<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: ses_mem.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>ses_mem.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: ses_mem.c,v 1.28 2007/12/07 16:37:56 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00013 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00014 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00015 <span class="preprocessor">#include &lt;time.h&gt;</span>
00016 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00017 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00018 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00019 <span class="preprocessor">#include &lt;klone/session.h&gt;</span>
00020 <span class="preprocessor">#include &lt;klone/request.h&gt;</span>
00021 <span class="preprocessor">#include &lt;klone/context.h&gt;</span>
00022 <span class="preprocessor">#include &lt;<a class="code" href="response_8h.html">klone/response.h</a>&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/vars.h&gt;</span>
00024 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00025 <span class="preprocessor">#include &lt;klone/atom.h&gt;</span>
00026 <span class="preprocessor">#include &lt;klone/ses_prv.h&gt;</span>
00027 <span class="preprocessor">#include &lt;klone/ppc.h&gt;</span>
00028 <span class="preprocessor">#include &lt;klone/ppc_cmd.h&gt;</span>
00029 
00030 <span class="keyword">enum</span> { SESSION_FILENAME_MAX_LENGTH = 256 };
00031 
00032 <span class="keyword">struct </span>enc_ses_mem_s
00033 {
00034     time_t mtime;                                   <span class="comment">/* modification time    */</span>
00035     <span class="keywordtype">char</span> filename[SESSION_FILENAME_MAX_LENGTH];     <span class="comment">/* session filename     */</span>
00036     size_t size;                                    <span class="comment">/* data size            */</span>
00037     <span class="keywordtype">char</span> data[1];                                   <span class="comment">/* data block           */</span>
00038 };
00039 
00040 <span class="keyword">typedef</span> <span class="keyword">struct </span>enc_ses_mem_s enc_ses_mem_t;
00041 
00042 <span class="keyword">static</span> <span class="keywordtype">int</span> so_atom_delete_oldest(session_opt_t *so)
00043 {
00044     atom_t *atom, *oldest;
00045     size_t count, i;
00046 
00047     dbg_err_if (so == NULL);
00048 
00049     count = atoms_count(so-&gt;atoms);
00050     nop_err_if(count == 0);
00051 
00052     dbg_err_if(atoms_getn(so-&gt;atoms, 0, &amp;oldest));
00053     <span class="keywordflow">for</span>(i = 1; i &lt; count; ++i)
00054     {
00055         dbg_err_if(atoms_getn(so-&gt;atoms, i, &amp;atom));
00056 
00057         <span class="comment">/* save if older */</span>
00058         <span class="keywordflow">if</span>(atom-&gt;arg &lt;= oldest-&gt;arg)
00059             oldest = atom;
00060     }
00061 
00062     dbg_err_if(atoms_remove(so-&gt;atoms, oldest));
00063 
00064     <span class="keywordflow">return</span> 0;
00065 err:
00066     <span class="keywordflow">return</span> ~0;
00067 }
00068 
00069 <span class="keyword">static</span> <span class="keywordtype">int</span> session_delete_oldest(session_opt_t *so)
00070 {
00071     ppc_t *ppc;
00072 
00073     dbg_err_if (so == NULL);
00074 
00075     <span class="keywordflow">if</span>(ctx-&gt;pipc)
00076     {   <span class="comment">/* children context, delete parent atom */</span>
00077         ppc = server_get_ppc(ctx-&gt;server);
00078         dbg_err_if(ppc == NULL);
00079 
00080         dbg_err_if(ppc_write(ppc, ctx-&gt;pipc, PPC_CMD_MSES_DELOLD, <span class="stringliteral">""</span>, 1) &lt; 0);
00081 
00082         <span class="comment">/* delete it from the local copy of atom list */</span>
00083         dbg_err_if(so_atom_delete_oldest(so));
00084     } <span class="keywordflow">else</span> {
00085         <span class="comment">/* parent context */</span>
00086         dbg_err_if(so_atom_delete_oldest(so));
00087     }
00088 
00089     <span class="keywordflow">return</span> 0;
00090 err:
00091     <span class="keywordflow">return</span> ~0;
00092 }
00093 
00094 <span class="keyword">static</span> <span class="keywordtype">int</span> so_atom_remove(session_opt_t *so, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>)
00095 {
00096     atom_t *atom = NULL;
00097 
00098     dbg_err_if (so == NULL);
00099     dbg_err_if (<span class="keywordtype">id</span> == NULL);
00100 
00101     <span class="comment">/* find the atom bound to this session */</span>
00102     <span class="keywordflow">if</span>(atoms_get(so-&gt;atoms, <span class="keywordtype">id</span>, &amp;atom))
00103         <span class="keywordflow">return</span> 0;
00104 
00105     <span class="comment">/* remove it from the list */</span>
00106     dbg_err_if(atoms_remove(so-&gt;atoms, atom));
00107 
00108     atom_free(atom);
00109 
00110     <span class="keywordflow">return</span> 0;
00111 err:
00112     <span class="keywordflow">return</span> ~0;
00113 }
00114 
00115 
00116 <span class="keyword">static</span> <span class="keywordtype">int</span> so_atom_add(session_opt_t *so, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <span class="keywordtype">char</span> *buf, 
00117     size_t size, <span class="keywordtype">void</span> *arg)
00118 {
00119     atom_t *atom = NULL, *old = NULL;
00120     size_t new_size, old_found = 0;
00121 
00122     dbg_err_if (so == NULL);
00123     dbg_err_if (<span class="keywordtype">id</span> == NULL);
00124     dbg_err_if (buf == NULL);
00125 
00126     <span class="comment">/* get the old atom associated to this id */</span>
00127     <span class="keywordflow">if</span>(!atoms_get(so-&gt;atoms, <span class="keywordtype">id</span>, &amp;old))
00128         old_found = 1;
00129 
00130     <span class="comment">/* delete the oldest session if there are already max_count sessions */</span>
00131     <span class="keywordflow">if</span>(so-&gt;max_count &amp;&amp; atoms_count(so-&gt;atoms) - old_found &gt;= so-&gt;max_count)
00132         dbg_err_if(session_delete_oldest(so));
00133 
00134     <span class="comment">/* delete the oldest session(s) if we are using already mem_limit bytes */</span>
00135     <span class="keywordflow">if</span>(so-&gt;mem_limit)
00136     {
00137         warn_err_ifm(size &gt; so-&gt;mem_limit, 
00138             <span class="stringliteral">"session size is bigger the memory.limit, save aborted..."</span>);
00139         <span class="keywordflow">for</span>(;;)
00140         {
00141             <span class="comment">/* new_size = size of all atoms + size of the atom we're going to</span>
00142 <span class="comment">               add - the size of the atom (if found) we're going to remove */</span>
00143             new_size = atoms_size(so-&gt;atoms) + size - (old ? old-&gt;size : 0);
00144             <span class="keywordflow">if</span>(atoms_count(so-&gt;atoms) &amp;&amp; new_size &gt; so-&gt;mem_limit)
00145                 dbg_err_if(session_delete_oldest(so));
00146             <span class="keywordflow">else</span>
00147                 <span class="keywordflow">break</span>;
00148         }
00149     }
00150 
00151     <span class="comment">/* create a new atom */</span>
00152     dbg_err_if(atom_create(<span class="keywordtype">id</span>, buf, size, arg, &amp;atom));
00153 
00154     <span class="comment">/* add it to the list */</span>
00155     dbg_err_if(atoms_add(so-&gt;atoms, atom));
00156 
00157     <span class="comment">/* remove the old atom associated to this id */</span>
00158     <span class="keywordflow">if</span>(old)
00159     {
00160         dbg_err_if(atoms_remove(so-&gt;atoms, old));
00161         atom_free(old);
00162     }
00163 
00164     <span class="keywordflow">return</span> 0;
00165 err:
00166     <span class="keywordflow">if</span>(atom)
00167         atom_free(atom);
00168     <span class="keywordflow">return</span> ~0;
00169 }
00170 
00171 
00172 <span class="comment">/* [parent] remove a sessioin*/</span>
00173 <span class="keyword">static</span> <span class="keywordtype">int</span> session_cmd_remove(ppc_t *ppc, <span class="keywordtype">int</span> fd, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cmd, 
00174     <span class="keywordtype">char</span> *data, size_t size, <span class="keywordtype">void</span> *vso)
00175 {
00176     session_opt_t *so = vso;
00177 
00178     u_unused_args(ppc, fd, cmd, size);
00179 
00180     dbg_err_if (data == NULL);
00181     dbg_err_if (vso == NULL);
00182 
00183     dbg_err_if(so_atom_remove(so, data <span class="comment">/* filename */</span>));
00184 
00185     <span class="keywordflow">return</span> 0;
00186 err:
00187     <span class="keywordflow">return</span> ~0;
00188 }
00189 
00190 <span class="comment">/* [parent] delete oldest session */</span>
00191 <span class="keyword">static</span> <span class="keywordtype">int</span> session_cmd_delold(ppc_t *ppc, <span class="keywordtype">int</span> fd, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cmd, 
00192     <span class="keywordtype">char</span> *data, size_t size, <span class="keywordtype">void</span> *vso)
00193 {
00194     session_opt_t *so = vso;
00195 
00196     u_unused_args(ppc, fd, cmd, data, size);
00197 
00198     dbg_err_if (vso == NULL);
00199 
00200     dbg_err_if (so_atom_delete_oldest(so));
00201 
00202     <span class="keywordflow">return</span> 0;
00203 err:
00204     <span class="keywordflow">return</span> ~0;
00205 }
00206 
00207 <span class="comment">/* [parent] save a session */</span>
00208 <span class="keyword">static</span> <span class="keywordtype">int</span> session_cmd_save(ppc_t *ppc, <span class="keywordtype">int</span> fd, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cmd, <span class="keywordtype">char</span> *data, 
00209     size_t size, <span class="keywordtype">void</span> *vso)
00210 {
00211     session_opt_t *so = vso;
00212     enc_ses_mem_t *esm = (enc_ses_mem_t*)data;
00213 
00214     u_unused_args(ppc, fd, cmd, size);
00215 
00216     dbg_err_if (vso == NULL);
00217     dbg_err_if (data == NULL);
00218 
00219     dbg_err_if(so_atom_add(so, esm-&gt;filename, esm-&gt;data, esm-&gt;size, 
00220         (<span class="keywordtype">void</span>*)esm-&gt;mtime));
00221 
00222     <span class="keywordflow">return</span> 0;
00223 err:
00224     <span class="keywordflow">return</span> ~0;
00225 }
00226 
00227 <span class="comment">/* [parent] get session data */</span>
00228 <span class="keyword">static</span> <span class="keywordtype">int</span> session_cmd_get(ppc_t *ppc, <span class="keywordtype">int</span> fd, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cmd, <span class="keywordtype">char</span> *data, 
00229     size_t size, <span class="keywordtype">void</span> *vso)
00230 {
00231     <span class="keyword">enum</span> { BUFSZ = 4096 };
00232     session_opt_t *so = vso;
00233     enc_ses_mem_t *esm = NULL;
00234     atom_t *atom = NULL;
00235     <span class="keywordtype">char</span> buf[BUFSZ];
00236     size_t esm_size;
00237 
00238     u_unused_args(cmd, size);
00239 
00240     dbg_err_if (ppc == NULL);
00241     dbg_err_if (vso == NULL);
00242     dbg_err_if (data == NULL);
00243     dbg_err_if (strlen(data) &gt; SESSION_FILENAME_MAX_LENGTH);
00244 
00245     <span class="comment">/* find the atom whose name is stored into 'data' buffer */</span>
00246     nop_err_if(atoms_get(so-&gt;atoms, data, &amp;atom));
00247 
00248     <span class="comment">/* if the buffer on the stack is big enough use it, otherwise alloc a </span>
00249 <span class="comment">       bigger one on the heap */</span>
00250     <span class="keywordflow">if</span>((esm_size = <span class="keyword">sizeof</span>(enc_ses_mem_t) + atom-&gt;size) &gt; BUFSZ)
00251     {
00252         esm = u_malloc(1 + esm_size);
00253         dbg_err_if(esm == NULL);
00254     } <span class="keywordflow">else</span>
00255         esm = (enc_ses_mem_t*)buf;
00256         
00257     <span class="comment">/* fill the enc_ses_mem_t struct */</span>
00258     esm-&gt;mtime = (time_t)atom-&gt;arg;
00259     strncpy(esm-&gt;filename, data, SESSION_FILENAME_MAX_LENGTH);
00260     esm-&gt;size = atom-&gt;size;
00261     memcpy(esm-&gt;data, atom-&gt;data, atom-&gt;size);
00262 
00263     dbg_err_if(ppc_write(ppc, fd, PPC_CMD_RESPONSE_OK, (<span class="keywordtype">char</span>*)esm,
00264         esm_size) &lt;= 0);
00265 
00266     <span class="keywordflow">if</span>(esm &amp;&amp; esm != (<span class="keywordtype">void</span>*)buf)
00267         U_FREE(esm);
00268 
00269     <span class="keywordflow">return</span> 0;
00270 err:
00271     <span class="keywordflow">if</span>(ppc)
00272         ppc_write(ppc, fd, PPC_CMD_RESPONSE_ERROR, (<span class="keywordtype">char</span> *)<span class="stringliteral">""</span>, 1);
00273     <span class="keywordflow">if</span>(esm &amp;&amp; esm != (<span class="keywordtype">void</span> *)buf)
00274         U_FREE(esm);
00275     <span class="keywordflow">return</span> ~0;
00276 }
00277 
00278 <span class="comment">/* add an atom to the list of global atoms */</span>
00279 <span class="keyword">static</span> <span class="keywordtype">int</span> session_mem_add(session_opt_t *so, <span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">char</span> *buf, 
00280     size_t size, time_t mtime)
00281 {
00282     atom_t *atom = NULL;
00283     enc_ses_mem_t *esm = NULL;
00284     ppc_t *ppc;
00285     size_t esize;
00286 
00287     dbg_err_if (so == NULL);
00288     dbg_err_if (filename == NULL);
00289     dbg_err_if (buf == NULL);
00290 
00291     <span class="keywordflow">if</span>(ctx-&gt;pipc)
00292     {   <span class="comment">/* children context */</span>
00293         ppc = server_get_ppc(ctx-&gt;server);
00294         dbg_err_if(ppc == NULL);
00295 
00296         <span class="comment">/* build the encoded parameters structure */</span>
00297         esize = size + <span class="keyword">sizeof</span>(enc_ses_mem_t);
00298         esm = (enc_ses_mem_t*)u_malloc(esize);
00299         dbg_err_if(esm == NULL);
00300 
00301         <span class="comment">/* fill esm fields */</span>
00302         esm-&gt;mtime = time(0);
00303         esm-&gt;size = size;
00304         dbg_err_if(strlen(filename) &gt; SESSION_FILENAME_MAX_LENGTH); 
00305         strncpy(esm-&gt;filename, filename, SESSION_FILENAME_MAX_LENGTH);
00306         memcpy(esm-&gt;data, buf, size);
00307 
00308         <span class="comment">/* send the command request */</span>
00309         dbg_err_if(ppc_write(ppc, ctx-&gt;pipc, PPC_CMD_MSES_SAVE, 
00310             (<span class="keywordtype">char</span>*)esm, esize) &lt; 0);
00311 
00312         U_FREE(esm);
00313 
00314         <span class="comment">/* add it to the local copy of atom list */</span>
00315         dbg_err_if(so_atom_add(so, filename, buf, size, (<span class="keywordtype">void</span>*)mtime));
00316 
00317     } <span class="keywordflow">else</span> {
00318         <span class="comment">/* parent context */</span>
00319         dbg_err_if(so_atom_add(so, filename, buf, size, (<span class="keywordtype">void</span>*)mtime));
00320     }
00321 
00322     <span class="keywordflow">return</span> 0;
00323 err:
00324     U_FREE(esm);
00325     <span class="keywordflow">if</span>(atom)
00326         atom_free(atom);
00327     <span class="keywordflow">return</span> ~0;
00328 }
00329 
00330 
00331 <span class="keyword">static</span> <span class="keywordtype">int</span> session_mem_save(session_t *ss)
00332 {
00333     <span class="keywordtype">char</span> *buf = NULL;
00334     size_t sz;
00335 
00336     dbg_err_if (ss == NULL);
00337     
00338     <span class="comment">/* save the session data to freshly alloc'd buf of size sz */</span>
00339     dbg_err_if(session_prv_save_to_buf(ss, &amp;buf, &amp;sz));
00340 
00341     <span class="comment">/* add the session to the in-memory session list */</span>
00342     dbg_err_if(session_mem_add(ss-&gt;so, ss-&gt;filename, buf, sz, time(0)));
00343 
00344     U_FREE(buf);
00345 
00346     <span class="keywordflow">return</span> 0;
00347 err:
00348     U_FREE(buf);
00349     <span class="keywordflow">return</span> ~0;
00350 }
00351 
00352 <span class="keyword">static</span> <span class="keywordtype">int</span> session_mem_load(session_t *ss)
00353 {
00354     <span class="keyword">enum</span> { BUFSZ = 4096 };
00355     atom_t *atom;
00356     <span class="keywordtype">char</span> buf[BUFSZ];
00357     size_t size;
00358     enc_ses_mem_t *esm;
00359     ppc_t *ppc;
00360     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cmd;
00361 
00362     dbg_err_if (ss == NULL);
00363     nop_err_if (ss-&gt;filename == NULL || strlen(ss-&gt;filename) == 0);
00364 
00365     <span class="comment">/* in fork and iterative model we can get the session from the current</span>
00366 <span class="comment">       address space, in prefork we must ask the parent for a fresh copy of </span>
00367 <span class="comment">       the session */</span>
00368     <span class="keywordflow">if</span>(ctx-&gt;backend &amp;&amp; ctx-&gt;backend-&gt;model == SERVER_MODEL_PREFORK)
00369     {   <span class="comment">/* get the session data through ppc */</span>
00370         ppc = server_get_ppc(ctx-&gt;server);
00371         dbg_err_if(ppc == NULL);
00372 
00373         <span class="comment">/* send a get request */</span>
00374         dbg_err_if(ppc_write(ppc, ctx-&gt;pipc, PPC_CMD_MSES_GET, ss-&gt;filename, 
00375             strlen(ss-&gt;filename) + 1) &lt; 0);
00376 
00377         <span class="comment">/* get the response from the parent */</span>
00378         dbg_err_if((size = ppc_read(ppc, ctx-&gt;pipc, &amp;cmd, buf, BUFSZ)) &lt;= 0);
00379 
00380         nop_err_if(cmd != PPC_CMD_RESPONSE_OK);
00381 
00382         <span class="comment">/* load session from esm */</span>
00383         esm = (enc_ses_mem_t*)buf;
00384         ss-&gt;mtime = esm-&gt;mtime;
00385         dbg_err_if(session_prv_load_from_buf(ss, esm-&gt;data, esm-&gt;size));
00386 
00387     } <span class="keywordflow">else</span> {
00388         <span class="comment">/* find the file into the atom list */</span>
00389         <span class="keywordflow">if</span>(atoms_get(ss-&gt;so-&gt;atoms, ss-&gt;filename, &amp;atom))
00390             <span class="keywordflow">return</span> ~0; <span class="comment">/* not found */</span>
00391 
00392         <span class="comment">/* copy stored mtime */</span>
00393         ss-&gt;mtime = (time_t)atom-&gt;arg;
00394 
00395         <span class="comment">/* load session from atom-&gt;data */</span>
00396         dbg_err_if(session_prv_load_from_buf(ss, atom-&gt;data, atom-&gt;size));
00397     }
00398 
00399     <span class="keywordflow">return</span> 0;
00400 err:
00401     <span class="keywordflow">return</span> ~0;
00402 }
00403 
00404 <span class="keyword">static</span> <span class="keywordtype">int</span> session_mem_remove(session_t *ss)
00405 {
00406     ppc_t *ppc;
00407 
00408     dbg_err_if (ss == NULL);
00409     
00410     <span class="keywordflow">if</span>(ctx-&gt;pipc)
00411     {   <span class="comment">/* children context */</span>
00412         ppc = server_get_ppc(ctx-&gt;server);
00413         dbg_err_if(ppc == NULL);
00414 
00415         dbg_err_if(ppc_write(ppc, ctx-&gt;pipc, PPC_CMD_MSES_REMOVE, ss-&gt;filename, 
00416             strlen(ss-&gt;filename) + 1) &lt; 0);
00417 
00418         <span class="comment">/* remove the session-atom from the (local copy) atom list */</span>
00419         dbg_err_if(so_atom_remove(ss-&gt;so, ss-&gt;filename));
00420     } <span class="keywordflow">else</span> {
00421         <span class="comment">/* parent context */</span>
00422         dbg_err_if(so_atom_remove(ss-&gt;so, ss-&gt;filename));
00423     }
00424 
00425     <span class="keywordflow">return</span> 0;
00426 err:
00427     <span class="keywordflow">return</span> ~0;
00428 }
00429 
00430 <span class="keyword">static</span> <span class="keywordtype">int</span> session_mem_term(session_t *ss)
00431 {
00432     <span class="comment">/* nothing to do */</span>
00433     u_unused_args(ss);
00434     <span class="keywordflow">return</span> 0;
00435 }
00436 
00437 <span class="keywordtype">int</span> session_mem_create(session_opt_t *so, request_t *rq, response_t *rs, 
00438         session_t **pss)
00439 {
00440     session_t *ss = NULL;
00441 
00442     dbg_err_if (so == NULL);
00443     dbg_err_if (rq == NULL);
00444     dbg_err_if (rs == NULL);
00445     dbg_err_if (pss == NULL);
00446 
00447     ss = u_zalloc(<span class="keyword">sizeof</span>(session_t));
00448     dbg_err_if(ss == NULL);
00449 
00450     ss-&gt;load = session_mem_load;
00451     ss-&gt;save = session_mem_save;
00452     ss-&gt;remove = session_mem_remove;
00453     ss-&gt;term = session_mem_term;
00454     ss-&gt;mtime = time(0);
00455     ss-&gt;so = so;
00456 
00457     dbg_err_if(session_prv_init(ss, rq, rs));
00458 
00459     *pss = ss;
00460 
00461     <span class="keywordflow">return</span> 0;
00462 err:
00463     <span class="keywordflow">if</span>(ss)
00464         session_free(ss);
00465     <span class="keywordflow">return</span> ~0;
00466 }
00467 
00468 <span class="comment">/* this function will be called once by the server during startup */</span>
00469 <span class="keywordtype">int</span> session_mem_module_init(u_config_t *config, session_opt_t *so)
00470 {
00471     ppc_t *ppc;
00472     u_config_t *c;
00473     <span class="keyword">const</span> <span class="keywordtype">char</span> *v;
00474 
00475     <span class="comment">/* config may be NULL */</span>
00476     dbg_err_if (so == NULL);
00477 
00478     <span class="comment">/* defaults */</span>
00479     so-&gt;max_count = 0;  <span class="comment">/* no limits */</span>
00480     so-&gt;mem_limit = 0;  <span class="comment">/* no limits */</span>
00481 
00482     <span class="keywordflow">if</span>(config)
00483     {
00484         <span class="comment">/* get configuration parameters */</span>
00485         dbg_err_if(u_config_get_subkey(config, <span class="stringliteral">"memory"</span>, &amp;c));
00486 
00487         <span class="keywordflow">if</span>((v = u_config_get_subkey_value(c, <span class="stringliteral">"max_count"</span>)) != NULL)
00488             so-&gt;max_count = atoi(v);
00489 
00490         <span class="keywordflow">if</span>((v = u_config_get_subkey_value(c, <span class="stringliteral">"limit"</span>)) != NULL)
00491             so-&gt;mem_limit = atoi(v);
00492     }
00493 
00494     <span class="comment">/* setup ppc parent &lt;-&gt; child channel */</span>
00495     ppc = server_get_ppc(ctx-&gt;server);
00496     dbg_err_if(ppc == NULL);
00497 
00498     <span class="comment">/* create an atom list to store in-memory session data */</span>
00499     dbg_err_if(atoms_create(&amp;so-&gt;atoms));
00500 
00501     <span class="comment">/* register PPC commands callbacks */</span>
00502     dbg_err_if(ppc_register(ppc, PPC_CMD_MSES_SAVE, session_cmd_save, so));
00503     dbg_err_if(ppc_register(ppc, PPC_CMD_MSES_GET, session_cmd_get, so));
00504     dbg_err_if(ppc_register(ppc, PPC_CMD_MSES_DELOLD, session_cmd_delold, so));
00505     dbg_err_if(ppc_register(ppc, PPC_CMD_MSES_REMOVE, session_cmd_remove, so));
00506 
00507     <span class="keywordflow">return</span> 0;
00508 err:
00509     <span class="keywordflow">return</span> ~0;
00510 }
00511 
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


