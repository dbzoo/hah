<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LibU: log.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>log.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005-2008 by KoanLogic s.r.l. - All rights reserved.  </span>
00003 <span class="comment"> */</span>
00004 
00005 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> rcsid[] =
00006     <span class="stringliteral">"$Id: log.c,v 1.7 2008/09/01 08:58:54 tho Exp $"</span>;
00007 
00008 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00009 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00010 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00011 <span class="preprocessor">#include &lt;string.h&gt;</span>
00012 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00013 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
00014 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00015 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00016 <span class="preprocessor">#include &lt;toolbox/log.h&gt;</span>
00017 <span class="preprocessor">#include &lt;toolbox/carpal.h&gt;</span>
00018 <span class="preprocessor">#include &lt;toolbox/misc.h&gt;</span>
00019 <span class="preprocessor">#include &lt;u/missing.h&gt;</span>
00020 <span class="preprocessor">#include &lt;missing/syslog.h&gt;</span>
00021 
00022 <span class="comment">/* applications that use libu will defined their own "int facility" variable */</span>
<a name="l00023"></a><a class="code" href="group__log.html#ga5">00023</a> <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group__log.html#ga0">facility</a>;
00024 
00025 <span class="comment">/* log hook. if not-zero use this function to write log messages */</span>
00026 <span class="keyword">static</span> <a class="code" href="group__log.html#ga1">u_log_hook_t</a> hook = NULL;
00027 <span class="keyword">static</span> <span class="keywordtype">void</span> *hook_arg = NULL;
00028 
00029 <span class="keyword">static</span> <a class="code" href="group__log.html#ga2">u_log_lock_t</a> f_lock = NULL;
00030 <span class="keyword">static</span> <span class="keywordtype">void</span> *f_lock_arg = NULL;
00031 
00032 <span class="keyword">static</span> <a class="code" href="group__log.html#ga3">u_log_unlock_t</a> f_unlock = NULL;
00033 <span class="keyword">static</span> <span class="keywordtype">void</span> *f_unlock_arg = NULL;
00034 
00035 <span class="keyword">enum</span> { STRERR_BUFSZ = 128, ERRMSG_BUFSZ = 256 };
00036 
00037 <span class="preprocessor">#ifdef OS_WIN</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define err_type DWORD</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define save_errno(var) var = GetLastError();</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define restore_errno(var) SetLastError(var);</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define err_type int</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define save_errno(var) var = errno;</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define restore_errno(var) errno = var;</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00046 <span class="preprocessor"></span>
<a name="l00047"></a><a class="code" href="group__log.html#ga13">00047</a> <span class="keywordtype">int</span> <a class="code" href="group__log.html#ga13">u_log_set_lock</a>(<a class="code" href="group__log.html#ga2">u_log_lock_t</a> f, <span class="keywordtype">void</span> *arg)
00048 {
00049     f_lock = f;
00050     f_lock_arg = arg;
00051 
00052     <span class="keywordflow">return</span> 0;
00053 }
00054 
<a name="l00055"></a><a class="code" href="group__log.html#ga14">00055</a> <span class="keywordtype">int</span> <a class="code" href="group__log.html#ga14">u_log_set_unlock</a>(<a class="code" href="group__log.html#ga3">u_log_unlock_t</a> f, <span class="keywordtype">void</span> *arg)
00056 {
00057     f_unlock = f;
00058     f_unlock_arg = arg;
00059 
00060     <span class="keywordflow">return</span> 0;
00061 }
00062 
00063 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> u_log_lock(<span class="keywordtype">void</span>)
00064 {
00065     <span class="keywordflow">if</span>(f_lock)
00066         f_lock(f_lock_arg);
00067 }
00068 
00069 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> u_log_unlock(<span class="keywordtype">void</span>)
00070 {
00071     <span class="keywordflow">if</span>(f_unlock)
00072         f_unlock(f_unlock_arg);
00073 }
00074 
00075 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* u_log_label(<span class="keywordtype">int</span> lev)
00076 {
00077     <span class="keywordflow">switch</span>(lev)
00078     {
00079     <span class="keywordflow">case</span> LOG_DEBUG:  
00080         <span class="keywordflow">return</span> <span class="stringliteral">"dbg"</span>; 
00081     <span class="keywordflow">case</span> LOG_INFO:   
00082         <span class="keywordflow">return</span> <span class="stringliteral">"inf"</span>; 
00083     <span class="keywordflow">case</span> LOG_NOTICE: 
00084         <span class="keywordflow">return</span> <span class="stringliteral">"ntc"</span>; 
00085     <span class="keywordflow">case</span> LOG_WARNING:
00086         <span class="keywordflow">return</span> <span class="stringliteral">"wrn"</span>;
00087     <span class="keywordflow">case</span> LOG_ERR:    
00088         <span class="keywordflow">return</span> <span class="stringliteral">"err"</span>;
00089     <span class="keywordflow">case</span> LOG_CRIT:   
00090         <span class="keywordflow">return</span> <span class="stringliteral">"crt"</span>;
00091     <span class="keywordflow">case</span> LOG_ALERT:   
00092         <span class="keywordflow">return</span> <span class="stringliteral">"alr"</span>;
00093     <span class="keywordflow">case</span> LOG_EMERG:   
00094         <span class="keywordflow">return</span> <span class="stringliteral">"emg"</span>;
00095     <span class="keywordflow">default</span>: 
00096         syslog(LOG_WARNING, 
00097                <span class="stringliteral">"[wrn][%d:::] unknown log level: %d"</span>, getpid(), lev);
00098         <span class="keywordflow">return</span> <span class="stringliteral">"unk"</span>;
00099     }
00100 }
00101 
00102 <span class="keyword">static</span> <span class="keywordtype">int</span> u_log(<span class="keywordtype">int</span> fac, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
00103 {
00104     va_list ap;
00105     <span class="keywordtype">char</span> buf[U_MAX_LOG_LENGTH];
00106 
00107     va_start(ap, fmt); 
00108 
00109     u_log_lock();
00110 
00111     <span class="keywordflow">if</span>(hook)
00112     {
00113         <span class="keywordflow">if</span>(vsnprintf(buf, U_MAX_LOG_LENGTH, fmt, ap) &gt; U_MAX_LOG_LENGTH)
00114         {
00115             va_end(ap);
00116             u_log_unlock();
00117             <span class="keywordflow">return</span> ~0; <span class="comment">/* buffer too small */</span>
00118         }
00119         buf[U_MAX_LOG_LENGTH - 1] = 0; 
00120         hook(hook_arg, level, buf);
00121     } <span class="keywordflow">else</span> 
00122         vsyslog(fac | level, fmt, ap);
00123 
00124     u_log_unlock();
00125 
00126     va_end(ap);
00127 
00128     <span class="keywordflow">return</span> 0;
00129 }
00130 
<a name="l00131"></a><a class="code" href="group__log.html#ga19">00131</a> <span class="keywordtype">int</span> <a class="code" href="group__log.html#ga19">u_log_set_hook</a>(<a class="code" href="group__log.html#ga1">u_log_hook_t</a> func, <span class="keywordtype">void</span> *arg, <a class="code" href="group__log.html#ga1">u_log_hook_t</a> *old, <span class="keywordtype">void</span> **parg)
00132 {
00133     u_log_lock();
00134 
00135     <span class="keywordflow">if</span>(old)
00136         *old = hook;
00137     <span class="keywordflow">if</span>(parg)
00138         *parg = hook_arg;
00139 
00140     hook = func;
00141     hook_arg = arg;
00142 
00143     u_log_unlock();
00144 
00145     <span class="keywordflow">return</span> 0;
00146 }
00147 
00148 <span class="keywordtype">int</span> u_log_write_ex(<span class="keywordtype">int</span> fac, <span class="keywordtype">int</span> lev, <span class="keywordtype">int</span> flags, <span class="keywordtype">int</span> err, <span class="keyword">const</span> <span class="keywordtype">char</span>* file, 
00149     <span class="keywordtype">int</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keyword">const</span> <span class="keywordtype">char</span>* fmt, ...)
00150 {
00151     va_list ap;
00152     err_type savederr;
00153     <span class="keywordtype">int</span> rc;
00154     <span class="keywordtype">char</span> msg[U_MAX_LOG_LENGTH], strerr[STRERR_BUFSZ], errmsg[STRERR_BUFSZ];
00155 
00156     save_errno(savederr);
00157 
00158     <span class="comment">/* build the message to send to the log system */</span>
00159     va_start(ap, fmt); 
00160     rc = vsnprintf(msg, U_MAX_LOG_LENGTH, fmt, ap);
00161     va_end(ap);
00162 
00163     <span class="keywordflow">if</span>(rc &gt;= U_MAX_LOG_LENGTH)
00164         <span class="keywordflow">goto</span> err; <span class="comment">/* message too long */</span>
00165 
00166     <span class="comment">/* init empty strings */</span>
00167     errmsg[0] = strerr[0] = 0;
00168 
00169     <span class="keywordflow">if</span>(err)
00170     {
00171         <a class="code" href="group__log.html#ga22">u_strerror_r</a>(err, strerr, <span class="keyword">sizeof</span>(strerr));
00172         snprintf(errmsg, <span class="keyword">sizeof</span>(errmsg), <span class="stringliteral">"[errno: %d, %s]"</span>, err, strerr);
00173         errmsg[<span class="keyword">sizeof</span>(errmsg) - 1] = 0; <span class="comment">/* paranoid set */</span>
00174     } 
00175 
00176     <span class="comment">/* ok, send the msg to the logger */</span>
00177     <span class="keywordflow">if</span>(flags &amp; LOG_WRITE_FLAG_CTX)
00178         u_log(fac, lev, <span class="stringliteral">"[%s][%d:%s:%d:%s] %s %s"</span>, 
00179                u_log_label(lev), getpid(), file, line, func, msg, errmsg);
00180     <span class="keywordflow">else</span>
00181         u_log(fac, lev, <span class="stringliteral">"[%s][%d:::] %s %s"</span>, 
00182                u_log_label(lev), getpid(), msg, errmsg);
00183 
00184     restore_errno(savederr);
00185     <span class="keywordflow">return</span> 0;
00186 err:
00187     restore_errno(savederr);
00188     <span class="keywordflow">return</span> ~0;
00189 }
00190 
00191 <span class="keywordtype">int</span> u_console_write_ex(<span class="keywordtype">int</span> err, <span class="keyword">const</span> <span class="keywordtype">char</span>* file, <span class="keywordtype">int</span> line, 
00192     <span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keyword">const</span> <span class="keywordtype">char</span>* fmt, ...)
00193 {
00194     err_type savederr;
00195     va_list ap;
00196     <span class="keywordtype">int</span> rc;
00197     <span class="keywordtype">char</span> strerr[STRERR_BUFSZ], errmsg[STRERR_BUFSZ];
00198 
00199     <span class="comment">/* when writing to console the following parameters are not used */</span>
00200     file = NULL;
00201     line = 0;
00202     func = NULL;
00203 
00204     save_errno(savederr);
00205 
00206     <span class="comment">/* build the message to send to the log system */</span>
00207     va_start(ap, fmt); 
00208 
00209     <span class="comment">/* write the message to the standard error */</span>
00210     rc = vfprintf(stderr, fmt, ap);
00211 
00212     va_end(ap);
00213 
00214     <span class="keywordflow">if</span>(rc &lt; 0)
00215         <span class="keywordflow">goto</span> err;
00216 
00217     <span class="comment">/* init empty strings */</span>
00218     errmsg[0] = strerr[0] = 0;
00219 
00220     <span class="keywordflow">if</span>(err)
00221     {
00222         <a class="code" href="group__log.html#ga22">u_strerror_r</a>(err, strerr, <span class="keyword">sizeof</span>(strerr));
00223         snprintf(errmsg, <span class="keyword">sizeof</span>(errmsg), <span class="stringliteral">"[errno: %d, %s]"</span>, err, strerr);
00224         errmsg[<span class="keyword">sizeof</span>(errmsg) - 1] = 0; <span class="comment">/* paranoid set */</span>
00225         fprintf(stderr, <span class="stringliteral">" %s\n"</span>, errmsg);
00226     } <span class="keywordflow">else</span>
00227         fprintf(stderr, <span class="stringliteral">"\n"</span>);
00228 
00229     restore_errno(savederr);
00230     <span class="keywordflow">return</span> 0;
00231 err:
00232     restore_errno(savederr);
00233     <span class="keywordflow">return</span> ~0;
00234 }
00235 
<a name="l00236"></a><a class="code" href="group__log.html#ga22">00236</a> <span class="keywordtype">int</span> <a class="code" href="group__log.html#ga22">u_strerror_r</a>(<span class="keywordtype">int</span> en, <span class="keywordtype">char</span> *msg, size_t sz)
00237 {
00238 
00239 <span class="preprocessor">#ifdef HAVE_STRERROR_R</span>
00240 <span class="preprocessor"></span>    <span class="keyword">enum</span> { BUFSZ = 256 };
00241     <span class="keywordtype">char</span> buf[BUFSZ] = { 0 };
00242 
00243     intptr_t rc;
00244 
00245     <span class="comment">/* assume POSIX prototype */</span>
00246     rc = (intptr_t)strerror_r(en, buf, BUFSZ);
00247 
00248     <span class="keywordflow">if</span>(rc == 0)
00249     {    <span class="comment">/* posix version, success */</span>
00250         strlcpy(msg, buf, sz);
00251     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(rc == -1 || (rc &gt; 0 &amp;&amp; rc &lt; 1024)) {
00252          <span class="comment">/* posix version, failed (returns -1 or an error number) */</span>
00253          <span class="keywordflow">goto</span> err;
00254     } <span class="keywordflow">else</span> {
00255         <span class="comment">/* glibc char*-returning version, always succeeds */</span>
00256         strlcpy(msg, (<span class="keywordtype">char</span>*)rc, sz);
00257     }
00258 <span class="preprocessor">#else</span>
00259 <span class="preprocessor"></span>    <span class="comment">/* there's not strerror_r, use strerror() instead */</span>
00260     <span class="keywordtype">char</span> *p;
00261 
00262     dbg_err_if((p = strerror(en)) == NULL);
00263 
00264     strlcpy(msg, p, sz);
00265 <span class="preprocessor">#endif</span>
00266 <span class="preprocessor"></span>
00267     <span class="keywordflow">return</span> 0;
00268 err:
00269     <span class="keywordflow">return</span> ~0;
00270 }
00271 
</pre></div><hr>
<div>
  <div style="text-align:left">
    <a href="http://www.koanlogic.com/kl/cont/gb/html/products.html">&larr;Products</a>
  </div>
  <div style="text-align:center;">
    &copy; 2005-2008 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
  </div>
</div>

</body>
</html>
