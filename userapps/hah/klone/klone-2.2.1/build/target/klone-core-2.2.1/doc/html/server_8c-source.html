<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: server.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>server.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: server.c,v 1.69 2009/08/15 22:12:33 stewy Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00013 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00014 <span class="preprocessor">#ifdef HAVE_SYS_WAIT</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/wait.h&gt;</span>
00016 <span class="preprocessor">#endif</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00018 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00019 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00020 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00021 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00022 <span class="preprocessor">#include &lt;klone/server.h&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/backend.h&gt;</span>
00024 <span class="preprocessor">#include &lt;klone/os.h&gt;</span>
00025 <span class="preprocessor">#include &lt;klone/timer.h&gt;</span>
00026 <span class="preprocessor">#include &lt;klone/context.h&gt;</span>
00027 <span class="preprocessor">#include &lt;klone/ppc.h&gt;</span>
00028 <span class="preprocessor">#include &lt;klone/ppc_cmd.h&gt;</span>
00029 <span class="preprocessor">#include &lt;klone/addr.h&gt;</span>
00030 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00031 <span class="preprocessor">#include &lt;klone/klog.h&gt;</span>
00032 <span class="preprocessor">#include &lt;klone/hook.h&gt;</span>
00033 <span class="preprocessor">#include &lt;klone/hookprv.h&gt;</span>
00034 <span class="preprocessor">#include &lt;klone/server_ppc_cmd.h&gt;</span>
00035 <span class="preprocessor">#include "server_s.h"</span>
00036 <span class="preprocessor">#include "child.h"</span>
00037 
00038 <span class="preprocessor">#define SERVER_MAX_BACKENDS 8</span>
00039 <span class="preprocessor"></span>
00040 <span class="keyword">enum</span> watch_fd_e
00041 {
00042     WATCH_FD_READ   = 1 &lt;&lt; 1,
00043     WATCH_FD_WRITE  = 1 &lt;&lt; 2,
00044     WATCH_FD_EXCP   = 1 &lt;&lt; 3
00045 };
00046 
00047 <span class="keyword">static</span> <span class="keywordtype">void</span> server_watch_fd(server_t *s, <span class="keywordtype">int</span> fd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mode);
00048 <span class="keyword">static</span> <span class="keywordtype">void</span> server_clear_fd(server_t *s, <span class="keywordtype">int</span> fd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mode);
00049 <span class="keyword">static</span> <span class="keywordtype">void</span> server_close_fd(server_t *s, <span class="keywordtype">int</span> fd);
00050 
00051 <span class="keyword">static</span> <span class="keywordtype">int</span> server_be_listen(backend_t *be)
00052 {
00053     <span class="keyword">enum</span> { DEFAULT_BACKLOG = 1024 };
00054     <span class="keywordtype">int</span> d = 0, backlog = 0, val = 1;
00055     u_config_t *subkey;
00056 
00057     dbg_return_if (be == NULL, ~0);
00058     dbg_return_if (be-&gt;addr == NULL, ~0);
00059 
00060     <span class="keywordflow">switch</span>(be-&gt;addr-&gt;type)
00061     {
00062         <span class="keywordflow">case</span> ADDR_IPV4:
00063             dbg_err_if((d = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0);
00064 <span class="preprocessor">            #ifndef OS_WIN</span>
00065 <span class="preprocessor"></span>            <span class="comment">/* on win with this flag more then on process will be allowed to</span>
00066 <span class="comment">               bind to the same port (SO_EXCLUSIVEADDRUSE is for releases </span>
00067 <span class="comment">               newer then Windows XP */</span>
00068             dbg_err_if(setsockopt(d, SOL_SOCKET, SO_REUSEADDR, (<span class="keywordtype">void</span> *)&amp;val, 
00069                 <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) &lt; 0);
00070 <span class="preprocessor">            #endif</span>
00071 <span class="preprocessor"></span>            dbg_err_if(bind(d, (<span class="keywordtype">void</span>*)&amp;be-&gt;addr-&gt;sa.sin, 
00072                 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in)));
00073             <span class="keywordflow">break</span>;
00074         <span class="keywordflow">case</span> ADDR_IPV6:
00075         <span class="keywordflow">case</span> ADDR_UNIX:
00076         <span class="keywordflow">default</span>:
00077             crit_err_if(<span class="stringliteral">"unupported addr type"</span>);
00078     }
00079 
00080     <span class="keywordflow">if</span>(!u_config_get_subkey(be-&gt;config, <span class="stringliteral">"backlog"</span>, &amp;subkey))
00081         backlog = atoi(u_config_get_value(subkey));
00082 
00083     <span class="keywordflow">if</span>(!backlog)
00084         backlog = DEFAULT_BACKLOG;
00085 
00086     dbg_err_if(listen(d, backlog));
00087 
00088     be-&gt;ld = d;
00089 
00090     <span class="keywordflow">return</span> 0;
00091 err:
00092     warn_strerror(errno);
00093     <span class="keywordflow">if</span>(d)
00094         close(d);
00095     <span class="keywordflow">return</span> ~0;
00096 }
00097 
00098 
00099 <span class="preprocessor">#ifdef OS_UNIX</span>
00100 <span class="preprocessor"></span><span class="comment">/* remove a child process whose pid is 'pid' to children list */</span>
00101 <span class="keyword">static</span> <span class="keywordtype">int</span> server_reap_child(server_t *s, pid_t pid)
00102 {
00103     child_t *child;
00104     backend_t *be;
00105 
00106     dbg_err_if (s == NULL);
00107     
00108     <span class="comment">/* get the child object */</span>
00109     dbg_err_if(children_get_by_pid(s-&gt;children, pid, &amp;child));
00110 
00111     <span class="comment">/* remove the child from the list */</span>
00112     dbg_err_if(children_del(s-&gt;children, child));
00113     be = child-&gt;be;
00114 
00115     <span class="comment">/* check that the minimum number of process are active */</span>
00116     be-&gt;nchild--;
00117     <span class="keywordflow">if</span>(be-&gt;nchild &lt; be-&gt;start_child)
00118         be-&gt;fork_child = be-&gt;start_child - be-&gt;nchild;
00119 
00120     U_FREE(child);
00121 
00122     <span class="keywordflow">return</span> 0;
00123 err:
00124     <span class="keywordflow">return</span> ~0;
00125 }
00126 
00127 <span class="comment">/* add a child to the list */</span>
00128 <span class="keyword">static</span> <span class="keywordtype">int</span> server_add_child(server_t *s, pid_t pid, backend_t *be)
00129 {
00130     child_t *child = NULL;
00131 
00132     dbg_err_if (s == NULL);
00133     dbg_err_if (be == NULL);
00134 
00135     dbg_err_if(child_create(pid, be, &amp;child));
00136 
00137     dbg_err_if(children_add(s-&gt;children, child));
00138 
00139     be-&gt;nchild++;
00140 
00141     <span class="keywordflow">return</span> 0;
00142 err:
00143     <span class="keywordflow">return</span> ~0;
00144 }
00145 
00146 <span class="comment">/* send 'sig' signal to all children process */</span>
00147 <span class="keyword">static</span> <span class="keywordtype">int</span> server_signal_children(server_t *s, <span class="keywordtype">int</span> sig)
00148 {
00149     child_t *child;
00150     ssize_t i;
00151 
00152     dbg_return_if (s == NULL, ~0);
00153     
00154     <span class="keywordflow">for</span>(i = children_count(s-&gt;children) - 1; i &gt;= 0; --i)
00155     {
00156         <span class="keywordflow">if</span>(!children_getn(s-&gt;children, i, &amp;child))
00157             dbg_err_if(kill(child-&gt;pid, sig) &lt; 0);
00158     }
00159 
00160     <span class="keywordflow">return</span> 0;
00161 err:
00162     dbg_strerror(errno);
00163     <span class="keywordflow">return</span> ~0;
00164 }
00165 <span class="preprocessor">#endif</span>
00166 <span class="preprocessor"></span>
00167 <span class="keyword">static</span> <span class="keywordtype">void</span> server_term_children(server_t *s)
00168 {
00169     dbg_ifb(s == NULL) <span class="keywordflow">return</span>;
00170 <span class="preprocessor">#ifdef OS_UNIX</span>
00171 <span class="preprocessor"></span>    server_signal_children(s, SIGTERM);
00172 <span class="preprocessor">#endif</span>
00173 <span class="preprocessor"></span>    <span class="keywordflow">return</span>;
00174 }
00175 
00176 <span class="keyword">static</span> <span class="keywordtype">void</span> server_kill_children(server_t *s)
00177 {
00178     dbg_ifb(s == NULL) <span class="keywordflow">return</span>;
00179 <span class="preprocessor">#ifdef OS_UNIX</span>
00180 <span class="preprocessor"></span>    server_signal_children(s, SIGKILL);
00181 <span class="preprocessor">#endif</span>
00182 <span class="preprocessor"></span>    <span class="keywordflow">return</span>;
00183 }
00184 
00185 <span class="keyword">static</span> <span class="keywordtype">void</span> server_sigint(<span class="keywordtype">int</span> sig)
00186 {
00187     u_unused_args(sig);
00188 
00189     warn(<span class="stringliteral">"SIGINT"</span>);
00190 
00191     <span class="keywordflow">if</span>(ctx &amp;&amp; ctx-&gt;server)
00192         server_stop(ctx-&gt;server);
00193     
00194     emb_term();
00195 }
00196 
00197 <span class="keyword">static</span> <span class="keywordtype">void</span> server_sigterm(<span class="keywordtype">int</span> sig)
00198 {
00199     u_unused_args(sig);
00200 
00201     <span class="comment">/* child process die immediately.</span>
00202 <span class="comment">     * note: don't call debug functions because the parent process could be</span>
00203 <span class="comment">     * already dead if the user used the "killall kloned" command */</span>
00204     <span class="keywordflow">if</span>(ctx-&gt;pipc)
00205         _exit(0); 
00206 
00207     warn(<span class="stringliteral">"SIGTERM"</span>);
00208 
00209     <span class="keywordflow">if</span>(ctx &amp;&amp; ctx-&gt;server)
00210         server_stop(ctx-&gt;server);
00211 }
00212 
00213 <span class="preprocessor">#ifdef OS_UNIX</span>
00214 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> server_sigchld(<span class="keywordtype">int</span> sig)
00215 {
00216     server_t *s = ctx-&gt;server;
00217 
00218     u_unused_args(sig);
00219 
00220     s-&gt;reap_children = 1;
00221 }
00222 
00223 <span class="keyword">static</span> <span class="keywordtype">void</span> server_waitpid(server_t *s)
00224 {
00225     pid_t pid = -1;
00226     <span class="keywordtype">int</span> status;
00227 
00228     dbg_ifb(s == NULL) <span class="keywordflow">return</span>;
00229     
00230     u_sig_block(SIGCHLD);
00231 
00232     <span class="comment">/* detach from child processes */</span>
00233     <span class="keywordflow">while</span>((pid = waitpid(-1, &amp;status, WNOHANG)) &gt; 0) 
00234     {
00235         <span class="keywordflow">if</span>(WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) != EXIT_SUCCESS)
00236             warn(<span class="stringliteral">"pid [%u], exit code [%d]"</span>, pid, WEXITSTATUS(status));
00237 
00238         <span class="keywordflow">if</span>(WIFSIGNALED(status))
00239             warn(<span class="stringliteral">"pid [%u], signal [%d]"</span>, pid, WTERMSIG(status));
00240 
00241         <span class="comment">/* decrement child count */</span>
00242         server_reap_child(s, pid);
00243     }
00244 
00245     s-&gt;reap_children = 0;
00246 
00247     u_sig_unblock(SIGCHLD);
00248 }
00249 <span class="preprocessor">#endif</span>
00250 <span class="preprocessor"></span>
00251 <span class="keyword">static</span> <span class="keywordtype">void</span> server_recalc_hfd(server_t *s)
00252 {
00253     <span class="keyword">register</span> <span class="keywordtype">int</span> i;
00254     fd_set *prdfds, *pwrfds, *pexfds;
00255 
00256     dbg_ifb(s == NULL) <span class="keywordflow">return</span>;
00257     
00258     prdfds = &amp;s-&gt;rdfds;
00259     pwrfds = &amp;s-&gt;wrfds;
00260     pexfds = &amp;s-&gt;exfds;
00261 
00262     <span class="comment">/* set s-&gt;hfd to highest value */</span>
00263     <span class="keywordflow">for</span>(i = s-&gt;hfd, s-&gt;hfd = 0; i &gt; 0; --i)
00264     {
00265         <span class="keywordflow">if</span>(FD_ISSET(i, prdfds) || FD_ISSET(i, pwrfds) || FD_ISSET(i, pexfds))
00266         {
00267             s-&gt;hfd = i;
00268             <span class="keywordflow">break</span>;
00269         }
00270     }
00271 }
00272 
00273 <span class="keyword">static</span> <span class="keywordtype">void</span> server_clear_fd(server_t *s, <span class="keywordtype">int</span> fd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mode)
00274 {
00275     dbg_ifb(s == NULL) <span class="keywordflow">return</span>;
00276 
00277     <span class="keywordflow">if</span>(mode &amp; WATCH_FD_READ)
00278         FD_CLR(fd, &amp;s-&gt;rdfds);
00279 
00280     <span class="keywordflow">if</span>(mode &amp; WATCH_FD_WRITE)
00281         FD_CLR(fd, &amp;s-&gt;wrfds);
00282 
00283     <span class="keywordflow">if</span>(mode &amp; WATCH_FD_EXCP)
00284         FD_CLR(fd, &amp;s-&gt;exfds);
00285 
00286     server_recalc_hfd(s);
00287 }
00288 
00289 <span class="keyword">static</span> <span class="keywordtype">void</span> server_watch_fd(server_t *s, <span class="keywordtype">int</span> fd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mode)
00290 {
00291     dbg_ifb(s == NULL) <span class="keywordflow">return</span>;
00292     dbg_ifb(fd &lt; 0) <span class="keywordflow">return</span>;
00293 
00294     <span class="keywordflow">if</span>(mode &amp; WATCH_FD_READ)
00295         FD_SET(fd, &amp;s-&gt;rdfds);
00296 
00297     <span class="keywordflow">if</span>(mode &amp; WATCH_FD_WRITE)
00298         FD_SET(fd, &amp;s-&gt;wrfds);
00299 
00300     <span class="keywordflow">if</span>(mode &amp; WATCH_FD_EXCP)
00301         FD_SET(fd, &amp;s-&gt;exfds);
00302 
00303     s-&gt;hfd = MAX(s-&gt;hfd, fd);
00304 }
00305 
00306 <span class="keyword">static</span> <span class="keywordtype">void</span> server_close_fd(server_t *s, <span class="keywordtype">int</span> fd)
00307 {
00308     dbg_ifb(s == NULL) <span class="keywordflow">return</span>;
00309     dbg_ifb(fd &lt; 0) <span class="keywordflow">return</span>;
00310 
00311     server_clear_fd(s, fd, WATCH_FD_READ | WATCH_FD_WRITE | WATCH_FD_EXCP);
00312     close(fd);
00313 }
00314 
00315 <span class="keyword">static</span> <span class="keywordtype">int</span> server_be_accept(server_t *s, backend_t *be, <span class="keywordtype">int</span> *pfd)
00316 {
00317     <span class="keyword">struct </span>sockaddr sa;
00318     <span class="keywordtype">int</span> sa_len = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr);
00319     <span class="keywordtype">int</span> ad;
00320 
00321     u_unused_args(s);
00322 
00323     dbg_return_if (be == NULL, ~0);
00324     dbg_return_if (pfd == NULL, ~0);
00325 
00326 again:
00327     ad = accept(be-&gt;ld, &amp;sa, &amp;sa_len);
00328     <span class="keywordflow">if</span>(ad == -1 &amp;&amp; errno == EINTR)
00329         <span class="keywordflow">goto</span> again; <span class="comment">/* interrupted */</span>
00330     dbg_err_if(ad == -1); <span class="comment">/* accept error */</span>
00331 
00332     *pfd = ad;
00333 
00334     <span class="keywordflow">return</span> 0;
00335 err:
00336     <span class="keywordflow">if</span>(ad &lt; 0)
00337         warn_strerror(errno);
00338     <span class="keywordflow">return</span> ~0;
00339 }
00340 
00341 <span class="keyword">static</span> <span class="keywordtype">int</span> server_backend_detach(server_t *s, backend_t *be)
00342 {
00343     s-&gt;nbackend--;
00344 
00345     dbg_return_if (s == NULL, ~0);
00346     dbg_return_if (be == NULL, ~0);
00347 
00348     addr_free(be-&gt;addr);
00349     be-&gt;server = NULL;
00350     be-&gt;addr = NULL;
00351     be-&gt;config = NULL;
00352 
00353     close(be-&gt;ld);
00354     be-&gt;ld = -1;
00355 
00356     backend_free(be);
00357 
00358     <span class="keywordflow">return</span> 0;
00359 }
00360 
00361 <span class="preprocessor">#ifdef OS_UNIX</span>
00362 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> server_chroot_to(server_t *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *dir)
00363 {
00364     dbg_return_if (s == NULL, ~0);
00365     dbg_return_if (dir == NULL, ~0);
00366 
00367     u_unused_args(s);
00368 
00369     dbg_err_if(chroot((<span class="keywordtype">char</span>*)dir));
00370 
00371     dbg_err_if(chdir(<span class="stringliteral">"/"</span>));
00372 
00373     info(<span class="stringliteral">"chroot'd: %s"</span>, dir);
00374 
00375     <span class="keywordflow">return</span> 0;
00376 err:
00377     warn_strerror(errno);
00378     <span class="keywordflow">return</span> ~0;
00379 }
00380 
00381 <span class="keyword">static</span> <span class="keywordtype">int</span> server_foreach_cb(<span class="keyword">struct</span> dirent *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">void</span> *arg)
00382 {
00383     <span class="keywordtype">int</span> *pfound = (<span class="keywordtype">int</span>*)arg;
00384 
00385     u_unused_args(d, path);
00386 
00387     *pfound = 1;
00388 
00389     <span class="keywordflow">return</span> ~0;
00390 }
00391 
00392 <span class="keyword">static</span> <span class="keywordtype">int</span> server_chroot_blind(server_t *s)
00393 {
00394     <span class="keyword">enum</span> { BLIND_DIR_MODE = 0100 }; <span class="comment">/* blind dir mode must be 0100 */</span>
00395     <span class="keywordtype">char</span> dir[U_PATH_MAX];
00396     <span class="keyword">struct </span>stat st;
00397     <span class="keywordtype">int</span> fd_dir = -1, found;
00398     pid_t child;
00399     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask;
00400 
00401     dbg_err_if (s == NULL);
00402     dbg_err_if (s-&gt;chroot == NULL);
00403 
00404     dbg_err_if(u_path_snprintf(dir, U_PATH_MAX, U_PATH_SEPARATOR,
00405         <span class="stringliteral">"%s/kloned_blind_chroot_%d.dir"</span>, s-&gt;chroot, getpid()));
00406 
00407     <span class="comment">/* create the blind dir (0100 mode) */</span>
00408     dbg_err_if(mkdir(dir, BLIND_DIR_MODE ));
00409 
00410     <span class="comment">/* get the fd of the dir */</span>
00411     dbg_err_if((fd_dir = open(dir, O_RDONLY, 0)) &lt; 0);
00412 
00413     dbg_err_if((child = fork()) &lt; 0);
00414 
00415     <span class="keywordflow">if</span>(child == 0)
00416     {   <span class="comment">/* child */</span>
00417 
00418         <span class="comment">/* delete the chroot dir and exit */</span>
00419         sleep(1); <span class="comment">// FIXME use a lock here</span>
00420         dbg(<span class="stringliteral">"[child] removing dir: %s\n"</span>, dir);
00421         rmdir(dir);
00422         _exit(0);
00423     }
00424     <span class="comment">/* parent */</span>
00425 
00426     <span class="comment">/* do chroot */</span>
00427     dbg_err_if(server_chroot_to(s, dir));
00428 
00429     <span class="comment">/* do some dir sanity checks */</span>
00430 
00431     <span class="comment">/* get stat values */</span>
00432     dbg_err_if(fstat(fd_dir, &amp;st));
00433 
00434     <span class="comment">/* the dir owned must be root */</span>
00435     dbg_err_if(st.st_gid || st.st_uid);
00436 
00437     <span class="comment">/* the dir mode must be 0100 */</span>
00438     dbg_err_if((st.st_mode &amp; 07777) != BLIND_DIR_MODE);
00439 
00440     <span class="comment">/* the dir must be empty */</span>
00441     found = 0;
00442     mask = S_IFIFO | S_IFCHR | S_IFDIR | S_IFBLK | S_IFREG | S_IFLNK | S_IFSOCK;
00443     dbg_err_if(<a class="code" href="group__ut.html#ga26">u_foreach_dir_item</a>(<span class="stringliteral">"/"</span>, mask, server_foreach_cb, &amp;found));
00444 
00445     <span class="comment">/* bail out if the dir is not empty */</span>
00446     dbg_err_if(found);
00447 
00448     close(fd_dir);
00449 
00450     <span class="keywordflow">return</span> 0;
00451 err:
00452     <span class="keywordflow">if</span>(fd_dir &gt;= 0)
00453         close(fd_dir);
00454     warn_strerror(errno);
00455     <span class="keywordflow">return</span> ~0;
00456 }
00457 
00458 <span class="keyword">static</span> <span class="keywordtype">int</span> server_chroot(server_t *s)
00459 {
00460     dbg_return_if (s == NULL, ~0);
00461 
00462     <span class="keywordflow">if</span>(s-&gt;blind_chroot)
00463         <span class="keywordflow">return</span> server_chroot_blind(s);
00464     <span class="keywordflow">else</span>
00465         <span class="keywordflow">return</span> server_chroot_to(s, s-&gt;chroot);
00466 }
00467 
00468 <span class="keyword">static</span> <span class="keywordtype">int</span> server_drop_privileges(server_t *s)
00469 {
00470     uid_t uid;
00471     gid_t gid;
00472 
00473     dbg_return_if (s == NULL, ~0);
00474 
00475     <span class="keywordflow">if</span>(s-&gt;gid &gt; 0)
00476     {
00477         gid = (gid_t)s-&gt;gid;
00478 
00479         <span class="comment">/* remove all groups except gid */</span>
00480         dbg_err_if(setgroups(1, &amp;gid));
00481 
00482         <span class="comment">/* set gid */</span>
00483         dbg_err_if(setgid(gid));
00484         dbg_err_if(setegid(gid));
00485 
00486         <span class="comment">/* verify */</span>
00487         dbg_err_if(getgid() != gid || getegid() != gid);
00488     }
00489 
00490     <span class="keywordflow">if</span>(s-&gt;uid &gt; 0)
00491     {
00492         uid = (uid_t)s-&gt;uid;
00493 
00494         <span class="comment">/* set uid */</span>
00495         dbg_err_if(setuid(uid));
00496         dbg_err_if(seteuid(uid));
00497 
00498         <span class="comment">/* verify */</span>
00499         dbg_err_if(getuid() != uid || geteuid() != uid);
00500     }
00501     
00502     <span class="keywordflow">return</span> 0;
00503 err:
00504     warn_strerror(errno);
00505     <span class="keywordflow">return</span> ~0;
00506 }
00507 
00508 <span class="keyword">static</span> <span class="keywordtype">int</span> server_fork_child(server_t *s, backend_t *be)
00509 {
00510     backend_t *obe; <span class="comment">/* other backed */</span>
00511     pid_t child;
00512     <span class="keywordtype">int</span> socks[2];
00513 
00514     dbg_return_if (s == NULL, -1);
00515     dbg_return_if (be == NULL, -1);
00516     <span class="comment">/* exit on too much children */</span>
00517     dbg_return_if (children_count(s-&gt;children) == s-&gt;max_child, -1);
00518     dbg_return_if (be-&gt;nchild == be-&gt;max_child, -1);
00519 
00520     <span class="comment">/* create a parent&lt;-&gt;child IPC channel */</span>
00521     dbg_err_if(socketpair(AF_UNIX, SOCK_STREAM, 0, socks) &lt; 0);
00522 
00523     <span class="keywordflow">if</span>((child = fork()) == 0)
00524     {   <span class="comment">/* child */</span>
00525 
00526         <span class="comment">/* never flush, the parent process will */</span>
00527         s-&gt;klog_flush = 0;
00528 
00529         <span class="comment">/* reseed the PRNG */</span>
00530         srand(rand() + getpid() + time(0));
00531 
00532         <span class="comment">/* close one end of the channel */</span>
00533         close(socks[0]);
00534 
00535         <span class="comment">/* save parent PPC socket and close the other */</span>
00536         ctx-&gt;pipc = socks[1];
00537         ctx-&gt;backend = be;
00538 
00539         <span class="comment">/* close listening sockets of other backends */</span>
00540         LIST_FOREACH(obe, &amp;s-&gt;bes, np)
00541         {
00542             <span class="keywordflow">if</span>(obe == be)
00543                 <span class="keywordflow">continue</span>;
00544             close(obe-&gt;ld);
00545             obe-&gt;ld = -1;
00546         }
00547 
00548         <span class="comment">/* clear child copy of children list */</span>
00549         dbg_err_if(children_clear(s-&gt;children));
00550 
00551     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(child &gt; 0) {
00552         <span class="comment">/* parent */</span>
00553 
00554         <span class="comment">/* save child pid and increment child count */</span>
00555         server_add_child(s, child, be);
00556 
00557         <span class="comment">/* close one end of the channel */</span>
00558         close(socks[1]);
00559 
00560         <span class="comment">/* watch the PPC socket connected to the child */</span>
00561         server_watch_fd(s, socks[0], WATCH_FD_READ);
00562     } <span class="keywordflow">else</span> {
00563         warn_err(<span class="stringliteral">"fork error"</span>);
00564     }
00565 
00566     <span class="keywordflow">return</span> child;
00567 err:
00568     warn_strerror(errno);
00569     <span class="keywordflow">return</span> -1;
00570 }
00571 
00572 <span class="keyword">static</span> <span class="keywordtype">int</span> server_child_serve(server_t *s, backend_t *be, <span class="keywordtype">int</span> ad)
00573 {
00574     pid_t child;
00575 
00576     dbg_return_if (s == NULL, ~0);
00577     dbg_return_if (be == NULL, ~0);
00578 
00579     dbg_err_if((child = server_fork_child(s, be)) &lt; 0);
00580 
00581     <span class="keywordflow">if</span>(child == 0)
00582     {   <span class="comment">/* child */</span>
00583 
00584         <span class="comment">/* close this be listening descriptor */</span>
00585         close(be-&gt;ld);
00586 
00587         hook_call(child_init);
00588 
00589         <span class="comment">/* serve the page */</span>
00590         dbg_if(backend_serve(be, ad));
00591 
00592         hook_call(child_term);
00593 
00594         <span class="comment">/* close client socket and die */</span>
00595         close(ad);
00596         server_stop(be-&gt;server); 
00597     }
00598     <span class="comment">/* parent */</span>
00599 
00600     <span class="keywordflow">return</span> 0;
00601 err:
00602     warn_strerror(errno);
00603     <span class="keywordflow">return</span> ~0;
00604 }
00605 
00606 <span class="keyword">static</span> <span class="keywordtype">int</span> server_cb_spawn_child(talarm_t *al, <span class="keywordtype">void</span> *arg)
00607 {
00608     server_t *s = (server_t*)arg;
00609 
00610     u_unused_args(al);
00611 
00612     dbg_err_if (s == NULL);
00613 
00614     <span class="comment">/* must be called by a child process */</span>
00615     dbg_err_if(ctx-&gt;backend == NULL || ctx-&gt;pipc == 0);
00616 
00617     <span class="comment">/* ask the parent to create a new worker child process */</span>
00618     dbg_err_if(server_ppc_cmd_fork_child(s, ctx-&gt;backend));
00619 
00620     <span class="comment">/* mark the current child process so it will die when finishes </span>
00621 <span class="comment">       serving this page */</span>
00622     server_stop(s);
00623 
00624     <span class="keywordflow">return</span> 0;
00625 err:
00626     <span class="keywordflow">return</span> ~0;
00627 }
00628 <span class="preprocessor">#endif </span><span class="comment">/* ifdef OS_UNIX */</span>
00629 
00630 <span class="keyword">static</span> <span class="keywordtype">int</span> server_be_serve(server_t *s, backend_t *be, <span class="keywordtype">int</span> ad)
00631 {
00632     talarm_t *al = NULL;
00633 
00634     dbg_err_if (s == NULL);
00635     dbg_err_if (be == NULL);
00636     
00637     <span class="keywordflow">switch</span>(be-&gt;model)
00638     {
00639 <span class="preprocessor">#ifdef OS_UNIX</span>
00640 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SERVER_MODEL_FORK:
00641         <span class="comment">/* spawn a child to handle the request */</span>
00642         dbg_err_if(server_child_serve(s, be, ad));
00643         <span class="keywordflow">break</span>;
00644 
00645     <span class="keywordflow">case</span> SERVER_MODEL_PREFORK: 
00646         <span class="comment">/* FIXME lower timeout value may be needed */</span>
00647         <span class="comment">/* if _serve takes more then 1 second spawn a new worker process */</span>
00648         dbg_err_if(timerm_add(1, server_cb_spawn_child, (<span class="keywordtype">void</span>*)s, &amp;al));
00649 
00650         <span class="comment">/* serve the page */</span>
00651         dbg_if(backend_serve(be, ad));
00652 
00653         <span class="comment">/* remove and free the alarm */</span>
00654         timerm_del(al); <span class="comment">/* prefork */</span>
00655         <span class="keywordflow">break</span>;
00656 <span class="preprocessor">#endif</span>
00657 <span class="preprocessor"></span>
00658     <span class="keywordflow">case</span> SERVER_MODEL_ITERATIVE:
00659         <span class="comment">/* serve the page */</span>
00660         dbg_if(backend_serve(be, ad));
00661         <span class="keywordflow">break</span>;
00662 
00663     <span class="keywordflow">default</span>:
00664         warn_err_if(<span class="stringliteral">"server model not supported"</span>);
00665     }
00666 
00667     <span class="comment">/* close the accepted (already served) socket */</span>
00668     close(ad);
00669 
00670     <span class="keywordflow">return</span> 0;
00671 err:
00672     close(ad);
00673     <span class="keywordflow">return</span> ~0;
00674 }
00675 
00676 <span class="keywordtype">int</span> server_stop(server_t *s)
00677 {
00678     dbg_err_if (s == NULL);
00679     
00680     <span class="keywordflow">if</span>(ctx-&gt;pipc)
00681     {   <span class="comment">/* child process */</span>
00682 
00683         dbg_err_if(ctx-&gt;backend == NULL);
00684 
00685         <span class="comment">/* close child listening sockets to force accept(2) to exit */</span>
00686         close(ctx-&gt;backend-&gt;ld);
00687     }
00688 
00689     <span class="comment">/* stop the parent process */</span>
00690     s-&gt;stop = 1;
00691 
00692     <span class="keywordflow">return</span> 0;
00693 err:
00694     <span class="keywordflow">return</span> ~0;
00695 }
00696 
00697 <span class="keyword">static</span> <span class="keywordtype">int</span> server_listen(server_t *s)
00698 {
00699     backend_t *be;
00700 
00701     dbg_err_if (s == NULL);
00702     
00703     LIST_FOREACH(be, &amp;s-&gt;bes, np)
00704     {
00705         <span class="comment">/* bind to be-&gt;addr */</span>
00706         dbg_err_if(server_be_listen(be));
00707 
00708         <span class="comment">/* watch the listening socket */</span>
00709         <span class="keywordflow">if</span>(be-&gt;model != SERVER_MODEL_PREFORK)
00710             server_watch_fd(s, be-&gt;ld, WATCH_FD_READ);
00711     }
00712 
00713     <span class="keywordflow">return</span> 0;
00714 err:
00715     <span class="keywordflow">return</span> ~0;
00716 }
00717 
00718 <span class="keywordtype">int</span> server_cgi(server_t *s)
00719 {
00720     backend_t *be;
00721 
00722     dbg_err_if (s == NULL);
00723 
00724     <span class="comment">/* use the first http backend as the CGI backend */</span>
00725     LIST_FOREACH(be, &amp;s-&gt;bes, np)
00726     {
00727         <span class="keywordflow">if</span>(strcasecmp(be-&gt;proto, <span class="stringliteral">"http"</span>) == 0)
00728         {
00729             hook_call(server_init);
00730 
00731             dbg_if(backend_serve(be, 0));
00732 
00733             hook_call(server_term);
00734 
00735             <span class="keywordflow">return</span> 0;
00736         }
00737     }
00738 
00739 err: <span class="comment">/* fall through if search loop exhausted */</span>
00740     <span class="keywordflow">return</span> ~0;
00741 }
00742 
00743 ppc_t* server_get_ppc(server_t *s)
00744 {
00745     dbg_return_if (s == NULL, NULL);
00746 
00747     <span class="keywordflow">return</span> s-&gt;ppc;
00748 }
00749 
00750 <span class="keyword">static</span> <span class="keywordtype">int</span> server_process_ppc(server_t *s, <span class="keywordtype">int</span> fd)
00751 {
00752     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cmd;
00753     <span class="keywordtype">char</span> data[PPC_MAX_DATA_SIZE];
00754     ssize_t n;
00755 
00756     dbg_err_if (s == NULL);
00757     dbg_err_if (fd &lt; 0);
00758 
00759     <span class="comment">/* get a ppc request */</span>
00760     n = ppc_read(s-&gt;ppc, fd, &amp;cmd, data, PPC_MAX_DATA_SIZE); 
00761     <span class="keywordflow">if</span>(n &gt; 0)
00762     {   
00763         <span class="comment">/* process a ppc (parent procedure call) request */</span>
00764         dbg_err_if(ppc_dispatch(s-&gt;ppc, fd, cmd, data, n));
00765     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n == 0) {
00766         <span class="comment">/* child has exit or closed the channel. close our side of the sock </span>
00767 <span class="comment">           and remove it from the watch list */</span>
00768         server_close_fd(s, fd);
00769     } <span class="keywordflow">else</span> {
00770         <span class="comment">/* ppc error. close fd and remove it from the watch list */</span>
00771         server_close_fd(s, fd);
00772     }
00773 
00774     <span class="keywordflow">return</span> 0;
00775 err:
00776     <span class="keywordflow">return</span> ~0;
00777 }
00778 
00779 <span class="keyword">static</span> <span class="keywordtype">int</span> server_set_socket_opts(server_t *s, <span class="keywordtype">int</span> sock)
00780 {
00781     <span class="keywordtype">int</span> on = 1; 
00782 
00783     u_unused_args(s);
00784 
00785     dbg_err_if (sock &lt; 0);
00786 
00787 <span class="preprocessor">#ifdef HAVE_TCP_NODELAY</span>
00788 <span class="preprocessor"></span>    <span class="comment">/* disable Nagle algorithm */</span>
00789     warn_err_sif(setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, 
00790         (<span class="keywordtype">void</span>*) &amp;on, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) &lt; 0);
00791 <span class="preprocessor">#endif</span>
00792 <span class="preprocessor"></span>
00793     <span class="keywordflow">return</span> 0;
00794 err:
00795     <span class="keywordflow">return</span> ~0;
00796 }
00797 
00798 <span class="keyword">static</span> <span class="keywordtype">int</span> server_dispatch(server_t *s, <span class="keywordtype">int</span> fd)
00799 {
00800     backend_t *be;
00801     <span class="keywordtype">int</span> ad = -1; 
00802 
00803     dbg_err_if (s == NULL);
00804 
00805     <span class="comment">/* find the backend that listen on fd */</span>
00806     LIST_FOREACH(be, &amp;s-&gt;bes, np)
00807         <span class="keywordflow">if</span>(be-&gt;ld == fd)
00808             <span class="keywordflow">break</span>;
00809 
00810     <span class="keywordflow">if</span>(be == NULL) <span class="comment">/* a child is ppc-calling */</span>
00811         <span class="keywordflow">return</span> server_process_ppc(s, fd);
00812 
00813     <span class="comment">/* accept the pending connection */</span>
00814     dbg_err_if(server_be_accept(s, be, &amp;ad));
00815 
00816     <span class="comment">/* set socket options on accepted socket */</span>
00817     dbg_err_if(server_set_socket_opts(s, ad));
00818 
00819     <span class="comment">/* serve the page */</span>
00820     dbg_err_if(server_be_serve(s, be, ad));
00821 
00822     <span class="keywordflow">return</span> 0;
00823 err:
00824     U_CLOSE(ad);
00825     <span class="keywordflow">return</span> ~0;
00826 }
00827 
00828 <span class="keywordtype">int</span> server_cb_klog_flush(talarm_t *a, <span class="keywordtype">void</span> *arg)
00829 {
00830     server_t *s = (server_t*)arg;
00831 
00832     u_unused_args(a);
00833 
00834     dbg_return_if (s == NULL, ~0);
00835 
00836     <span class="comment">/* set a flag to flush the klog object in server_loop */</span>
00837     s-&gt;klog_flush++;
00838 
00839     <span class="keywordflow">return</span> 0;
00840 }
00841 
00842 <span class="preprocessor">#ifdef OS_UNIX</span>
00843 <span class="preprocessor"></span><span class="keywordtype">int</span> server_spawn_child(server_t *s, backend_t *be)
00844 {
00845     size_t c;
00846     <span class="keywordtype">int</span> rc;
00847 
00848     dbg_err_if (s == NULL);
00849     dbg_err_if (be == NULL);
00850 
00851     dbg_err_if((rc = server_fork_child(s, be)) &lt; 0);
00852     <span class="keywordflow">if</span>(rc &gt; 0)
00853         <span class="keywordflow">return</span> 0; <span class="comment">/* parent */</span>
00854 
00855     <span class="comment">/* call the hook that runs the on-child user code */</span>
00856     hook_call(child_init);
00857 
00858     <span class="comment">/* child main loop: </span>
00859 <span class="comment">       close on s-&gt;stop or if max # of request limit has reached (the </span>
00860 <span class="comment">       server will respawn a new process if needed) */</span>
00861     <span class="keywordflow">for</span>(c = 0; !s-&gt;stop &amp;&amp; c &lt; be-&gt;max_rq_xchild; ++c)
00862     {
00863         <span class="comment">/* wait for a new client (will block on accept(2)) */</span>
00864         dbg_err_if(server_dispatch(s, be-&gt;ld));
00865     }
00866 
00867     <span class="comment">/* before child shutdowns call the term hook */</span>
00868     hook_call(child_term);
00869 
00870     server_stop(s);
00871 
00872     <span class="keywordflow">return</span> 0;
00873 err:
00874     <span class="keywordflow">return</span> ~0;
00875 }
00876 
00877 <span class="comment">/* spawn pre-fork child processes */</span>
00878 <span class="keyword">static</span> <span class="keywordtype">int</span> server_spawn_children(server_t *s)
00879 {
00880     backend_t *be;
00881     <span class="keyword">register</span> size_t i;
00882 
00883     dbg_err_if (s == NULL);
00884 
00885     <span class="comment">/* spawn N child process that will sleep asap into accept(2) */</span>
00886     LIST_FOREACH (be, &amp;s-&gt;bes, np)
00887     {
00888         <span class="keywordflow">if</span>(be-&gt;model != SERVER_MODEL_PREFORK || be-&gt;fork_child == 0)
00889             <span class="keywordflow">continue</span>;
00890 
00891         <span class="comment">/* spawn be-&gt;fork_child child processes */</span>
00892         <span class="keywordflow">for</span>(i = 0; i &lt; be-&gt;fork_child; ++i)
00893         {
00894             dbg_err_if(server_spawn_child(s, be));
00895             <span class="comment">/* child context? */</span>
00896             <span class="keywordflow">if</span>(ctx-&gt;pipc)
00897                 <span class="keywordflow">break</span>; <span class="comment">/* the child previously spawned is dying, exit */</span>
00898             be-&gt;fork_child--;
00899         }
00900     }
00901 
00902     <span class="keywordflow">return</span> 0;
00903 err:
00904     <span class="keywordflow">return</span> ~0;
00905 }
00906 <span class="preprocessor">#endif</span>
00907 <span class="preprocessor"></span>
00908 <span class="keywordtype">int</span> server_loop(server_t *s)
00909 {
00910     <span class="keyword">struct </span>timeval tv;
00911     <span class="keywordtype">int</span> rc, fd;
00912     fd_set rdfds, wrfds, exfds;
00913 
00914     dbg_err_if (s == NULL);
00915     dbg_err_if (s-&gt;config == NULL);
00916 
00917     dbg_err_if(server_listen(s));
00918 
00919 <span class="preprocessor">#ifdef OS_UNIX</span>
00920 <span class="preprocessor"></span>    <span class="comment">/* if it's configured chroot to the dst dir */</span>
00921     <span class="keywordflow">if</span>(s-&gt;chroot)
00922         dbg_err_if(server_chroot(s));
00923 
00924     <span class="comment">/* set uid/gid to non-root user */</span>
00925     warn_err_sifm(server_drop_privileges(s), <span class="stringliteral">"unable to drop priviledges"</span>);
00926 
00927     <span class="comment">/* if allow_root is not set check that we're not running as root */</span>
00928     <span class="keywordflow">if</span>(!s-&gt;allow_root)
00929         warn_err_ifm(!getuid() || !geteuid() || !getgid() || !getegid(),
00930             <span class="stringliteral">"you must set the allow_root config option to run kloned as root"</span>);
00931 <span class="preprocessor">#endif</span>
00932 <span class="preprocessor"></span>
00933     <span class="comment">/* server startup hook */</span>
00934     hook_call(server_init);
00935 
00936     <span class="keywordflow">for</span>(; !s-&gt;stop; )
00937     {
00938 <span class="preprocessor">#ifdef OS_UNIX</span>
00939 <span class="preprocessor"></span>        <span class="comment">/* spawn new child if needed (may fail on resource limits) */</span>
00940         dbg_if(server_spawn_children(s));
00941 <span class="preprocessor">#endif</span>
00942 <span class="preprocessor"></span>
00943         <span class="comment">/* children in pre-fork mode exit here */</span>
00944         <span class="keywordflow">if</span>(ctx-&gt;pipc)
00945             <span class="keywordflow">break</span>;
00946 
00947         memcpy(&amp;rdfds, &amp;s-&gt;rdfds, <span class="keyword">sizeof</span>(fd_set));
00948         memcpy(&amp;wrfds, &amp;s-&gt;wrfds, <span class="keyword">sizeof</span>(fd_set));
00949         memcpy(&amp;exfds, &amp;s-&gt;exfds, <span class="keyword">sizeof</span>(fd_set));
00950 
00951         <span class="comment">/* wake up every second */</span>
00952         tv.tv_sec = 1; tv.tv_usec = 0;
00953 
00954     again:
00955         rc = select(1 + s-&gt;hfd, &amp;rdfds, &amp;wrfds, &amp;exfds, &amp;tv); 
00956         <span class="keywordflow">if</span>(rc == -1 &amp;&amp; errno == EINTR)
00957             <span class="keywordflow">goto</span> again; <span class="comment">/* interrupted */</span>
00958         dbg_err_if(rc == -1); <span class="comment">/* select error */</span>
00959 
00960 <span class="preprocessor">#ifdef OS_UNIX</span>
00961 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(s-&gt;reap_children)
00962             server_waitpid(s);
00963 <span class="preprocessor">#endif</span>
00964 <span class="preprocessor"></span>
00965         <span class="comment">/* call klog_flush if flush timeout has expired and select() timeouts */</span>
00966         <span class="keywordflow">if</span>(s-&gt;klog_flush &amp;&amp; ctx-&gt;pipc == 0)
00967         {
00968             <span class="comment">/* flush the log buffer */</span>
00969             klog_flush(s-&gt;klog);
00970 
00971             <span class="comment">/* reset the flag */</span>
00972             s-&gt;klog_flush = 0; 
00973 
00974             U_FREE(s-&gt;al_klog_flush);
00975 
00976             <span class="comment">/* re-set the timer */</span>
00977             dbg_err_if(timerm_add(SERVER_LOG_FLUSH_TIMEOUT, 
00978                 server_cb_klog_flush, s, &amp;s-&gt;al_klog_flush));
00979         }
00980 
00981         <span class="comment">/* for each signaled listening descriptor */</span>
00982         <span class="keywordflow">for</span>(fd = 0; rc &amp;&amp; fd &lt; 1 + s-&gt;hfd; ++fd)
00983         { 
00984             <span class="keywordflow">if</span>(FD_ISSET(fd, &amp;rdfds))
00985             {
00986                 --rc;
00987                 <span class="comment">/* dispatch the request to the right backend */</span>
00988                 dbg_if(server_dispatch(s, fd));
00989             } 
00990         } <span class="comment">/* for each ready fd */</span>
00991 
00992     } <span class="comment">/* !s-&gt;stop */</span>
00993 
00994     <span class="comment">/* children in fork mode exit here */</span>
00995     <span class="keywordflow">if</span>(ctx-&gt;pipc)
00996         <span class="keywordflow">return</span> 0;
00997 
00998     <span class="comment">/* server shutdown hook */</span>
00999     hook_call(server_term);
01000 
01001     <span class="comment">/* shutdown all children */</span>
01002     server_term_children(s);
01003 
01004     sleep(1);
01005 
01006     <span class="comment">/* brute kill children process */</span>
01007     <span class="keywordflow">if</span>(s-&gt;nchild)
01008         server_kill_children(s);
01009 
01010     <span class="keywordflow">return</span> 0;
01011 err:
01012     <span class="keywordflow">return</span> ~0;
01013 }
01014 
01015 <span class="keywordtype">int</span> server_free(server_t *s)
01016 {
01017     backend_t *be;
01018 
01019     dbg_err_if (s == NULL);
01020 
01021     <span class="comment">/* remove the hook (that needs the server_t object) */</span>
01022     u_log_set_hook(NULL, NULL, NULL, NULL);
01023 
01024     <span class="comment">/* remove klog flushing alarm */</span>
01025     <span class="keywordflow">if</span>(s-&gt;al_klog_flush)
01026     {
01027         timerm_del(s-&gt;al_klog_flush);
01028         s-&gt;al_klog_flush = NULL;
01029     }
01030 
01031     <span class="keywordflow">if</span>(s-&gt;klog)
01032     {
01033         <span class="comment">/* child processes must not close klog when in 'file' mode, because </span>
01034 <span class="comment">           klog_file_t will flush data that the parent already flushed </span>
01035 <span class="comment">           (children inherit a "used" FILE* that will usually contain, on close,</span>
01036 <span class="comment">           not-empty buffer that fclose (called by exit()) flushes). same </span>
01037 <span class="comment">           thing may happens with different log devices when buffers are used.</span>
01038 <span class="comment">         */</span>
01039         <span class="keywordflow">if</span>(ctx-&gt;pipc == 0)
01040             klog_close(s-&gt;klog);
01041         s-&gt;klog = NULL;
01042     }
01043 
01044     <span class="keywordflow">while</span>((be = LIST_FIRST(&amp;s-&gt;bes)) != NULL)
01045     {
01046         LIST_REMOVE(be, np);
01047         server_backend_detach(s, be);
01048     }
01049 
01050     dbg_if(ppc_free(s-&gt;ppc));
01051 
01052     dbg_if(children_free(s-&gt;children));
01053 
01054 <span class="preprocessor">#ifdef OS_WIN</span>
01055 <span class="preprocessor"></span>    WSACleanup();
01056 <span class="preprocessor">#endif</span>
01057 <span class="preprocessor"></span>
01058     U_FREE(s);
01059     <span class="keywordflow">return</span> 0;
01060 err:
01061     <span class="keywordflow">return</span> ~0;
01062 }
01063 
01064 <span class="keyword">static</span> <span class="keywordtype">int</span> server_setup_backend(server_t *s, backend_t *be)
01065 {
01066     u_config_t *subkey;
01067 
01068     dbg_return_if (s == NULL, ~0);
01069     dbg_return_if (be == NULL, ~0);
01070     
01071     <span class="comment">/* server count */</span>
01072     s-&gt;nbackend++;
01073 
01074     <span class="comment">/* parse and create the bind kaddr_t */</span>
01075     warn_err_ifm(u_config_get_subkey(be-&gt;config, <span class="stringliteral">"addr"</span>, &amp;subkey),
01076         <span class="stringliteral">"missing or bad '&lt;servname&gt;.addr' value"</span>);
01077 
01078     dbg_err_if(addr_create(&amp;be-&gt;addr));
01079 
01080     <span class="keywordflow">if</span>(strcasecmp(be-&gt;proto, <span class="stringliteral">"https"</span>) == 0)
01081         dbg_err_if(addr_set_ipv4_port(be-&gt;addr, 443)); <span class="comment">/* default https port */</span>
01082     <span class="keywordflow">else</span>
01083         dbg_err_if(addr_set_ipv4_port(be-&gt;addr, 80)); <span class="comment">/* default http port */</span>
01084 
01085     dbg_err_if(addr_set_from_config(be-&gt;addr, subkey));
01086 
01087     <span class="keywordflow">return</span> 0;
01088 err:
01089     <span class="keywordflow">if</span>(be-&gt;addr)
01090     {
01091         addr_free(be-&gt;addr);
01092         be-&gt;addr = NULL;
01093     }
01094     <span class="keywordflow">return</span> ~0;
01095 }
01096 
01097 <span class="keyword">static</span> <span class="keywordtype">int</span> server_log_hook(<span class="keywordtype">void</span> *arg, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">char</span> *str)
01098 {
01099     server_t *s = (server_t*)arg;
01100     u_log_hook_t old = NULL;
01101     <span class="keywordtype">void</span> *old_arg = NULL;
01102 
01103     dbg_err_if (s == NULL);
01104     dbg_err_if (str == NULL);
01105  
01106     <span class="comment">/* if both the server and the calling backend have no log then exit */</span>
01107     <span class="keywordflow">if</span>(s-&gt;klog == NULL &amp;&amp; (ctx-&gt;backend == NULL || ctx-&gt;backend-&gt;klog == NULL))
01108         <span class="keywordflow">return</span> 0; <span class="comment">/* log is disabled */</span>
01109 
01110     <span class="comment">/* disable log hooking in the hook itself otherwise an infinite loop </span>
01111 <span class="comment">       may happen if a log function is called from inside the hook */</span>
01112     u_log_set_hook(NULL, NULL, &amp;old, &amp;old_arg);
01113 
01114     <span class="comment">/* syslog klog doesn't go through ppc */</span>
01115     <span class="keywordflow">if</span>(s-&gt;klog-&gt;type == KLOG_TYPE_SYSLOG || ctx-&gt;pipc == 0)
01116     {   <span class="comment">/* syslog klog or parent context */</span>
01117         <span class="keywordflow">if</span>(s-&gt;klog)
01118             dbg_err_if(klog(s-&gt;klog, syslog_to_klog(level), <span class="stringliteral">"%s"</span>, str));
01119     } <span class="keywordflow">else</span> {
01120         <span class="comment">/* children context */</span>
01121         dbg_err_if(server_ppc_cmd_log_add(s, level, str));
01122     }
01123 
01124     <span class="comment">/* re-set the old hook */</span>
01125     u_log_set_hook(old, old_arg, NULL, NULL);
01126 
01127     <span class="keywordflow">return</span> 0;
01128 err:
01129     <span class="keywordflow">if</span>(old)
01130         u_log_set_hook(old, old_arg, NULL, NULL);
01131     <span class="keywordflow">return</span> ~0;
01132 }
01133 
01134 <span class="keywordtype">int</span> server_get_logger(server_t *s, klog_t **pkl)
01135 {
01136     klog_t *kl = NULL;
01137 
01138     dbg_err_if (s == NULL);
01139     dbg_err_if (pkl == NULL);
01140  
01141     <span class="keywordflow">if</span>(ctx-&gt;backend)
01142         kl = ctx-&gt;backend-&gt;klog; <span class="comment">/* may be NULL */</span>
01143 
01144     <span class="keywordflow">if</span>(kl == NULL)
01145         kl = s-&gt;klog; <span class="comment">/* may be NULL */</span>
01146 
01147     *pkl = kl;
01148 
01149     <span class="keywordflow">return</span> 0;
01150 err:
01151     <span class="keywordflow">return</span> ~0;
01152 }
01153 
01154 <span class="keyword">static</span> <span class="keywordtype">int</span> server_get_klog_line(server_t *s, klog_t *kl, size_t i, <span class="keywordtype">char</span> *line)
01155 {
01156     backend_t *be = ctx-&gt;backend;
01157 
01158     dbg_err_if(kl-&gt;type != KLOG_TYPE_MEM);
01159     dbg_err_if(be == NULL);
01160 
01161     <span class="comment">/* we need ppc just in prefork mode */</span>
01162     <span class="keywordflow">if</span>(be-&gt;model != SERVER_MODEL_PREFORK)
01163     {
01164         dbg_err_if(klog_getln(kl, i, line));
01165         <span class="keywordflow">return</span> 0;
01166     }
01167 
01168     <span class="comment">/* send the ppc command and read back the response */</span>
01169     nop_err_if(server_ppc_cmd_log_get(s, i, line));
01170 
01171     <span class="keywordflow">return</span> 0;
01172 err:
01173     <span class="keywordflow">return</span> ~0;
01174 }
01175 
01176 <span class="keywordtype">int</span> server_foreach_memlog_line(server_t *s, 
01177     <span class="keywordtype">int</span> (*cb)(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keywordtype">void</span>*), <span class="keywordtype">void</span> *arg)
01178 {
01179     klog_t *kl = NULL;  
01180     size_t i;
01181     <span class="keywordtype">char</span> line[KLOG_LN_SZ];
01182 
01183     <span class="comment">/* get the configured klog object and check that's a in-memory klog */</span>
01184     <span class="keywordflow">if</span>(server_get_logger(s, &amp;kl) || kl == NULL || kl-&gt;type != KLOG_TYPE_MEM)
01185     {
01186         cb(<span class="stringliteral">"logging is not configured or is not a in-memory log"</span>, arg);
01187         <span class="keywordflow">return</span> ~0;
01188     }
01189 
01190     <span class="comment">/* for each log line call the user-given callback function */</span>
01191     <span class="keywordflow">for</span>(i = 1; server_get_klog_line(s, kl, i, line) == 0; ++i)
01192         cb(line, arg);
01193 
01194     <span class="keywordflow">return</span> 0;
01195 err:
01196     cb(<span class="stringliteral">"klog_getln error"</span>, arg);
01197     <span class="keywordflow">return</span> ~0;
01198 }
01199 
01200 
01201 <span class="keywordtype">int</span> server_get_backend_by_id(server_t *s, <span class="keywordtype">int</span> <span class="keywordtype">id</span>, backend_t **pbe)
01202 {
01203     backend_t *be;
01204 
01205     dbg_err_if (s == NULL);
01206     dbg_err_if (pbe == NULL);
01207     
01208     LIST_FOREACH(be, &amp;s-&gt;bes, np)
01209     {
01210         <span class="keywordflow">if</span>(be-&gt;id == <span class="keywordtype">id</span>)
01211         {
01212             *pbe = be;
01213             <span class="keywordflow">return</span> 0;
01214         }
01215     }
01216 
01217 err: <span class="comment">/* fall through if search loop exhausted */</span>
01218     <span class="keywordflow">return</span> ~0;
01219 }
01220 
01221 <span class="keywordtype">int</span> server_create(u_config_t *config, <span class="keywordtype">int</span> foreground, server_t **ps)
01222 {
01223     server_t *s = NULL;
01224     u_config_t *bekey = NULL, *log_c = NULL;
01225     backend_t *be = NULL;
01226     <span class="keyword">const</span> <span class="keywordtype">char</span> *list, *type;
01227     <span class="keywordtype">char</span> *n = NULL, *name = NULL;
01228     <span class="keywordtype">int</span> i, <span class="keywordtype">id</span>, iv;
01229 
01230     dbg_return_if (ps == NULL, ~0);
01231     dbg_return_if (config == NULL, ~0);
01232 
01233 <span class="preprocessor">#ifdef OS_WIN</span>
01234 <span class="preprocessor"></span>    WORD ver;
01235     WSADATA wsadata;
01236 
01237     ver = MAKEWORD(1,1);
01238     dbg_err_if(WSAStartup(ver, &amp;wsadata));
01239 <span class="preprocessor">#endif</span>
01240 <span class="preprocessor"></span>
01241     s = u_zalloc(<span class="keyword">sizeof</span>(server_t));
01242     dbg_err_if(s == NULL);
01243 
01244     *ps = s; <span class="comment">/* we need it before backend inits */</span>
01245 
01246     s-&gt;config = config;
01247     s-&gt;model = SERVER_MODEL_FORK; <span class="comment">/* default */</span>
01248 
01249     dbg_err_if(children_create(&amp;s-&gt;children));
01250 
01251     <span class="comment">/* init fd_set */</span>
01252     FD_ZERO(&amp;s-&gt;rdfds);
01253     FD_ZERO(&amp;s-&gt;wrfds);
01254     FD_ZERO(&amp;s-&gt;exfds);
01255 
01256     <span class="comment">/* init backend list */</span>
01257     LIST_INIT(&amp;s-&gt;bes);
01258 
01259     dbg_err_if(ppc_create(&amp;s-&gt;ppc));
01260 
01261     <span class="comment">/* create the log device if requested */</span>
01262     <span class="keywordflow">if</span>(!u_config_get_subkey(config, <span class="stringliteral">"log"</span>, &amp;log_c))
01263     {
01264         dbg_if(klog_open_from_config(log_c, &amp;s-&gt;klog));
01265         s-&gt;klog_flush = 1;
01266     }
01267 
01268     <span class="comment">/* register the log ppc callbacks */</span>
01269     dbg_err_if(ppc_register(s-&gt;ppc, PPC_CMD_NOP, server_ppc_cb_nop, s));
01270     dbg_err_if(ppc_register(s-&gt;ppc, PPC_CMD_LOG_ADD, server_ppc_cb_log_add, s));
01271     dbg_err_if(ppc_register(s-&gt;ppc, PPC_CMD_LOG_GET, server_ppc_cb_log_get, s));
01272 <span class="preprocessor">#ifdef OS_UNIX</span>
01273 <span class="preprocessor"></span>    dbg_err_if(ppc_register(s-&gt;ppc, PPC_CMD_FORK_CHILD, 
01274         server_ppc_cb_fork_child, s));
01275 <span class="preprocessor">#endif</span>
01276 <span class="preprocessor"></span>    dbg_err_if(ppc_register(s-&gt;ppc, PPC_CMD_ACCESS_LOG, 
01277                 server_ppc_cb_access_log, s));
01278 
01279     <span class="comment">/* redirect logs to the server_log_hook function */</span>
01280     dbg_err_if(u_log_set_hook(server_log_hook, s, NULL, NULL));
01281 
01282     <span class="comment">/* parse server list and build s-&gt;bes */</span>
01283     list = u_config_get_subkey_value(config, <span class="stringliteral">"server_list"</span>);
01284     warn_err_ifm(list == NULL, <span class="stringliteral">"bad or missing 'server_list' config param"</span>);
01285 
01286     <span class="comment">/* chroot, uid and gid */</span>
01287     s-&gt;chroot = u_config_get_subkey_value(config, <span class="stringliteral">"chroot"</span>);
01288     dbg_err_if(u_config_get_subkey_value_i(config, <span class="stringliteral">"uid"</span>, -1, &amp;s-&gt;uid));
01289     dbg_err_if(u_config_get_subkey_value_i(config, <span class="stringliteral">"gid"</span>, -1, &amp;s-&gt;gid));
01290     dbg_err_if(u_config_get_subkey_value_b(config, <span class="stringliteral">"allow_root"</span>, 0, 
01291         &amp;s-&gt;allow_root));
01292     dbg_err_if(u_config_get_subkey_value_b(config, <span class="stringliteral">"blind_chroot"</span>, 0, 
01293         &amp;s-&gt;blind_chroot));
01294 
01295     warn_err_ifm(!s-&gt;uid || !s-&gt;gid, 
01296         <span class="stringliteral">"you must set uid and gid config parameters"</span>);
01297 
01298     dbg_err_if(u_config_get_subkey_value_i(config, <span class="stringliteral">"max_child"</span>, 
01299         SERVER_MAX_CHILD, &amp;iv));
01300     s-&gt;max_child = iv;
01301 
01302     name = n = u_zalloc(strlen(list) + 1);
01303     dbg_err_if(name == NULL);
01304     
01305     <span class="comment">/* load config and init backend for each server in server.list */</span>
01306     <span class="keywordflow">for</span>(i = strlen(list), <span class="keywordtype">id</span> = 0; 
01307         i &gt; 0 &amp;&amp; sscanf(list, <span class="stringliteral">"%[^ \t]"</span>, name); 
01308         i -= 1 + strlen(name), list += 1 + strlen(name), name[0] = 0)
01309     {
01310         dbg(<span class="stringliteral">"configuring backend: %s"</span>, name);
01311 
01312         <span class="comment">/* just SERVER_MAX_BACKENDS supported */</span>
01313         warn_err_if(s-&gt;nbackend == SERVER_MAX_BACKENDS);
01314 
01315         <span class="comment">/* get config tree of this backend */</span>
01316         warn_err_ifm(u_config_get_subkey(config, name, &amp;bekey),
01317             <span class="stringliteral">"missing [%s] backend configuration"</span>, name);
01318 
01319         type = u_config_get_subkey_value(bekey, <span class="stringliteral">"type"</span>);
01320         warn_err_ifm(type == NULL, <span class="stringliteral">"missing or bad '&lt;servname&gt;.type' value"</span>);
01321 
01322         <span class="comment">/* create a new backend and push it into the 'be' list */</span>
01323         warn_err_ifm(backend_create(type, bekey, &amp;be),
01324             <span class="stringliteral">"backend \"%s\" startup error"</span>, type);
01325 
01326         be-&gt;server = s;
01327         be-&gt;config = bekey;
01328         be-&gt;id = <span class="keywordtype">id</span>++;
01329         <span class="keywordflow">if</span>(be-&gt;model == SERVER_MODEL_UNSET)
01330             be-&gt;model = s-&gt;model; <span class="comment">/* inherit server model */</span>
01331 
01332         <span class="keywordflow">if</span>(foreground)
01333             be-&gt;model = SERVER_MODEL_ITERATIVE;
01334 
01335         <span class="comment">/* create the log device (may fail if logging is not configured) */</span>
01336         <span class="keywordflow">if</span>(!u_config_get_subkey(bekey, <span class="stringliteral">"log"</span>, &amp;log_c))
01337             dbg_if(klog_open_from_config(log_c, &amp;be-&gt;klog));
01338 
01339 <span class="preprocessor">#ifdef OS_WIN</span>
01340 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(be-&gt;model != SERVER_MODEL_ITERATIVE)
01341             warn_err(<span class="stringliteral">"child-based server model is not "</span>
01342                      <span class="stringliteral">"yet supported on Windows"</span>);
01343 <span class="preprocessor">#endif</span>
01344 <span class="preprocessor"></span>
01345         LIST_INSERT_HEAD(&amp;s-&gt;bes, be, np);
01346 
01347         dbg_err_if(server_setup_backend(s, be));
01348     }
01349 
01350     U_FREE(n);
01351 
01352     <span class="comment">/* init done, set signal handlers */</span>
01353     dbg_err_if(u_signal(SIGINT, server_sigint));
01354     dbg_err_if(u_signal(SIGTERM, server_sigterm));
01355 <span class="preprocessor">#ifdef OS_UNIX </span>
01356 <span class="preprocessor"></span>    dbg_err_if(u_signal(SIGPIPE, SIG_IGN));
01357     dbg_err_if(u_signal(SIGCHLD, server_sigchld));
01358 <span class="preprocessor">#endif</span>
01359 <span class="preprocessor"></span>
01360     <span class="keywordflow">return</span> 0;
01361 err:
01362     warn(<span class="stringliteral">"server init error (config error?)"</span>);
01363     U_FREE(n);
01364     <span class="keywordflow">if</span>(s)
01365     {
01366         server_free(s);
01367         *ps = NULL;
01368     }
01369     <span class="keywordflow">return</span> ~0;
01370 }
01371 
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


