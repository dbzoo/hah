<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: cipher.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>cipher.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: cipher.c,v 1.11 2007/10/26 08:57:59 tho Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00013 <span class="preprocessor">#include &lt;klone/codec.h&gt;</span>
00014 <span class="preprocessor">#include &lt;klone/ccipher.h&gt;</span>
00015 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00016 
00017 <span class="keyword">enum</span> { CODEC_CIPHER_MAX_INPUT = 4096 <span class="comment">/* max src block size for transform() */</span> };
00018 
00019 <span class="keyword">typedef</span> int (*EVP_Update_t)(EVP_CIPHER_CTX *ctx, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out,
00020     <span class="keywordtype">int</span> *outl, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in, <span class="keywordtype">int</span> inl);
00021 <span class="keyword">typedef</span> int (*EVP_Final_ex_t)(EVP_CIPHER_CTX *ctx, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out,
00022     <span class="keywordtype">int</span> *outl);
00023 
00024 <span class="keyword">struct </span>codec_cipher_s
00025 {
00026     codec_t codec;
00027     <span class="keyword">const</span> EVP_CIPHER *cipher;   <span class="comment">/* encryption cipher algorithm */</span>
00028     EVP_CIPHER_CTX cipher_ctx;  <span class="comment">/* encrypt context */</span>
00029     <span class="keywordtype">char</span> *cbuf;
00030     size_t coff, ccount, cbuf_size;
00031     EVP_Update_t update;        <span class="comment">/* EVP_{Encrypt,Decrypt}Update func ptr */</span>
00032     EVP_Final_ex_t <span class="keyword">final</span>;       <span class="comment">/* EVP_{Encrypt,Decrypt}Final_ex func ptr */</span>
00033 };
00034 
00035 <span class="keyword">typedef</span> <span class="keyword">struct </span>codec_cipher_s codec_cipher_t;
00036 
00037 <span class="keyword">static</span> <span class="keywordtype">void</span> codec_cbufcpy(codec_cipher_t *cc, <span class="keywordtype">char</span> *dst, size_t *dcount)
00038 {
00039     size_t count;
00040 
00041     count = MIN(*dcount, cc-&gt;ccount);
00042 
00043     memcpy(dst, cc-&gt;cbuf + cc-&gt;coff, count);
00044     cc-&gt;ccount -= count;
00045     <span class="keywordflow">if</span>(cc-&gt;ccount)
00046         cc-&gt;coff += count;
00047     <span class="keywordflow">else</span>
00048         cc-&gt;coff = 0;
00049     *dcount = count;
00050 }
00051 
00052 <span class="keyword">static</span> ssize_t cipher_flush(codec_t *codec, <span class="keywordtype">char</span> *dst, size_t *dcount)
00053 {
00054     codec_cipher_t *cc;
00055     <span class="keywordtype">int</span> wr;
00056 
00057     dbg_err_if (codec == NULL);
00058     dbg_err_if (dst == NULL);
00059     dbg_err_if (dcount == NULL);
00060 
00061     cc = (codec_cipher_t*)codec;
00062     
00063     <span class="keywordflow">for</span>(;;)
00064     {
00065         <span class="keywordflow">if</span>(cc-&gt;ccount)
00066         {
00067             codec_cbufcpy(cc, dst, dcount);
00068             <span class="keywordflow">return</span> CODEC_FLUSH_CHUNK; <span class="comment">/* call flush again */</span>
00069         }
00070 
00071         <span class="keywordflow">if</span>(cc-&gt;final)
00072         {
00073             wr = -1; <span class="comment">/* just used to return an int value */</span>
00074             dbg_err_if(!cc-&gt;final(&amp;cc-&gt;cipher_ctx, cc-&gt;cbuf, &amp;wr));
00075 
00076             cc-&gt;ccount += wr;
00077             cc-&gt;final = NULL; <span class="comment">/* can be called just once */</span>
00078 
00079             <span class="keywordflow">if</span>(wr)
00080                 <span class="keywordflow">continue</span>;
00081         }
00082         <span class="keywordflow">break</span>;
00083     }
00084 
00085     *dcount = 0;
00086     <span class="keywordflow">return</span> CODEC_FLUSH_COMPLETE;
00087 err:
00088     <span class="keywordflow">return</span> -1;
00089 }
00090 
00091 <span class="keyword">static</span> ssize_t cipher_transform(codec_t *codec, <span class="keywordtype">char</span> *dst, size_t *dcount, 
00092         <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t src_sz)
00093 {
00094     codec_cipher_t *cc;
00095     ssize_t c;
00096     <span class="keywordtype">int</span> wr;
00097 
00098     dbg_err_if (codec == NULL);
00099     dbg_err_if (src == NULL);
00100     dbg_err_if (dst == NULL); 
00101     dbg_err_if (dcount == NULL || *dcount == 0); 
00102     dbg_err_if (src_sz == 0);
00103 
00104     cc = (codec_cipher_t*)codec;
00105 
00106     c = 0;
00107     <span class="keywordflow">for</span>(;;)
00108     {
00109         <span class="keywordflow">if</span>(cc-&gt;ccount)
00110         {
00111             codec_cbufcpy(cc, dst, dcount);
00112             <span class="keywordflow">return</span> c; <span class="comment">/* consumed */</span>
00113         }
00114 
00115         <span class="comment">/* the cbuf must be empty because we need the whole buffer to be sure to</span>
00116 <span class="comment">           have enough output space for EVP_{Encrypt,Decrypt}Update */</span>
00117 
00118         c = MIN(src_sz, CODEC_CIPHER_MAX_INPUT);
00119 
00120         wr = -1; <span class="comment">/* just used to return an int value */</span>
00121         dbg_err_if(!cc-&gt;update(&amp;cc-&gt;cipher_ctx, cc-&gt;cbuf, &amp;wr, src, c));
00122         cc-&gt;ccount += wr;
00123 
00124         <span class="keywordflow">if</span>(wr == 0)
00125         {
00126             *dcount = 0;
00127             <span class="keywordflow">break</span>; <span class="comment">/* cipher need more input to produce any output */</span>
00128         }
00129     }
00130 
00131     dbg_err_if(c == 0 &amp;&amp; *dcount == 0);
00132     <span class="keywordflow">return</span> c;
00133 err:
00134     <span class="keywordflow">return</span> -1;
00135 }
00136 
00137 <span class="keyword">static</span> <span class="keywordtype">int</span> cipher_free(codec_t *codec)
00138 {
00139     codec_cipher_t *cc;
00140        
00141     nop_return_if (codec == NULL, 0);   
00142         
00143     cc = (codec_cipher_t*)codec;
00144 
00145     U_FREE(cc-&gt;cbuf);
00146     U_FREE(cc);
00147 
00148     <span class="keywordflow">return</span> 0;
00149 }
00150 
<a name="l00172"></a><a class="code" href="group__filters.html#ga0">00172</a> <span class="keywordtype">int</span> <a class="code" href="group__filters.html#ga0">codec_cipher_create</a>(<span class="keywordtype">int</span> op, <span class="keyword">const</span> EVP_CIPHER *cipher, 
00173     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *iv, codec_t **pcc)
00174 {
00175     codec_cipher_t *cc = NULL;
00176 
00177     dbg_return_if (cipher == NULL, ~0);
00178     dbg_return_if (key == NULL, ~0);
00179     <span class="comment">/* iv can be NULL */</span>
00180     dbg_return_if (pcc == NULL, ~0);
00181 
00182     cc = u_zalloc(<span class="keyword">sizeof</span>(codec_cipher_t));
00183     dbg_err_if(cc == NULL);
00184 
00185     cc-&gt;codec.transform = cipher_transform;
00186     cc-&gt;codec.flush = cipher_flush;
00187     cc-&gt;codec.free = cipher_free;      
00188 
00189     cc-&gt;cipher = cipher;
00190 
00191     <span class="comment">/* be sure that the cipher stuff is loaded */</span>
00192     EVP_add_cipher(cc-&gt;cipher);
00193 
00194     EVP_CIPHER_CTX_init(&amp;cc-&gt;cipher_ctx);
00195 
00196     cc-&gt;cbuf_size = CODEC_CIPHER_MAX_INPUT + 
00197         EVP_CIPHER_block_size(cc-&gt;cipher) -1;
00198 
00199     cc-&gt;cbuf = u_malloc(cc-&gt;cbuf_size);
00200     dbg_err_if(cc-&gt;cbuf == NULL);
00201 
00202     <span class="keywordflow">switch</span>(op)
00203     {
00204     <span class="keywordflow">case</span> CIPHER_ENCRYPT:
00205         dbg_err_if(!EVP_EncryptInit_ex(&amp;cc-&gt;cipher_ctx, cc-&gt;cipher, NULL, 
00206             key, iv));
00207         cc-&gt;update = EVP_EncryptUpdate;
00208         cc-&gt;final = EVP_EncryptFinal_ex;
00209         <span class="keywordflow">break</span>;
00210     <span class="keywordflow">case</span> CIPHER_DECRYPT:
00211         dbg_err_if(!EVP_DecryptInit_ex(&amp;cc-&gt;cipher_ctx, cc-&gt;cipher, NULL, 
00212             key, iv));
00213         cc-&gt;update = EVP_DecryptUpdate;
00214         cc-&gt;final = EVP_DecryptFinal_ex;
00215         <span class="keywordflow">break</span>;
00216     <span class="keywordflow">default</span>:
00217         dbg_err_if(<span class="stringliteral">"bad cipher op"</span>);
00218     }
00219 
00220 
00221     *pcc = (codec_t*)cc;
00222 
00223     <span class="keywordflow">return</span> 0;
00224 err:
00225     U_FREE(cc);
00226     <span class="keywordflow">return</span> ~0;
00227 }
00228 
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


