<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: vars.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>vars.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: vars.c,v 1.32 2008/05/16 15:04:47 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00013 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00014 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00015 <span class="preprocessor">#include &lt;klone/vars.h&gt;</span>
00016 <span class="preprocessor">#include &lt;klone/varprv.h&gt;</span>
00017 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00018 
00019 TAILQ_HEAD(var_list_s, var_s);
00020 
00021 <span class="keyword">struct </span>vars_s
00022 {
00023     u_list_t *list;              <span class="comment">/* list of variables (var_t) */</span>
00024     <span class="keywordtype">int</span> flags;
00025 };
00026 
00039 u_string_t *vars_get_value_s(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00040 {
00041     var_t *v = NULL;
00042 
00043     dbg_err_if (vs == NULL);
00044     dbg_err_if (name == NULL);
00045 
00046     dbg_err_if((v = vars_get(vs, name)) == NULL);
00047 
00048     <span class="keywordflow">return</span> var_get_value_s(v);
00049 err:
00050     <span class="keywordflow">return</span> NULL;
00051 }
00052 
00053 <span class="keywordtype">int</span> vars_create(vars_t **pvs)
00054 {
00055     vars_t *vs = NULL;
00056 
00057     dbg_err_if (pvs == NULL);
00058 
00059     vs = u_zalloc(<span class="keyword">sizeof</span>(vars_t));
00060     dbg_err_if(vs == NULL);
00061 
00062     dbg_err_if(u_list_create(&amp;vs-&gt;list));
00063 
00064     *pvs = vs;
00065 
00066     <span class="keywordflow">return</span> 0;
00067 err:
00068     <span class="keywordflow">if</span>(vs)
00069         vars_free(vs);
00070     <span class="keywordflow">return</span> ~0;
00071 }
00072 
00073 <span class="keywordtype">int</span> vars_set_flags(vars_t *vs, <span class="keywordtype">int</span> flags)
00074 {
00075     dbg_err_if (vs == NULL);
00076 
00077     vs-&gt;flags = flags;
00078 
00079     <span class="keywordflow">return</span> 0;
00080 err:
00081     <span class="keywordflow">return</span> ~0;
00082 }
00083 
00084 <span class="keywordtype">int</span> vars_free(vars_t *vs)
00085 {
00086     var_t *v;
00087     <span class="keywordtype">int</span> t;
00088 
00089     <span class="keywordflow">if</span>(vs)
00090     {
00091         <span class="comment">/* if the var_t objects are owned by this vars_t then free them all */</span>
00092         <span class="keywordflow">if</span>((vs-&gt;flags &amp; VARS_FLAG_FOREIGN) == 0)
00093         {
00094             <span class="comment">/* free all variables */</span>
00095             <span class="keywordflow">for</span>(t = 0; (v = u_list_get_n(vs-&gt;list, t)) != NULL; ++t)
00096                 var_free(v);
00097         }
00098 
00099         <span class="keywordflow">if</span>(vs-&gt;list)
00100             u_list_free(vs-&gt;list);
00101 
00102         U_FREE(vs);
00103     }
00104 
00105     <span class="keywordflow">return</span> 0;
00106 }
00107 
00108 <span class="keywordtype">int</span> vars_add(vars_t *vs, var_t *v)
00109 {
00110     dbg_err_if(vs == NULL);
00111     dbg_err_if(v == NULL);
00112 
00113     dbg_err_if(u_list_add(vs-&gt;list, v));
00114 
00115     <span class="keywordflow">return</span> 0;
00116 err:
00117     <span class="keywordflow">return</span> ~0;
00118 }
00119 
00120 <span class="keywordtype">int</span> vars_del(vars_t *vs, var_t *v)
00121 {
00122     dbg_err_if(vs == NULL);
00123     dbg_err_if(v == NULL);
00124    
00125     dbg_err_if(u_list_del(vs-&gt;list, v));
00126 
00127     <span class="keywordflow">return</span> 0;
00128 err:
00129     <span class="keywordflow">return</span> ~0;
00130 }
00131 
00143 var_t *vars_getn(vars_t *vs, size_t i)
00144 {
00145     dbg_goto_if (vs == NULL, notfound);
00146 
00147     dbg_goto_if (i &gt;= u_list_count(vs-&gt;list), notfound); <span class="comment">/* out of bounds */</span>
00148 
00149     <span class="keywordflow">return</span> u_list_get_n(vs-&gt;list, i);
00150 notfound:
00151     <span class="keywordflow">return</span> NULL;
00152 }
00153 
00164 size_t vars_count(vars_t *vs)
00165 {
00166     dbg_return_if (vs == NULL, 0);
00167 
00168     <span class="keywordflow">return</span> u_list_count(vs-&gt;list);
00169 }
00170 
00182 size_t vars_countn(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00183 {
00184     var_t *v;
00185     size_t c = 0;
00186     <span class="keywordtype">int</span> t;
00187 
00188     dbg_return_if (vs == NULL || name == NULL, 0);
00189 
00190     <span class="keywordflow">for</span>(t = 0; (v = u_list_get_n(vs-&gt;list, t)) != NULL; ++t)
00191     {
00192         <span class="keywordflow">if</span>(strcasecmp(u_string_c(v-&gt;sname), name) == 0)
00193             c++;
00194     }
00195 
00196     <span class="keywordflow">return</span> c;
00197 }
00198 
00212 <span class="keywordtype">int</span> vars_add_urlvar(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *cstr, var_t **pv)
00213 {
00214     <span class="keyword">enum</span> { NAMESZ = 256, VALSZ = 4096 };
00215     <span class="keywordtype">char</span> sname[NAMESZ], svalue[VALSZ];
00216     <span class="keywordtype">char</span> *val, *str = NULL, *name = sname, *value = svalue;
00217     var_t *var = NULL;
00218     ssize_t vsz;
00219     size_t val_len;
00220 
00221     dbg_return_if (vs == NULL, ~0);
00222     dbg_return_if (cstr == NULL, ~0);
00223     <span class="comment">/* v may be NULL */</span>
00224         
00225     <span class="comment">/* dup the string so we can modify it */</span>
00226     str = u_strdup(cstr);
00227     dbg_err_if(str == NULL);
00228 
00229     val = strchr(str, <span class="charliteral">'='</span>);
00230     dbg_err_if(val == NULL);
00231 
00232     <span class="comment">/* zero-term the name part and set the value pointer */</span>
00233     *val++ = 0; 
00234 
00235     val_len = strlen(val);
00236 
00237     <span class="comment">/* if the buffer on the stack is too small alloc a bigger one */</span>
00238     <span class="keywordflow">if</span>(strlen(str) &gt;= NAMESZ)
00239         dbg_err_if((name = u_zalloc(1 + strlen(str))) == NULL);
00240 
00241     <span class="comment">/* if the buffer on the stack is too small alloc a bigger one */</span>
00242     <span class="keywordflow">if</span>(val_len &gt;= VALSZ)
00243         dbg_err_if((value = u_zalloc(1 + val_len)) == NULL);
00244 
00245     <span class="comment">/* url-decode var name */</span>
00246     dbg_err_if(<a class="code" href="group__ut.html#ga30">u_urlncpy</a>(name, str, strlen(str), URLCPY_DECODE) &lt;= 0);
00247 
00248     <span class="comment">/* url-decode var value */</span>
00249     <span class="keywordflow">if</span>(val_len)
00250     {
00251         dbg_err_if((
00252             vsz = <a class="code" href="group__ut.html#ga30">u_urlncpy</a>(value, val, val_len, URLCPY_DECODE)) &lt;= 0);
00253     } <span class="keywordflow">else</span> {
00254         <span class="comment">/* an empty value */</span>
00255         value[0] = 0;
00256         vsz = 1;
00257     }
00258 
00259     <span class="comment">/* dbg("name: [%s]  value: [%s]", name, value); */</span>
00260 
00261     dbg_err_if(var_bin_create(name, value, vsz, &amp;var));
00262 
00263     <span class="comment">/* push into the var list */</span>
00264     dbg_err_if(vars_add(vs, var));
00265 
00266     <span class="keywordflow">if</span>(pv)
00267         *pv = var;
00268 
00269     <span class="comment">/* if the buffer has been alloc'd on the heap then free it */</span>
00270     <span class="keywordflow">if</span>(value &amp;&amp; value != svalue)
00271         U_FREE(value);
00272 
00273     <span class="keywordflow">if</span>(name &amp;&amp; name != sname)
00274         U_FREE(name);
00275 
00276     U_FREE(str);
00277 
00278     <span class="keywordflow">return</span> 0;
00279 err:
00280     <span class="keywordflow">if</span>(value &amp;&amp; value != svalue)
00281         U_FREE(value);
00282     <span class="keywordflow">if</span>(name &amp;&amp; name != sname)
00283         U_FREE(name);
00284     U_FREE(str);
00285     <span class="keywordflow">if</span>(var)
00286         var_free(var);
00287     <span class="keywordflow">return</span> ~0;
00288 }
00289 
00290 <span class="keywordtype">int</span> vars_add_strvar(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *str)
00291 {
00292     <span class="keywordtype">char</span> *eq, *dups = NULL;
00293     var_t *var = NULL;
00294 
00295     dbg_err_if (vs == NULL);
00296     dbg_err_if (str == NULL);
00297 
00298     <span class="comment">/* dup the string (str is const) */</span>
00299     dups = u_strdup(str);
00300     dbg_err_if(dups == NULL);
00301 
00302     <span class="comment">/* search the '=' and replace it with a '\0' */</span>
00303     eq = strchr(dups, <span class="charliteral">'='</span>);
00304     dbg_err_if(eq == NULL);
00305     *eq = 0;
00306 
00307     <span class="comment">/* create a new var obj */</span>
00308     dbg_err_if(var_create(dups, eq+1, &amp;var));
00309 
00310     U_FREE(dups);
00311 
00312     <span class="comment">/* push into the cookie list */</span>
00313     dbg_err_if(vars_add(vs, var));
00314 
00315     <span class="keywordflow">return</span> 0;
00316 err:
00317     U_FREE(dups);
00318     <span class="keywordflow">if</span>(var)
00319         var_free(var);
00320     <span class="keywordflow">return</span> ~0;
00321 }
00322 
00337 var_t *vars_geti(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *var_name, size_t i)
00338 {
00339     var_t *v;
00340     <span class="keywordtype">int</span> t;
00341 
00342     dbg_goto_if (vs == NULL, notfound);
00343     dbg_goto_if (var_name == NULL, notfound);
00344 
00345     <span class="keywordflow">for</span>(t = 0; (v = u_list_get_n(vs-&gt;list, t)) != NULL; ++t)
00346     {
00347         <span class="keywordflow">if</span>(strcasecmp(u_string_c(v-&gt;sname), var_name) == 0)
00348         {
00349             <span class="keywordflow">if</span>(i-- == 0)
00350                 <span class="keywordflow">return</span> v;
00351         }
00352     }
00353 
00354 notfound:
00355     <span class="keywordflow">return</span> NULL;
00356 }
00357 
00371 var_t *vars_get(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *var_name)
00372 {
00373     dbg_return_if (vs == NULL, NULL);
00374     dbg_return_if (var_name == NULL, NULL);
00375 
00376     <span class="keywordflow">return</span> vars_geti(vs, var_name, 0);
00377 }
00378 
00394 <span class="keywordtype">int</span> vars_geti_value_i(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, size_t ith)
00395 {
00396     <span class="keyword">const</span> <span class="keywordtype">char</span> *v;
00397 
00398     dbg_return_if (vs == NULL, 0);
00399     dbg_return_if (name == NULL, 0);
00400 
00401     v = vars_geti_value(vs, name, ith);
00402     <span class="keywordflow">if</span>(v == NULL)
00403         <span class="keywordflow">return</span> 0;
00404     <span class="keywordflow">else</span>
00405         <span class="keywordflow">return</span> atoi(v);
00406 }
00407 
00421 u_string_t *vars_geti_value_s(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, size_t ith)
00422 {
00423     var_t *v = NULL;
00424 
00425     dbg_err_if (vs == NULL);
00426     dbg_err_if (name == NULL);
00427 
00428     dbg_err_if((v = vars_geti(vs, name, ith)) == NULL);
00429 
00430     <span class="keywordflow">return</span> var_get_value_s(v);
00431 err:
00432     <span class="keywordflow">return</span> NULL;
00433 }
00434 
00448 <span class="keywordtype">int</span> vars_get_value_i(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00449 {
00450     dbg_return_if (vs == NULL, 0);
00451     dbg_return_if (name == NULL, 0);
00452 
00453     <span class="keywordflow">return</span> vars_geti_value_i(vs, name, 0);
00454 }
00455 
00471 <span class="keyword">const</span> <span class="keywordtype">char</span> *vars_geti_value(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, size_t ith)
00472 {
00473     var_t *v;
00474 
00475     dbg_return_if (vs == NULL, NULL);
00476     dbg_return_if (name == NULL, NULL);
00477     
00478     v = vars_geti(vs, name, ith);
00479 
00480     <span class="keywordflow">return</span>  v ? var_get_value(v) : NULL;
00481 }
00482 
00496 <span class="keyword">const</span> <span class="keywordtype">char</span> *vars_get_value(vars_t *vs, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00497 {
00498     dbg_return_if (vs == NULL, NULL);
00499     dbg_return_if (name == NULL, NULL);
00500 
00501     <span class="keywordflow">return</span> vars_geti_value(vs, name, 0);
00502 }
00503 
00517 <span class="keywordtype">void</span> vars_foreach(vars_t *vs, <span class="keywordtype">int</span> (*cb)(var_t *, <span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *arg)
00518 {
00519     var_t *v;
00520     <span class="keywordtype">int</span> t;
00521 
00522     dbg_ifb (vs == NULL) <span class="keywordflow">return</span>;
00523     dbg_ifb (cb == NULL) <span class="keywordflow">return</span>;
00524 
00525     <span class="keywordflow">for</span>(t = 0; (v = u_list_get_n(vs-&gt;list, t)) != NULL; ++t)
00526     {
00527         <span class="keywordflow">if</span>(cb(v, arg))
00528             <span class="keywordflow">break</span>;
00529     }
00530 
00531     <span class="keywordflow">return</span>;
00532 }
00533 
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


