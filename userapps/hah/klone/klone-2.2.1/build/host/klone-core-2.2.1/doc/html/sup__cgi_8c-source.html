<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: sup_cgi.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>sup_cgi.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: sup_cgi.c,v 1.12 2008/10/27 21:28:04 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00013 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00014 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00015 <span class="preprocessor">#include &lt;sys/wait.h&gt;</span>
00016 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00017 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00018 <span class="preprocessor">#include &lt;<a class="code" href="http_8h.html">klone/http.h</a>&gt;</span>
00019 <span class="preprocessor">#include &lt;klone/supplier.h&gt;</span>
00020 <span class="preprocessor">#include &lt;klone/io.h&gt;</span>
00021 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00022 <span class="preprocessor">#include &lt;klone/rsfilter.h&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/vhost.h&gt;</span>
00024 
00025 <span class="comment">/* holds environment variables passed to the cgi */</span>
00026 <span class="keyword">typedef</span> <span class="keyword">struct </span>cgi_env_s
00027 {
00028     <span class="keywordtype">char</span> **env;
00029     <span class="keywordtype">int</span> size, count;
00030 } cgi_env_t;
00031 
00032 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_get_config(http_t *h, request_t *rq, u_config_t **pc)
00033 {
00034     u_config_t *config = NULL;
00035     vhost_t *vhost;
00036 
00037     dbg_err_if(h == NULL);
00038     dbg_err_if(rq == NULL);
00039 
00040     dbg_err_if((vhost = http_get_vhost(h, rq)) == NULL);
00041 
00042     *pc = vhost-&gt;config;
00043 
00044     <span class="keywordflow">return</span> 0;
00045 err:
00046     <span class="keywordflow">return</span> ~0;
00047 }
00048 
00049 
00050 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_script(http_t *h, request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *fqn)
00051 {
00052     u_config_t *config, *sub, *base;
00053     <span class="keyword">const</span> <span class="keywordtype">char</span> *dir;
00054     <span class="keywordtype">int</span> i, t;
00055 
00056     <span class="keywordflow">if</span>(fqn == NULL)
00057         <span class="keywordflow">return</span> 0;
00058 
00059     <span class="comment">/* get cgi. config subtree */</span>
00060     dbg_err_if(cgi_get_config(h, rq, &amp;base));
00061 
00062     <span class="comment">/* get cgi. config subtree */</span>
00063     nop_err_if(u_config_get_subkey(base, <span class="stringliteral">"cgi"</span>, &amp;config));
00064 
00065     <span class="comment">/* for each script_di config item */</span>
00066     <span class="keywordflow">for</span>(i = 0; !u_config_get_subkey_nth(config, <span class="stringliteral">"script_alias"</span>, i, &amp;sub); ++i)
00067     {
00068         <span class="keywordflow">if</span>((dir = u_config_get_value(sub)) == NULL)
00069             <span class="keywordflow">continue</span>; <span class="comment">/* empty key */</span>
00070 
00071         <span class="comment">/* find the dir part of the "alias dir" value */</span>
00072         <span class="keywordflow">for</span>(t = strlen(dir) - 1; t &gt; 0; --t)
00073             <span class="keywordflow">if</span>(dir[t] == <span class="charliteral">' '</span> || dir[t] == <span class="charliteral">'\t'</span>)
00074                 <span class="keywordflow">break</span>;
00075 
00076         <span class="keywordflow">if</span>(t == 0)
00077             <span class="keywordflow">continue</span>; <span class="comment">/* malformed value */</span>
00078 
00079         <span class="comment">/* skip the blank */</span>
00080         dir += ++t;
00081 
00082         <span class="comment">/* the first part of fqn must be equal to p and the file must be +x */</span>
00083         <span class="keywordflow">if</span>(!strncmp(fqn, dir, strlen(dir)) &amp;&amp; !access(fqn, X_OK))
00084             <span class="keywordflow">return</span> 1; <span class="comment">/* ok, fqn in in the dir_alias dir or in a subdir */</span>
00085     }
00086 
00087 err:
00088     <span class="keywordflow">return</span> 0;
00089 }
00090 
00091 <span class="comment">/* returns 1 if the file extension in one of those handled by cgi programs */</span>
00092 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_ext(http_t *h, request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *fqn, 
00093         <span class="keyword">const</span> <span class="keywordtype">char</span> **phandler)
00094 {
00095     u_config_t *config, *base;
00096     <span class="keywordtype">char</span> buf[U_FILENAME_MAX];
00097     <span class="keywordtype">char</span> *ext = NULL;
00098     <span class="keyword">const</span> <span class="keywordtype">char</span> *handler;
00099 
00100     <span class="keywordflow">if</span>(fqn == NULL)
00101         <span class="keywordflow">return</span> 0;
00102 
00103     <span class="keywordflow">for</span>(ext = NULL; *fqn; ++fqn) 
00104         <span class="keywordflow">if</span>(*fqn == <span class="charliteral">'.'</span>)
00105             ext = (<span class="keywordtype">char</span>*)fqn;
00106 
00107     <span class="keywordflow">if</span>(ext == NULL)
00108         <span class="keywordflow">return</span> 0; <span class="comment">/* file with no extension */</span>
00109 
00110     ext++; <span class="comment">/* skip '.' */</span>
00111 
00112     <span class="comment">/* get cgi. config subtree */</span>
00113     dbg_err_if(cgi_get_config(h, rq, &amp;base));
00114 
00115     <span class="comment">/* get cgi. config subtree */</span>
00116     nop_err_if(u_config_get_subkey(base, <span class="stringliteral">"cgi"</span>, &amp;config));
00117 
00118     dbg_err_if(u_snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">"%s.handler"</span>, ext));
00119 
00120     <span class="comment">/* check for cgi extension handler */</span>
00121     handler = u_config_get_subkey_value(config, buf);
00122 
00123     <span class="keywordflow">if</span>(handler)
00124     {
00125         <span class="keywordflow">if</span>(phandler)
00126             *phandler = handler;
00127         <span class="keywordflow">return</span> 1;
00128     }
00129 
00130 err:
00131     <span class="keywordflow">return</span> 0;
00132 }
00133 
00134 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_setenv(cgi_env_t *env, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *value)
00135 {
00136     <span class="keyword">enum</span> { CHUNK = 32 };
00137     <span class="keywordtype">char</span> *keyval = NULL, **nenv = NULL;
00138     <span class="keywordtype">int</span> i, nl, vl;
00139 
00140     dbg_return_if(!env || !name || !value, ~0);
00141 
00142     <span class="keywordflow">if</span>((nl = strlen(name)) == 0)
00143         <span class="keywordflow">return</span> ~0;
00144 
00145     vl = strlen(value);
00146 
00147     <span class="comment">/* alloc or realloc the array */</span>
00148     <span class="keywordflow">if</span>(env-&gt;size == 0 || env-&gt;size == env-&gt;count)
00149     {
00150         env-&gt;size += CHUNK;
00151         <span class="keywordflow">if</span>(env-&gt;env == NULL)
00152             nenv = u_zalloc(env-&gt;size * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
00153         <span class="keywordflow">else</span> {
00154             nenv = u_realloc(env-&gt;env, env-&gt;size * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
00155         }
00156         dbg_err_if(nenv == NULL);
00157         <span class="comment">/* zero-out new elems */</span>
00158         <span class="keywordflow">for</span>(i = env-&gt;count; i &lt; env-&gt;size; ++i)
00159             nenv[i] = NULL;
00160         env-&gt;env = nenv;
00161     }
00162 
00163     keyval = u_malloc(nl + vl + 2);
00164     dbg_err_if(keyval == NULL);
00165 
00166     sprintf(keyval, <span class="stringliteral">"%s=%s"</span>, name, value);
00167 
00168     env-&gt;env[env-&gt;count++] = keyval;
00169 
00170     <span class="keywordflow">return</span> 0;
00171 err:
00172     U_FREE(keyval);
00173     U_FREE(nenv);
00174     <span class="keywordflow">return</span> ~0;
00175 }
00176 
00177 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_is_valid_uri(http_t *h, request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *uri, 
00178         size_t len, <span class="keywordtype">void</span> **handle, time_t *mtime)
00179 {
00180     <span class="keyword">struct </span>stat st; 
00181     <span class="keywordtype">char</span> fqn[U_FILENAME_MAX];
00182 
00183     dbg_return_if (uri == NULL, 0);
00184     dbg_return_if (mtime == NULL, 0);
00185     dbg_return_if (len &gt;= U_FILENAME_MAX, 0);
00186 
00187     memcpy(fqn, uri, len);
00188     fqn[len] = 0;
00189 
00190     <span class="comment">/* fqn must be already normalized */</span>
00191     <span class="keywordflow">if</span>(strstr(fqn, <span class="stringliteral">".."</span>))
00192         <span class="keywordflow">return</span> 0; 
00193     
00194     <span class="keywordflow">if</span>( stat(fqn, &amp;st) == 0 &amp;&amp; S_ISREG(st.st_mode))
00195     {
00196         <span class="comment">/* if it's not a cgi given its extension of uri then exit */</span>
00197         <span class="keywordflow">if</span>(!cgi_ext(h, rq, fqn, NULL) &amp;&amp; !cgi_script(h, rq, fqn))
00198             <span class="keywordflow">return</span> 0;
00199 
00200         *mtime = st.st_mtime;
00201         *handle = NULL;
00202         <span class="keywordflow">return</span> 1;
00203     } <span class="keywordflow">else</span>
00204         <span class="keywordflow">return</span> 0;
00205 }
00206 
00207 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *cgi_addr_to_ip(kaddr_t *addr, <span class="keywordtype">char</span> *buf, size_t bufsz)
00208 {
00209     <span class="keyword">const</span> <span class="keywordtype">char</span> *cstr;
00210 
00211 <span class="preprocessor">#ifndef NO_IPV6</span>
00212 <span class="preprocessor"></span>    cstr = inet_ntop( addr-&gt;type == ADDR_IPV4 ? AF_INET : AF_INET6,
00213                 (addr-&gt;type == ADDR_IPV4 ?  
00214                     (<span class="keyword">const</span> <span class="keywordtype">void</span>*)&amp;(addr-&gt;sa.sin.sin_addr) : 
00215                     (<span class="keyword">const</span> <span class="keywordtype">void</span>*)&amp;(addr-&gt;sa.sin6.sin6_addr)),
00216                  buf, bufsz);
00217 <span class="preprocessor">#else</span>
00218 <span class="preprocessor"></span>    cstr = inet_ntoa(addr-&gt;sa.sin.sin_addr);
00219 <span class="preprocessor">#endif</span>
00220 <span class="preprocessor"></span>
00221     dbg_err_if(cstr == NULL);
00222 
00223     <span class="keywordflow">return</span> cstr;
00224 err:
00225     <span class="keywordflow">return</span> NULL;
00226 }
00227 
00228 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_setenv_addr(cgi_env_t *env, kaddr_t *addr, 
00229         <span class="keyword">const</span> <span class="keywordtype">char</span> *label_addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *label_port)
00230 {
00231     <span class="keyword">const</span> <span class="keywordtype">char</span> *cstr;
00232     <span class="keywordtype">char</span> buf[128];
00233 
00234     dbg_return_if(addr-&gt;type == ADDR_UNIX, 0);
00235 
00236     <span class="keywordflow">if</span>((cstr = cgi_addr_to_ip(addr, buf, <span class="keyword">sizeof</span>(buf))) != NULL)
00237         dbg_err_if(cgi_setenv(env, label_addr, cstr));
00238 
00239     u_snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">"%u"</span>, ntohs(addr-&gt;sa.sin.sin_port));
00240     dbg_err_if(cgi_setenv(env, label_port, buf));
00241 
00242     <span class="keywordflow">return</span> 0;
00243 err:
00244     <span class="keywordflow">return</span> ~0;
00245 }
00246 
00247 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_setenv_ctype(cgi_env_t *env, request_t *rq)
00248 {
00249     <span class="keyword">const</span> <span class="keywordtype">char</span> *ct;
00250 
00251     <span class="keywordflow">if</span>((ct = <a class="code" href="group__request.html#ga13">request_get_field_value</a>(rq, <span class="stringliteral">"Content-type"</span>)) != NULL)
00252         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"CONTENT_TYPE"</span>, ct));
00253 
00254     <span class="keywordflow">return</span> 0;
00255 err:
00256     <span class="keywordflow">return</span> ~0;
00257 }
00258 
00259 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_setenv_clen(cgi_env_t *env, request_t *rq)
00260 {
00261     <span class="keywordtype">char</span> buf[32];
00262     ssize_t len;
00263 
00264     <span class="keywordflow">if</span>((len = <a class="code" href="group__request.html#ga23">request_get_content_length</a>(rq)) &gt; 0)
00265     {
00266         dbg_err_if(u_snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">"%ld"</span>, len));
00267         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"CONTENT_LENGTH"</span>, buf));
00268     }
00269 
00270     <span class="keywordflow">return</span> 0;
00271 err:
00272     <span class="keywordflow">return</span> ~0;
00273 }
00274 
00275 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_set_blocking(<span class="keywordtype">int</span> fd)
00276 {
00277     <span class="keywordtype">int</span> flags;
00278 
00279     warn_err_sif((flags = fcntl(fd, F_GETFL)) &lt; 0);
00280 
00281     nop_err_if(fcntl(fd, F_SETFL, flags &amp; (~O_NONBLOCK)) &lt; 0);
00282 
00283     <span class="keywordflow">return</span> 0;
00284 err:
00285     <span class="keywordflow">return</span> ~0;
00286 }
00287 
00288 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_makeenv(request_t *rq, response_t *rs, cgi_env_t *env)
00289 {
00290     kaddr_t *addr;
00291     header_t *h;
00292     field_t *field;
00293     <span class="keyword">const</span> <span class="keywordtype">char</span> *cstr;
00294     <span class="keywordtype">char</span> *p, buf[1024];
00295     <span class="keywordtype">int</span> i;
00296 
00297     u_unused_args(rs);
00298 
00299     dbg_err_if(cgi_setenv(env, <span class="stringliteral">"SERVER_SOFTWARE"</span>, <span class="stringliteral">"klone/"</span> KLONE_VERSION));
00300     dbg_err_if(cgi_setenv(env, <span class="stringliteral">"SERVER_PROTOCOL"</span>, <span class="stringliteral">"HTTP/1.0"</span>));
00301     dbg_err_if(cgi_setenv(env, <span class="stringliteral">"GATEWAY_INTERFACE"</span>, <span class="stringliteral">"CGI/1.1"</span>));
00302     dbg_err_if(cgi_setenv(env, <span class="stringliteral">"REDIRECT_STATUS"</span>, <span class="stringliteral">"200"</span>));
00303 
00304     <span class="comment">/* klone server address */</span>
00305     <span class="keywordflow">if</span>((addr = <a class="code" href="group__request.html#ga9">request_get_addr</a>(rq)) != NULL) 
00306     {
00307         dbg_err_if(cgi_setenv_addr(env, addr, <span class="stringliteral">"SERVER_ADDR"</span>, <span class="stringliteral">"SERVER_PORT"</span>));
00308         <span class="keywordflow">if</span>((cstr = cgi_addr_to_ip(addr, buf, <span class="keyword">sizeof</span>(buf))) != NULL)
00309             dbg_err_if(cgi_setenv(env, <span class="stringliteral">"SERVER_NAME"</span>, cstr));
00310     }
00311 
00312     <span class="comment">/* client address */</span>
00313     <span class="keywordflow">if</span>((addr = <a class="code" href="group__request.html#ga10">request_get_peer_addr</a>(rq)) != NULL) 
00314         dbg_err_if(cgi_setenv_addr(env, addr, <span class="stringliteral">"REMOTE_ADDR"</span>, <span class="stringliteral">"REMOTE_PORT"</span>));
00315 
00316     <span class="comment">/* method */</span>
00317     <span class="keywordflow">switch</span>(<a class="code" href="group__request.html#ga22">request_get_method</a>(rq))
00318     {
00319     <span class="keywordflow">case</span> <a class="code" href="http_8h.html#a33a21">HM_GET</a>:    cstr = <span class="stringliteral">"GET"</span>; <span class="keywordflow">break</span>;
00320     <span class="keywordflow">case</span> <a class="code" href="http_8h.html#a33a22">HM_HEAD</a>:   cstr = <span class="stringliteral">"HEAD"</span>; <span class="keywordflow">break</span>;
00321     <span class="keywordflow">case</span> <a class="code" href="http_8h.html#a33a23">HM_POST</a>:   cstr = <span class="stringliteral">"POST"</span>; <span class="keywordflow">break</span>;
00322     <span class="keywordflow">default</span>:
00323         cstr = <span class="stringliteral">"UNKNOWN"</span>;
00324     }
00325     dbg_err_if(cgi_setenv(env, <span class="stringliteral">"REQUEST_METHOD"</span>, cstr));
00326 
00327     <span class="keywordflow">if</span>(io_is_secure(<a class="code" href="group__request.html#ga7">request_io</a>(rq)))
00328         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"HTTPS"</span>, <span class="stringliteral">"on"</span>));
00329 
00330     <span class="keywordflow">if</span>((cstr = <a class="code" href="group__request.html#ga20">request_get_path_info</a>(rq)) != NULL)
00331         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"PATH_INFO"</span>, cstr));
00332 
00333     <span class="keywordflow">if</span>((cstr = <a class="code" href="group__request.html#ga21">request_get_resolved_path_info</a>(rq)) != NULL)
00334         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"PATH_TRANSLATED"</span>, cstr));
00335 
00336     <span class="keywordflow">if</span>((cstr = <a class="code" href="group__request.html#ga19">request_get_query_string</a>(rq)) != NULL)
00337         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"QUERY_STRING"</span>, cstr));
00338 
00339     <span class="comment">/* content length */</span>
00340     dbg_err_if(cgi_setenv_clen(env, rq));
00341 
00342     <span class="comment">/* content type*/</span>
00343     dbg_err_if(cgi_setenv_ctype(env, rq));
00344 
00345     <span class="keywordflow">if</span>((cstr = <a class="code" href="group__request.html#ga17">request_get_filename</a>(rq)) != NULL)
00346         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"SCRIPT_NAME"</span>, cstr));
00347 
00348     <span class="keywordflow">if</span>((cstr = <a class="code" href="group__request.html#ga15">request_get_uri</a>(rq)) != NULL)
00349         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"REQUEST_URI"</span>, cstr));
00350 
00351     <span class="keywordflow">if</span>((cstr = <a class="code" href="group__request.html#ga18">request_get_resolved_filename</a>(rq)) != NULL)
00352         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"SCRIPT_FILENAME"</span>, cstr));
00353 
00354     <span class="keywordflow">if</span>((cstr = getenv(<span class="stringliteral">"SYSTEMROOT"</span>)) != NULL)
00355         dbg_err_if(cgi_setenv(env, <span class="stringliteral">"SYSTEMROOT"</span>, cstr));
00356 
00357     dbg_err_if((h = <a class="code" href="group__request.html#ga11">request_get_header</a>(rq)) == NULL);
00358 
00359     <span class="comment">/* export all client request headers prefixing them with HTTP_ */</span>
00360     <span class="keywordflow">for</span>(i = 0; i &lt; header_field_count(h); ++i)
00361     {
00362         field = header_get_fieldn(h, i);
00363         dbg_err_if(field == NULL);
00364 
00365         dbg_err_if(u_snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">"HTTP_%s"</span>, 
00366                     field_get_name(field)));
00367 
00368         <span class="comment">/* convert the field name to uppercase and '-' to '_' */</span>
00369         <span class="keywordflow">for</span>(p = buf; *p &amp;&amp; *p != <span class="charliteral">':'</span>; ++p)
00370         {
00371             <span class="keywordflow">if</span>(*p == <span class="charliteral">'-'</span>)
00372                 *p = <span class="charliteral">'_'</span>;
00373             <span class="keywordflow">else</span>
00374                 *p = toupper(*p);
00375         }
00376 
00377         <span class="keywordflow">if</span>(field_get_value(field))
00378             dbg_err_if(cgi_setenv(env, buf, field_get_value(field)));
00379         <span class="keywordflow">else</span>
00380             dbg_err_if(cgi_setenv(env, buf, <span class="stringliteral">""</span>));
00381     }
00382 
00383     <span class="keywordflow">return</span> 0;
00384 err:
00385     <span class="keywordflow">return</span> ~0;
00386 }
00387 
00388 <span class="preprocessor">#define close_pipe(fd)                      \</span>
00389 <span class="preprocessor">    do {                                    \</span>
00390 <span class="preprocessor">        if(fd[0] != -1) close(fd[0]);       \</span>
00391 <span class="preprocessor">        if(fd[1] != -1) close(fd[1]);       \</span>
00392 <span class="preprocessor">    } while(0); </span>
00393 <span class="preprocessor"></span>
00394 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_exec(request_t *rq, response_t *rs, pid_t *pchild, 
00395         <span class="keywordtype">int</span> *pcgi_stdin, <span class="keywordtype">int</span> *pcgi_stdout)
00396 {
00397     <span class="keyword">enum</span> { RD_END <span class="comment">/* read end point */</span>, WR_END <span class="comment">/* write end point */</span>};
00398     <span class="keywordtype">int</span> cgi_stdin[2] = { -1, -1 };
00399     <span class="keywordtype">int</span> cgi_stdout[2] = { -1, -1 };
00400     cgi_env_t cgi_env = { NULL, 0, 0 };
00401     http_t *h;
00402     <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[] = { NULL, NULL, NULL };
00403     <span class="keyword">const</span> <span class="keywordtype">char</span> *cgi_file, *handler;
00404     <span class="keywordtype">char</span> *p, *cgi_path = NULL;
00405     pid_t child;
00406     <span class="keywordtype">int</span> fd;
00407 
00408     dbg_err_if((h = <a class="code" href="group__request.html#ga8">request_get_http</a>(rq)) == NULL);
00409 
00410     <span class="comment">/* create a pair of parent&lt;-&gt;child IPC channels */</span>
00411     dbg_err_if(pipe(cgi_stdin) &lt; 0);
00412     dbg_err_if(pipe(cgi_stdout) &lt; 0);
00413 
00414     crit_err_if((child = fork()) &lt; 0);
00415 
00416     <span class="keywordflow">if</span>(child == 0)
00417     {   <span class="comment">/* child */</span>
00418 
00419         <span class="comment">/* close one end of both channels */</span>
00420         close(cgi_stdin[WR_END]);
00421         close(cgi_stdout[RD_END]);
00422 
00423         <span class="comment">/* setup cgi stdout to point to the write end of the cgi_stdout pipe */</span>
00424         close(STDOUT_FILENO);
00425         crit_err_if(dup2(cgi_stdout[WR_END], STDOUT_FILENO) &lt; 0);
00426         close(cgi_stdout[WR_END]);
00427 
00428         <span class="comment">/* setup cgi stdin to point to the read end of the cgi_stdin pipe */</span>
00429         close(STDIN_FILENO);
00430         crit_err_if(dup2(cgi_stdin[RD_END], STDIN_FILENO) &lt; 0);
00431         close(cgi_stdin[RD_END]);
00432 
00433         <span class="comment">/* ignore cgi stderr */</span>
00434         fd = open(<span class="stringliteral">"/dev/null"</span>, O_WRONLY);
00435         dbg_err_if(fd &lt; 0);
00436         crit_err_if(dup2(fd, STDERR_FILENO) &lt; 0);
00437         close(fd);
00438 
00439         <span class="comment">/* all standard descriptor must be blocking */</span>
00440         cgi_set_blocking(STDOUT_FILENO);
00441         cgi_set_blocking(STDIN_FILENO);
00442         cgi_set_blocking(STDERR_FILENO);
00443 
00444         <span class="comment">/* close any other open fd */</span>
00445         <span class="keywordflow">for</span>(fd = 3; fd &lt; 255; ++fd) 
00446             close(fd);
00447 
00448         <span class="comment">/* extract path name from cgi_file */</span>
00449         dbg_err_if((cgi_file = <a class="code" href="group__request.html#ga18">request_get_resolved_filename</a>(rq)) == NULL);
00450 
00451         cgi_path = u_strdup(cgi_file);
00452         dbg_err_if(cgi_path == NULL);
00453 
00454         <span class="comment">/* cut out filename part */</span>
00455         dbg_err_if((p = strrchr(cgi_path, <span class="charliteral">'/'</span>)) == NULL);
00456         ++p; *p = 0;
00457 
00458         crit_err_sifm(chdir(cgi_path) &lt; 0, <span class="stringliteral">"unable to chdir to %s"</span>, cgi_path);
00459 
00460         U_FREE(cgi_path);
00461 
00462         <span class="comment">/* make the CGI environment vars array */</span>
00463         crit_err_sif(cgi_makeenv(rq, rs, &amp;cgi_env));
00464 
00465         <span class="comment">/* the handler may be the path of the handler or "exec" that means that</span>
00466 <span class="comment">         * the script must be run as is */</span>
00467         <span class="keywordflow">if</span>(!cgi_ext(h, rq, cgi_file, &amp;handler) || !strcasecmp(handler, <span class="stringliteral">"exec"</span>))
00468         {
00469             <span class="comment">/* setup cgi argv (ISINDEX command line handling is not impl) */</span>
00470             argv[0] = cgi_file;
00471 
00472         } <span class="keywordflow">else</span> {
00473             <span class="comment">/* run the handler of this file extension */</span>
00474             argv[0] = handler;
00475             argv[1] = cgi_file;
00476         }
00477 
00478         <span class="comment">/* run the cgi (never returns) */</span>
00479         crit_err_sif(execve(argv[0], argv, cgi_env.env));
00480 
00481         <span class="comment">/* never reached */</span>
00482 
00483     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(child &gt; 0) {
00484         <span class="comment">/* parent */</span>
00485 
00486         <span class="comment">/* close one end of both channels */</span>
00487         close(cgi_stdin[RD_END]);
00488         close(cgi_stdout[WR_END]);
00489 
00490         <span class="comment">/* return cgi read/write descriptors to the parent */</span>
00491         *pcgi_stdin = cgi_stdin[WR_END];
00492         *pcgi_stdout = cgi_stdout[RD_END];
00493         *pchild = child;
00494 
00495         <span class="keywordflow">return</span> 0;
00496 
00497     } <span class="keywordflow">else</span> {
00498         warn_err(<span class="stringliteral">"fork error"</span>);
00499     }
00500 
00501 err:
00502     <span class="keywordflow">if</span>(child == 0)
00503         _exit(1); <span class="comment">/* children exit here on error */</span>
00504     close_pipe(cgi_stdin);
00505     close_pipe(cgi_stdout);
00506     <span class="keywordflow">return</span> ~0;
00507 }
00508 
00509 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_serve(request_t *rq, response_t *rs)
00510 {
00511     codec_t *filter = NULL;
00512     header_t *head = NULL;
00513     field_t *field = NULL;
00514     <span class="keyword">const</span> <span class="keywordtype">char</span> *fqn, *filename;
00515     <span class="keywordtype">char</span> buf[4096];
00516     io_t *out = NULL, *cgi_in = NULL, *cgi_out = NULL;
00517     ssize_t n, tot = 0, clen;
00518     <span class="keywordtype">int</span> cgi_stdin = -1, cgi_stdout = -1, status;
00519     pid_t child;
00520 
00521     dbg_err_if (rq == NULL);
00522     dbg_err_if (rs == NULL);
00523 
00524     <span class="comment">/* shortcuts */</span>
00525     dbg_err_if((out = <a class="code" href="group__response.html#ga16">response_io</a>(rs)) == NULL);
00526     dbg_err_if((head = <a class="code" href="group__response.html#ga17">response_get_header</a>(rs)) == NULL);
00527 
00528     <span class="comment">/* if something goes wrong return a "bad request" */</span>
00529     <a class="code" href="group__response.html#ga6">response_set_status</a>(rs, HTTP_STATUS_BAD_REQUEST); 
00530 
00531     <span class="comment">/* script file name */</span>
00532     fqn = <a class="code" href="group__request.html#ga18">request_get_resolved_filename</a>(rq);
00533 
00534     <span class="comment">/* run the CGI and return its stdin and stdout descriptor */</span>
00535     crit_err_if(cgi_exec(rq, rs, &amp;child, &amp;cgi_stdin, &amp;cgi_stdout));
00536 
00537     <span class="comment">/* by default disable caching */</span>
00538     <a class="code" href="group__response.html#ga11">response_disable_caching</a>(rs);
00539 
00540     <span class="comment">/* copy any POST input data to the CGI */</span>
00541     <span class="keywordflow">if</span>(<a class="code" href="group__request.html#ga22">request_get_method</a>(rq) == <a class="code" href="http_8h.html#a33a23">HM_POST</a> &amp;&amp; 
00542             (clen = <a class="code" href="group__request.html#ga23">request_get_content_length</a>(rq)) &gt; 0)
00543     {
00544         <span class="comment">/* build an io_t object to read cgi output */</span>
00545         crit_err_sif(io_fd_create(cgi_stdin, O_WRONLY, &amp;cgi_out));
00546 
00547         <span class="comment">/* FIXME </span>
00548 <span class="comment">           if the cgi does not read from stdin (and POSTed data is big) </span>
00549 <span class="comment">           we could be block here waiting for the buffer to drain </span>
00550 <span class="comment">         */</span>
00551         
00552         <span class="comment">/* send POSTed data to the cgi (the script may not read it so we don't </span>
00553 <span class="comment">         * complain on broken pipe error) */</span>
00554         crit_if(<a class="code" href="group__basic.html#ga23">io_copy</a>(cgi_out, <a class="code" href="group__request.html#ga7">request_io</a>(rq), clen) &lt; 0);
00555 
00556         <a class="code" href="group__basic.html#ga14">io_free</a>(cgi_out); cgi_out = NULL;
00557         close(cgi_stdin); cgi_stdin = -1;
00558     }
00559 
00560     <span class="comment">/* build an io_t object to read cgi output */</span>
00561     crit_err_sif(io_fd_create(cgi_stdout, O_RDONLY, &amp;cgi_in));
00562 
00563     <span class="comment">/* extract filename part of the fqn */</span>
00564     crit_err_if((filename = strrchr(fqn, <span class="charliteral">'/'</span>)) == NULL);
00565     filename++;
00566 
00567     <span class="comment">/* header of cgis whose name start with nhp- must not be parsed */</span>
00568     <span class="keywordflow">if</span>(strncmp(filename, <span class="stringliteral">"nph-"</span>, 4))
00569     {
00570         <span class="comment">/* create a response filter (used to automatically print the header) */</span>
00571         dbg_err_if(response_filter_create(rq, rs, NULL, &amp;filter));
00572         <a class="code" href="group__basic.html#ga32">io_codec_add_tail</a>(out, filter);
00573         filter = NULL; <span class="comment">/* io_t owns it */</span>
00574 
00575         <span class="comment">/* merge cgi header with response headers */</span>
00576         crit_err_if(header_load_ex(head, cgi_in, HLM_OVERRIDE));
00577 
00578         <span class="comment">/* set the response code */</span>
00579         <span class="keywordflow">if</span>((field = header_get_field(head, <span class="stringliteral">"Status"</span>)) != NULL &amp;&amp; 
00580                 field_get_value(field))
00581         {
00582             <a class="code" href="group__response.html#ga6">response_set_status</a>(rs, atoi(field_get_value(field)));
00583         } <span class="keywordflow">else</span> {
00584             <span class="keywordflow">if</span>(header_get_field(head, <span class="stringliteral">"Location"</span>))
00585                 <a class="code" href="group__response.html#ga6">response_set_status</a>(rs, HTTP_STATUS_MOVED_TEMPORARILY);
00586             <span class="keywordflow">else</span>
00587                 <a class="code" href="group__response.html#ga6">response_set_status</a>(rs, HTTP_STATUS_OK); 
00588         }
00589     } <span class="keywordflow">else</span>
00590         <a class="code" href="group__response.html#ga6">response_set_status</a>(rs, HTTP_STATUS_OK); 
00591 
00592     <span class="comment">/* write cgi output to the client */</span>
00593     <span class="keywordflow">while</span>((n = <a class="code" href="group__basic.html#ga18">io_read</a>(cgi_in, buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)
00594     {
00595         <span class="keywordflow">if</span>(<a class="code" href="group__basic.html#ga19">io_write</a>(out, buf, n) &lt; 0)
00596             <span class="keywordflow">break</span>;
00597         tot += n;
00598     }
00599 
00600     <span class="comment">/* if nothing has been printed by the script; write a dummy byte so </span>
00601 <span class="comment">     * the io_t calls the filter function that, in turn, will print out the </span>
00602 <span class="comment">     * HTTP header (rsfilter will handle it) */</span>
00603     <span class="keywordflow">if</span>(tot == 0)
00604         <a class="code" href="group__basic.html#ga19">io_write</a>(out, <span class="stringliteral">"\n"</span>, 1);
00605 
00606     <span class="keywordflow">if</span>(cgi_in)
00607         <a class="code" href="group__basic.html#ga14">io_free</a>(cgi_in); 
00608     <span class="keywordflow">if</span>(cgi_out)
00609         <a class="code" href="group__basic.html#ga14">io_free</a>(cgi_out); 
00610 
00611     close(cgi_stdin);
00612     close(cgi_stdout);
00613 
00614     <span class="comment">/* wait for the child to finish (FIXME add a max timeout) */</span>
00615     waitpid(child, &amp;status, 0);
00616     <span class="keywordflow">if</span>(WIFEXITED(status) &amp;&amp; WEXITSTATUS(status))
00617         warn(<span class="stringliteral">"cgi exited with [%d]"</span>, WEXITSTATUS(status));
00618 
00619     <span class="keywordflow">return</span> 0;
00620 err:
00621     <span class="keywordflow">if</span>(cgi_out)
00622         <a class="code" href="group__basic.html#ga14">io_free</a>(cgi_out);
00623     <span class="keywordflow">if</span>(cgi_in)
00624         <a class="code" href="group__basic.html#ga14">io_free</a>(cgi_in);
00625     <span class="keywordflow">if</span>(cgi_stdin != -1)
00626         close(cgi_stdin);
00627     <span class="keywordflow">if</span>(cgi_stdout != -1)
00628         close(cgi_stdout);
00629     <span class="keywordflow">return</span> ~0;
00630 }
00631 
00632 <span class="keyword">static</span> <span class="keywordtype">int</span> cgi_init(<span class="keywordtype">void</span>)
00633 {
00634     <span class="keywordflow">return</span> 0;
00635 }
00636 
00637 <span class="keyword">static</span> <span class="keywordtype">void</span> cgi_term(<span class="keywordtype">void</span>)
00638 {
00639     <span class="keywordflow">return</span>;
00640 }
00641 
00642 supplier_t sup_cgi = {
00643     <span class="stringliteral">"cgi supplier"</span>,
00644     cgi_init,
00645     cgi_term,
00646     cgi_is_valid_uri,
00647     cgi_serve
00648 };
00649 
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


