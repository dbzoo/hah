<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: tls.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>tls.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005-2008 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: tls.c,v 1.21 2008/07/10 08:56:13 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00013 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00014 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00015 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00016 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#include &lt;openssl/ssl.h&gt;</span>
00018 <span class="preprocessor">#include &lt;openssl/rand.h&gt;</span>
00019 <span class="preprocessor">#include &lt;openssl/err.h&gt;</span>
00020 <span class="preprocessor">#include &lt;openssl/x509_vfy.h&gt;</span>
00021 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00022 <span class="preprocessor">#include &lt;klone/tls.h&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00024 <span class="preprocessor">#include &lt;klone/tlsprv.h&gt;</span>
00025 
00026 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_sid = 1;
00027 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_inited = 0; 
00028 
00029 <span class="comment">/* private methods */</span>
00030 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_context (SSL_CTX **);
00031 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_load_x509_creds (SSL_CTX *, tls_ctx_args_t *);
00032 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_gendh_params (SSL_CTX *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
00033 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_gen_eph_rsa (SSL_CTX *);
00034 <span class="keyword">static</span> <span class="keywordtype">void</span> tls_rand_seed (<span class="keywordtype">void</span>);
00035 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_sid_context (SSL_CTX *, <span class="keywordtype">int</span> *);
00036 <span class="keyword">static</span> DH *tls_load_dh_param (<span class="keyword">const</span> <span class="keywordtype">char</span> *);
00037 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_no_passphrase_cb (<span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">void</span> *);
00038 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_init_ctx_args (tls_ctx_args_t *);
00039 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_set_ctx_vdepth (u_config_t *, tls_ctx_args_t *);
00040 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_set_ctx_crlopts (u_config_t *, tls_ctx_args_t *);
00041 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_set_ctx_vmode (u_config_t *, tls_ctx_args_t *);
00042 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_check_ctx (tls_ctx_args_t *);
00043 <span class="keyword">static</span> <span class="keywordtype">void</span> tls_free_ctx_args (tls_ctx_args_t *cargs);
00044 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_load_ctx_args (u_config_t *cfg, tls_ctx_args_t **cargs);
00045 <span class="keyword">static</span> SSL_CTX *tls_init_ctx (tls_ctx_args_t *cargs);
00046 <span class="keyword">static</span> <span class="keywordtype">int</span> cb_vfy (<span class="keywordtype">int</span> ok, X509_STORE_CTX *store_ctx);
00047 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL_PSK</span>
00048 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> tls_set_ctx_psk_hash (u_config_t *, tls_ctx_args_t *);
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor"></span>
00051 SSL_CTX *tls_load_init_ctx (u_config_t *cfg)
00052 {
00053     SSL_CTX *ctx = NULL;
00054     tls_ctx_args_t *cargs = NULL;
00055 
00056     dbg_return_if (cfg == NULL, NULL);
00057 
00058     dbg_err_if (tls_load_ctx_args(cfg, &amp;cargs));
00059     dbg_err_if ((ctx = tls_init_ctx(cargs)) == NULL);
00060 
00061     tls_free_ctx_args(cargs);
00062 
00063     <span class="keywordflow">return</span> ctx;
00064 err:
00065     <span class="keywordflow">if</span> (cargs)
00066         tls_free_ctx_args(cargs);
00067     <span class="keywordflow">if</span> (ctx)
00068         SSL_CTX_free(ctx);
00069     <span class="keywordflow">return</span> NULL;
00070 }
00071 
00072 <span class="comment">/* load SSL_CTX args from configuration */</span>
00073 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_load_ctx_args (u_config_t *cfg, tls_ctx_args_t **pcargs)
00074 {
00075     tls_ctx_args_t *cargs = NULL;
00076 
00077     dbg_return_if (cfg == NULL, ~0);
00078     dbg_return_if (pcargs == NULL, ~0);
00079 
00080     cargs = u_zalloc(<span class="keyword">sizeof</span>(tls_ctx_args_t));
00081     dbg_err_if (cargs == NULL);
00082 
00083     (<span class="keywordtype">void</span>) tls_init_ctx_args(cargs);
00084 
00085     cargs-&gt;cert = u_config_get_subkey_value(cfg, <span class="stringliteral">"cert_file"</span>);
00086     cargs-&gt;key = u_config_get_subkey_value(cfg, <span class="stringliteral">"key_file"</span>);
00087     cargs-&gt;certchain = u_config_get_subkey_value(cfg, <span class="stringliteral">"certchain_file"</span>);
00088     cargs-&gt;ca = u_config_get_subkey_value(cfg, <span class="stringliteral">"ca_file"</span>);
00089     cargs-&gt;dh = u_config_get_subkey_value(cfg, <span class="stringliteral">"dh_file"</span>);
00090     cargs-&gt;crl = u_config_get_subkey_value(cfg, <span class="stringliteral">"crl_file"</span>);
00091 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL_PSK</span>
00092 <span class="preprocessor"></span>    <span class="comment">/* handle 'pskdb_file', 'psk_hint' and 'psk_hash' keywords */</span>
00093     cargs-&gt;pskdb = u_config_get_subkey_value(cfg, <span class="stringliteral">"pskdb_file"</span>);
00094     cargs-&gt;psk_hint = u_config_get_subkey_value(cfg, <span class="stringliteral">"psk_hint"</span>);
00095     dbg_err_if (tls_set_ctx_psk_hash(cfg, cargs));
00096 <span class="preprocessor">#endif</span>
00097 <span class="preprocessor"></span>    dbg_err_if (tls_set_ctx_crlopts(cfg, cargs));
00098     dbg_err_if (tls_set_ctx_vdepth(cfg, cargs));
00099     dbg_err_if (tls_set_ctx_vmode(cfg, cargs));
00100 
00101     <span class="comment">/* check cargs consistency against the supplied values */</span>
00102     crit_err_ifm (tls_check_ctx(cargs), 
00103             <span class="stringliteral">"error validating SSL configuration options"</span>);
00104 
00105     *pcargs = cargs;
00106 
00107     <span class="keywordflow">return</span> 0;
00108 err:
00109     <span class="keywordflow">if</span> (cargs)
00110         tls_free_ctx_args(cargs);
00111     <span class="keywordflow">return</span> ~0;
00112 }
00113 
00114 <span class="comment">/* initialize 'parent' SSL context */</span>
00115 <span class="keyword">static</span> SSL_CTX *tls_init_ctx (tls_ctx_args_t *cargs)
00116 {
00117     SSL_CTX *c = NULL;
00118 
00119     dbg_return_if (cargs == NULL, NULL);
00120 
00121     <span class="comment">/* global init */</span>
00122     dbg_err_if (tls_init());
00123 
00124     <span class="comment">/* create SSL CTX from where all the SSL sessions will be cloned */</span>
00125     dbg_err_if (tls_context(&amp;c));
00126 
00127     <span class="comment">/* don't ask for unlocking passphrases: this assumes that all </span>
00128 <span class="comment">     * credentials are stored in clear text */</span>
00129     SSL_CTX_set_default_passwd_cb(c, tls_no_passphrase_cb);
00130 
00131     <span class="comment">/* NOTE: configuration has been sanitized earlier by tls_check_ctx, </span>
00132 <span class="comment">     * so we can be reasonably sure that one (or both) of PSK or X.509 </span>
00133 <span class="comment">     * credentials are in place. */</span>
00134 
00135     <span class="keywordflow">if</span> (cargs-&gt;cert)
00136         <span class="comment">/* set key and certs against the SSL context */</span>
00137         dbg_err_if (tls_load_x509_creds(c, cargs));
00138 
00139 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL_PSK</span>
00140 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (cargs-&gt;pskdb)
00141         <span class="comment">/* load psk DB and set psk callback */</span>
00142         dbg_err_if (tls_psk_init(c, cargs));
00143 <span class="preprocessor">#endif</span>
00144 <span class="preprocessor"></span>
00145     <span class="comment">/* generate RSA ephemeral parameters and load into SSL_CTX */</span>
00146     dbg_err_if (tls_gen_eph_rsa(c));
00147 
00148     <span class="comment">/* (possibly) generate DH parameters and load into SSL_CTX */</span>
00149     dbg_err_if (tls_gendh_params(c, cargs-&gt;dh));
00150 
00151     <span class="comment">/* set the session id context */</span>
00152     dbg_err_if (tls_sid_context(c, &amp;tls_sid));
00153 
00154     <span class="keywordflow">return</span> c;
00155 err:
00156     <span class="keywordflow">if</span> (c)
00157         SSL_CTX_free(c);
00158     <span class="keywordflow">return</span> NULL;
00159 }
00160 
00161 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_sid_context (SSL_CTX *c, <span class="keywordtype">int</span> *sid)
00162 {
00163     <span class="keywordtype">int</span> rc;
00164 
00165     dbg_return_if (c == NULL, ~0); 
00166     dbg_return_if (sid == NULL, ~0); 
00167     
00168     <span class="comment">/* every time tls_init_ctx() is called, move on the session id context */</span>
00169     (*sid)++;
00170 
00171     rc = SSL_CTX_set_session_id_context(c, (<span class="keywordtype">void</span> *) sid, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00172     dbg_err_ifm (rc == 0, <span class="stringliteral">"error setting sid: %s"</span>, tls_get_error());
00173     
00174     <span class="keywordflow">return</span> 0;
00175 err:
00176     <span class="keywordflow">return</span> ~0;
00177 }
00178 
00179 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_context (SSL_CTX **pc)
00180 {
00181     SSL_CTX *c = NULL;
00182 
00183     dbg_return_if (pc == NULL, ~0);
00184 
00185     c = SSL_CTX_new(SSLv23_server_method());
00186     dbg_err_ifm (c == NULL, <span class="stringliteral">"error creating SSL CTX: %s"</span>, tls_get_error());
00187 
00188     *pc = c;
00189 
00190     <span class="keywordflow">return</span> 0;
00191 err:
00192     <span class="keywordflow">return</span> ~0;
00193 }
00194 
00195 <span class="comment">/* XXX very primitive */</span>
00196 <span class="keywordtype">char</span> *tls_get_error (<span class="keywordtype">void</span>)
00197 {
00198     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> e = ERR_get_error();
00199     <span class="keywordflow">return</span> ERR_error_string(e, NULL);
00200 }
00201 
00202 <span class="comment">/* if skey is NULL, assume private key in scert, ca can be NULL */</span>
00203 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_load_x509_creds (SSL_CTX *c, tls_ctx_args_t *cargs)
00204 {
00205     dbg_return_if (c == NULL, ~0);
00206     dbg_return_if (cargs == NULL, ~0);
00207     dbg_return_if (cargs-&gt;cert == NULL, ~0);
00208 
00209     <span class="comment">/* if key file unspecified assume key+cert are bundled */</span>
00210     <span class="keywordflow">if</span> (!cargs-&gt;key)
00211         cargs-&gt;key = cargs-&gt;cert;
00212     
00213     <span class="comment">/* set ca if supplied */</span>
00214     <span class="keywordflow">if</span> (cargs-&gt;ca)
00215         crit_err_ifm(tls_load_verify_locations(c, cargs-&gt;ca),
00216                 <span class="stringliteral">"error loading CA certificate from %s"</span>, cargs-&gt;ca);
00217 
00218     <span class="comment">/* explicitly set the list of CAs for which we accept certificates */</span>
00219     <span class="keywordflow">if</span> (cargs-&gt;ca &amp;&amp; cargs-&gt;vmode != SSL_VERIFY_NONE)
00220         SSL_CTX_set_client_CA_list(c, tls_load_client_CA_file(cargs-&gt;ca));
00221 
00222     <span class="comment">/* load server certificate */</span>
00223     crit_err_ifm (tls_use_certificate_file(c, cargs-&gt;cert, 
00224                 SSL_FILETYPE_PEM) &lt;= 0, 
00225             <span class="stringliteral">"error loading server certificate from %s"</span>, cargs-&gt;cert);
00226 
00227     <span class="comment">/* load private key (perhaps from the cert file) */</span>
00228     crit_err_ifm (tls_use_PrivateKey_file(c, cargs-&gt;key, SSL_FILETYPE_PEM) &lt;= 0,
00229             <span class="stringliteral">"error loading the private key from %s"</span>, cargs-&gt;key);
00230 
00231     <span class="comment">/* check skey consistency against scert */</span>
00232     crit_err_ifm (!SSL_CTX_check_private_key(c),
00233             <span class="stringliteral">"the given private key doesn't seem to belong "</span>
00234             <span class="stringliteral">"to the server certificate"</span>);
00235 
00236     <span class="comment">/* load optional server certficate chain */</span>
00237     <span class="keywordflow">if</span> (cargs-&gt;certchain)
00238         crit_err_ifm (tls_use_certificate_chain(c, cargs-&gt;certchain, 
00239                     0, NULL) &lt; 0, 
00240                 <span class="stringliteral">"error loading server certificate chain"</span>);
00241 
00242     <span class="comment">/* load optional CRL file + opts into args */</span>
00243     <span class="keywordflow">if</span> (cargs-&gt;crl)
00244         crit_err_ifm (tls_use_crls(c, cargs), <span class="stringliteral">"error loading CA CRL file"</span>);
00245 
00246     <span class="comment">/* set SSL verify mode (no, optional, required) and callbacks */</span>
00247     SSL_CTX_set_verify(c, cargs-&gt;vmode, cb_vfy);
00248 
00249     <span class="comment">/* set verification depth */</span>
00250     <span class="keywordflow">if</span> (cargs-&gt;depth &gt; 0)
00251         SSL_CTX_set_verify_depth(c, cargs-&gt;depth);
00252 
00253     <span class="keywordflow">return</span> 0;
00254 err:
00255     <span class="keywordflow">return</span> ~0;
00256 }
00257 
00258 <span class="keyword">static</span> <span class="keywordtype">int</span> cb_vfy (<span class="keywordtype">int</span> ok, X509_STORE_CTX *store_ctx)
00259 {
00260     <span class="keywordtype">int</span> e;
00261     X509 *x;
00262     <span class="keywordtype">char</span> buf[1024];
00263     
00264     <span class="keywordflow">if</span> (ok)
00265         <span class="keywordflow">return</span> ok;
00266 
00267     e = X509_STORE_CTX_get_error(store_ctx);
00268     x = store_ctx-&gt;current_cert;
00269 
00270     <span class="comment">/* at present just put a note in the log.</span>
00271 <span class="comment">     * the idea is that here we can catch CRL specific errors and, based </span>
00272 <span class="comment">     * on the value of crl_opts directive, use different accept/reject </span>
00273 <span class="comment">     * policies.  e.g. return ok in case X509_V_ERR_CRL_HAS_EXPIRED, etc. */</span>
00274     info(<span class="stringliteral">"%s; current certificate subject is %s"</span>, 
00275             X509_verify_cert_error_string(e), 
00276             X509_NAME_oneline(X509_get_subject_name(x), buf, <span class="keyword">sizeof</span> buf));
00277 
00278     <span class="keywordflow">return</span> 0;
00279 }
00280 
00281 <span class="keywordtype">int</span> tls_init (<span class="keywordtype">void</span>)
00282 {
00283     <span class="keywordflow">if</span> (tls_inited)
00284         <span class="keywordflow">return</span> 0;
00285 
00286     SSL_load_error_strings();
00287     dbg_err_if (!SSL_library_init());
00288     tls_rand_seed(); 
00289     tls_inited++;
00290 
00291     <span class="keywordflow">return</span> 0;
00292 
00293 err:
00294     dbg(<span class="stringliteral">"%s"</span>, tls_get_error()); 
00295     <span class="keywordflow">return</span> ~0;
00296 }
00297 
00298 <span class="keyword">static</span> <span class="keywordtype">void</span> tls_rand_seed (<span class="keywordtype">void</span>)
00299 {
00300     <span class="keyword">struct </span>timeval tv;
00301     tls_rand_seed_t seed;
00302 
00303     (<span class="keywordtype">void</span>) gettimeofday(&amp;tv, NULL);
00304     
00305     seed.pid = getpid();
00306     seed.t1 = tv.tv_sec; 
00307     seed.t2 = tv.tv_usec;
00308     seed.stack = (<span class="keywordtype">void</span> *) &amp;seed;
00309 
00310     RAND_seed((<span class="keyword">const</span> <span class="keywordtype">void</span> *) &amp;seed, <span class="keyword">sizeof</span> seed);
00311 }
00312 
00313 <span class="comment">/* generate RSA ephemeral parameters and load'em into SSL_CTX */</span>
00314 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_gen_eph_rsa(SSL_CTX *c)
00315 {
00316     RSA *eph_rsa = NULL;
00317 
00318     dbg_return_if (c == NULL, ~0);
00319 
00320     dbg_err_if (!(eph_rsa = RSA_generate_key(512, RSA_F4, 0, NULL)));
00321     dbg_err_if (!SSL_CTX_set_tmp_rsa(c, eph_rsa));
00322     RSA_free(eph_rsa); <span class="comment">/* eph_rsa is dup'ed by SSL_CTX_set_tmp_rsa() */</span>
00323 
00324     <span class="keywordflow">return</span> 0;
00325 err:
00326     dbg(<span class="stringliteral">"%s"</span>, tls_get_error());
00327     <span class="keywordflow">if</span> (eph_rsa)
00328         RSA_free(eph_rsa);    
00329 
00330     <span class="keywordflow">return</span> ~0;
00331 }
00332 
00333 <span class="comment">/* generate DH ephemeral parameters and load'em into SSL_CTX */</span>
00334 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_gendh_params(SSL_CTX *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *dhfile)
00335 {
00336     DH *eph_dh = NULL;
00337 
00338     dbg_return_if (c == NULL, ~0);
00339 
00340     eph_dh = dhfile ? tls_load_dh_param(dhfile) : get_dh1024(); 
00341     dbg_err_if (!(eph_dh));
00342 
00343     dbg_err_if (!SSL_CTX_set_tmp_dh(c, eph_dh));
00344     DH_free(eph_dh);
00345 
00346 <span class="preprocessor">#if 0</span>
00347 <span class="preprocessor"></span>    <span class="comment">/* Avoid small subgroup attacks (if p and g are strong primes</span>
00348 <span class="comment">     * this is not strictly necessary).  This is said to have a negligible (?)</span>
00349 <span class="comment">     * impact during negotiation phase. TODO: test it ! */</span>
00350     (<span class="keywordtype">void</span>) SSL_CTX_set_options(c, SSL_OP_SINGLE_DH_USE); */
00351 <span class="preprocessor">#endif </span><span class="comment">/* 0 */</span>
00352 
00353     <span class="keywordflow">return</span> 0;
00354 err:
00355     dbg(<span class="stringliteral">"%s"</span>, tls_get_error());
00356     <span class="keywordflow">if</span> (eph_dh)
00357         DH_free(eph_dh);
00358 
00359     <span class="keywordflow">return</span> ~0;
00360 }
00361 
00362 <span class="keyword">static</span> DH *tls_load_dh_param (<span class="keyword">const</span> <span class="keywordtype">char</span> *res_name)
00363 {
00364     DH *dh = NULL;
00365     BIO *bio = NULL;
00366 
00367     dbg_return_if (res_name == NULL, NULL);
00368 
00369     <span class="comment">/* say return_if here instead of err_if because bio_from_emb()</span>
00370 <span class="comment">     * could have failed for a non-openssl error */</span>
00371     dbg_return_if (!(bio = tls_get_file_bio(res_name)), NULL);
00372     dbg_err_if (!(dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL)));
00373 
00374     BIO_free(bio);
00375 
00376     <span class="keywordflow">return</span> dh;
00377 err:
00378     dbg(<span class="stringliteral">"%s"</span>, tls_get_error());
00379     <span class="keywordflow">if</span> (bio) 
00380         BIO_free(bio);
00381 
00382     <span class="keywordflow">return</span> NULL;
00383 }
00384 
00385 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_no_passphrase_cb (<span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> num, <span class="keywordtype">int</span> w, <span class="keywordtype">void</span> *arg)
00386 {
00387     u_unused_args(buf, num, w, arg);
00388 
00389     <span class="keywordflow">return</span> -1;
00390 }
00391 
00392 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_init_ctx_args (tls_ctx_args_t *cargs)
00393 {
00394     dbg_return_if (!cargs, ~0);
00395 
00396     cargs-&gt;cert = NULL;
00397     cargs-&gt;key = NULL;
00398     cargs-&gt;ca = NULL;
00399     cargs-&gt;dh = NULL;
00400     cargs-&gt;crl = NULL;
00401 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL_PSK</span>
00402 <span class="preprocessor"></span>    cargs-&gt;pskdb = NULL;
00403 <span class="preprocessor">#endif</span>
00404 <span class="preprocessor"></span>    cargs-&gt;crlopts = 0;
00405     cargs-&gt;depth = 1;
00406     cargs-&gt;vmode = SSL_VERIFY_NONE;
00407 
00408     <span class="keywordflow">return</span> 0;
00409 }
00410 
00411 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_set_ctx_vdepth (u_config_t *cfg, tls_ctx_args_t *cargs)
00412 {
00413     u_config_t    *k;
00414     
00415     dbg_return_if (!cfg || !cargs, ~0);
00416 
00417     <span class="keywordflow">if</span> (!u_config_get_subkey(cfg, <span class="stringliteral">"verify_depth"</span>, &amp;k))
00418         cargs-&gt;depth = atoi(u_config_get_value(k));    
00419 
00420     <span class="keywordflow">return</span> 0;
00421 }
00422 
00423 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL_PSK</span>
00424 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> tls_set_ctx_psk_hash (u_config_t *cfg, tls_ctx_args_t *cargs)
00425 {
00426     <span class="keywordtype">int</span> rc; 
00427 
00428     dbg_return_if (cfg == NULL, ~0);
00429     dbg_return_if (cargs == NULL, ~0);
00430 
00431     <span class="comment">/* default value is 0 (i.e. cleartext) */</span>
00432     rc = u_config_get_subkey_value_b(cfg, <span class="stringliteral">"psk_hash"</span>, 0, &amp;cargs-&gt;psk_is_hashed);
00433     dbg_return_ifm (rc, ~0, <span class="stringliteral">"bad value given to psk_hash directive"</span>);
00434 
00435     <span class="keywordflow">return</span> 0;
00436 }
00437 <span class="preprocessor">#endif</span>
00438 <span class="preprocessor"></span>
00439 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_set_ctx_crlopts (u_config_t *cfg, tls_ctx_args_t *cargs)
00440 {
00441     <span class="keyword">const</span> <span class="keywordtype">char</span> *v;
00442     
00443     dbg_return_if (cfg == NULL, ~0);
00444     dbg_return_if (cargs == NULL, ~0);
00445 
00446     v = u_config_get_subkey_value(cfg, <span class="stringliteral">"crl_opts"</span>);
00447 
00448     <span class="keywordflow">if</span> (v == NULL)
00449     {
00450         cargs-&gt;crlopts = 0;
00451         <span class="keywordflow">return</span> 0;
00452     }
00453 
00454     <span class="keywordflow">if</span> (!strcasecmp(v, <span class="stringliteral">"check_all"</span>))
00455         cargs-&gt;crlopts = X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL;
00456     <span class="keywordflow">else</span>
00457         warn_err(<span class="stringliteral">"unknown value %s for 'crl_opts' directive"</span>, v);
00458 
00459     <span class="keywordflow">return</span> 0;
00460 err:
00461     <span class="keywordflow">return</span> ~0;
00462 }
00463 
00464 <span class="comment">/* 'verify_mode' and 'verify_client' are aliases</span>
00465 <span class="comment"> * the former is deprecated and retained only for compatibility with klone 1 */</span>
00466 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_set_ctx_vmode (u_config_t *cfg, tls_ctx_args_t *cargs)
00467 {
00468     <span class="keyword">const</span> <span class="keywordtype">char</span> *v;
00469     
00470     dbg_return_if (cfg == NULL, ~0);
00471     dbg_return_if (cargs == NULL, ~0);
00472     
00473     <span class="comment">/* try 'verify_mode' directive first then 'verify_client' */</span>
00474     <span class="keywordflow">if</span>  ((v = u_config_get_subkey_value(cfg, <span class="stringliteral">"verify_mode"</span>)) == NULL)
00475         v = u_config_get_subkey_value(cfg, <span class="stringliteral">"verify_client"</span>);
00476 
00477     <span class="keywordflow">if</span> (v == NULL || !strcasecmp(v, <span class="stringliteral">"no"</span>))  <span class="comment">/* unset == none */</span>
00478         cargs-&gt;vmode = SSL_VERIFY_NONE;
00479     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcasecmp(v, <span class="stringliteral">"optional"</span>))
00480         cargs-&gt;vmode = SSL_VERIFY_PEER;
00481     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcasecmp(v, <span class="stringliteral">"require"</span>))
00482         cargs-&gt;vmode = SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
00483     <span class="keywordflow">else</span>
00484         warn_err(<span class="stringliteral">"unknown verification value:\'%s\'"</span>, v);
00485     
00486     <span class="keywordflow">return</span> 0;
00487 err:
00488     <span class="keywordflow">return</span> ~0;
00489 }
00490 
00491 <span class="keyword">static</span> <span class="keywordtype">int</span> tls_check_ctx (tls_ctx_args_t *cargs)
00492 {
00493     dbg_return_if (cargs == NULL, ~0);
00494 
00495 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL_PSK</span>
00496 <span class="preprocessor"></span>    <span class="comment">/* if no PSK password file is set check for certificate/key */</span>
00497     <span class="keywordflow">if</span> (cargs-&gt;pskdb == NULL)
00498     {
00499 <span class="preprocessor">#endif</span>
00500 <span class="preprocessor"></span>        <span class="comment">/* cert_file is a MUST */</span>
00501         crit_err_ifm (!cargs-&gt;cert || strlen(cargs-&gt;cert) == 0, 
00502             <span class="stringliteral">"missing cert_file option parameter"</span>);
00503 
00504         <span class="comment">/* if private key file is missing, assume the key is inside cert_file */</span>
00505         warn_ifm (cargs-&gt;key == NULL, 
00506             <span class="stringliteral">"missing cert key option, assuming the key is inside cert_file"</span>);
00507 
00508         <span class="comment">/* if verify_mode == "required" the CA file MUST be present */</span>
00509         <span class="keywordflow">if</span> (cargs-&gt;vmode &amp; SSL_VERIFY_PEER)
00510             crit_err_ifm (cargs-&gt;ca == NULL, 
00511                 <span class="stringliteral">"SSL verify is required but CA certificate file is missing"</span>);
00512 
00513 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL_PSK</span>
00514 <span class="preprocessor"></span>    }
00515 <span class="preprocessor">#endif</span>
00516 <span class="preprocessor"></span>
00517     <span class="comment">/* if 'crl_file' was given, set crlopts at least to verify the client</span>
00518 <span class="comment">     * certificate against the supplied CRL */</span>
00519     <span class="keywordflow">if</span> (cargs-&gt;crl &amp;&amp; cargs-&gt;crlopts == 0)
00520         cargs-&gt;crlopts = X509_V_FLAG_CRL_CHECK;
00521 
00522     <span class="keywordflow">return</span> 0;
00523 err:
00524     <span class="keywordflow">return</span> ~0;
00525 }
00526 
00527 
00528 <span class="keyword">static</span> <span class="keywordtype">void</span> tls_free_ctx_args (tls_ctx_args_t *cargs)
00529 {
00530     KLONE_FREE(cargs);
00531     <span class="keywordflow">return</span>;
00532 }
00533 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_LIBOPENSSL */</span>
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


