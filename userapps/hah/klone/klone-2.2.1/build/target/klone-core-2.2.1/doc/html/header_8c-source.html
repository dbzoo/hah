<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: header.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>header.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: header.c,v 1.20 2007/10/26 11:21:51 tho Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00013 <span class="preprocessor">#include &lt;klone/os.h&gt;</span>
00014 <span class="preprocessor">#include &lt;klone/header.h&gt;</span>
00015 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00016 
00029 <span class="keywordtype">int</span> header_set_field(header_t *h, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *value)
00030 {
00031     field_t* n = NULL, *ex;
00032 
00033     dbg_err_if (h == NULL);
00034     dbg_err_if (name == NULL);
00035     dbg_err_if (value == NULL);
00036 
00037     <span class="comment">/* modify existing field if already set */</span>
00038     <span class="keywordflow">if</span>((ex = header_get_field(h, name)) == NULL)
00039     {
00040         dbg_err_if(field_create(name, value, &amp;n));
00041         dbg_err_if(header_add_field(h, n));
00042     } <span class="keywordflow">else</span>
00043         dbg_err_if(field_set(ex, name, value));
00044 
00045     <span class="keywordflow">return</span> 0;
00046 err:
00047     <span class="keywordflow">if</span>(n)
00048         field_free(n);
00049     <span class="keywordflow">return</span> ~0;
00050 }
00051 
00062 <span class="keywordtype">int</span> header_clear(header_t *h)
00063 {
00064     field_t *f;
00065     
00066     dbg_return_if (h == NULL, ~0);
00067     
00068     <span class="comment">/* free all items */</span>
00069     <span class="keywordflow">while</span>((f = TAILQ_FIRST(&amp;h-&gt;fields)) != NULL)
00070     {
00071         header_del_field(h, f);
00072         field_free(f);
00073     }
00074 
00075     <span class="keywordflow">return</span> 0;
00076 }
00077 
00088 size_t header_field_count(header_t *h)
00089 {
00090     dbg_return_if (h == NULL, 0);
00091 
00092     <span class="keywordflow">return</span> h-&gt;nfields;
00093 }
00094 
00106 field_t *header_get_fieldn(header_t *h, size_t idx)
00107 {
00108     field_t *f;
00109     size_t i = 0;
00110 
00111     dbg_goto_if (h == NULL, notfound);
00112     nop_goto_if (idx &gt;= h-&gt;nfields, notfound);
00113 
00114     TAILQ_FOREACH(f, &amp;h-&gt;fields, np)
00115     {
00116         <span class="keywordflow">if</span>(i == idx)
00117             <span class="keywordflow">return</span> f;
00118         ++i;
00119     }
00120 
00121 notfound:
00122     <span class="keywordflow">return</span> NULL;
00123 }
00124 
00138 field_t *header_get_field(header_t *h, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00139 {
00140     field_t *f = NULL;
00141 
00142     dbg_goto_if (h == NULL, notfound);
00143     dbg_goto_if (name == NULL, notfound);
00144 
00145     TAILQ_FOREACH(f, &amp;h-&gt;fields, np)
00146         <span class="keywordflow">if</span>(strcasecmp(f-&gt;name, name) == 0)
00147             <span class="keywordflow">return</span> f;
00148 
00149 notfound:
00150     <span class="keywordflow">return</span> NULL;
00151 }
00152 
00166 <span class="keyword">const</span> <span class="keywordtype">char</span> *header_get_field_value(header_t *h, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00167 {
00168     field_t *f;
00169 
00170     dbg_return_if (h == NULL, NULL);
00171     dbg_return_if (name == NULL, NULL);
00172     
00173     f = header_get_field(h, name);
00174 
00175     <span class="keywordflow">return</span> f ? field_get_value(f) : NULL;
00176 }
00177 
00189 <span class="keywordtype">int</span> header_del_field(header_t *h, field_t *f)
00190 {
00191     dbg_return_if (h == NULL, ~0);
00192     dbg_return_if (f == NULL, ~0);
00193 
00194     TAILQ_REMOVE(&amp;h-&gt;fields, f, np);
00195     h-&gt;nfields--;
00196 
00197     <span class="keywordflow">return</span> 0;
00198 }
00199 
00211 <span class="keywordtype">int</span> header_add_field(header_t *h, field_t *f)
00212 {
00213     dbg_return_if (h == NULL, ~0);
00214     dbg_return_if (f == NULL, ~0);
00215 
00216     TAILQ_INSERT_TAIL(&amp;h-&gt;fields, f, np);
00217     h-&gt;nfields++;
00218 
00219     <span class="keywordflow">return</span> 0;
00220 }
00221 
00222 <span class="keyword">static</span> <span class="keywordtype">int</span> header_process_line(header_t *h, u_string_t *line, <span class="keywordtype">int</span> mode)
00223 {
00224     field_t *ex, *f = NULL;
00225     <span class="keyword">const</span> <span class="keywordtype">char</span> *p;
00226 
00227     dbg_err_if (h == NULL);
00228     dbg_err_if (line == NULL);
00229     
00230     <span class="keywordflow">if</span>(!u_string_len(line))
00231         <span class="keywordflow">return</span> 0;
00232 
00233     <span class="comment">/* alloc a new field */</span>
00234     dbg_err_if(field_create(NULL, NULL, &amp;f));
00235 
00236     <span class="comment">/* parse and set name, value and params */</span>
00237     dbg_err_if(field_set_from_line(f, u_string_c(line)));
00238 
00239     <span class="comment">/* add to this header */</span>
00240     <span class="keywordflow">switch</span>(mode)
00241     {
00242     <span class="keywordflow">case</span> HLM_ADD:
00243         dbg_err_if(header_add_field(h, f));
00244         <span class="keywordflow">break</span>;
00245     <span class="keywordflow">case</span> HLM_OVERRIDE:
00246         <span class="keywordflow">if</span>((ex = header_get_field(h, field_get_name(f))) != NULL)
00247         {
00248             header_del_field(h, ex);
00249             field_free(ex); ex = NULL;
00250         }
00251         dbg_err_if(header_add_field(h, f));
00252         <span class="keywordflow">break</span>;
00253     <span class="keywordflow">case</span> HLM_KEEP:
00254         <span class="keywordflow">if</span>((ex = header_get_field(h, field_get_name(f))) == NULL)
00255             dbg_err_if(header_add_field(h, f));
00256         <span class="keywordflow">else</span> {
00257             field_free(f); f = NULL;
00258         }
00259         <span class="keywordflow">break</span>;
00260     <span class="keywordflow">default</span>:
00261         crit_err(<span class="stringliteral">"unknown header load mode"</span>);
00262     }
00263 
00264     <span class="keywordflow">return</span> 0;
00265 err:
00266     <span class="keywordflow">if</span>(f)
00267         field_free(f);
00268     <span class="keywordflow">return</span> ~0;
00269 }
00270 
00271 <span class="comment">/* load from environment. change each HTTP_name=value to name=value (replacing</span>
00272 <span class="comment">   '_' with '-' */</span>
00273 <span class="keywordtype">int</span> header_load_from_cgienv(header_t *h)
00274 {
00275     <span class="keyword">extern</span> <span class="keywordtype">char</span> **environ;
00276     <span class="keyword">enum</span> { BUFSZ = 256 };
00277     <span class="keywordtype">int</span> i;
00278     size_t blen, t;
00279     <span class="keywordtype">char</span> *e, *eq, buf[BUFSZ];
00280 
00281     <span class="comment">/* add HTTP_* to header field list */</span>
00282     <span class="keywordflow">for</span>(i = 0; environ[i]; ++i)
00283     {
00284         e = environ[i];
00285         <span class="keywordflow">if</span>(strlen(e) &gt; 5 &amp;&amp; strncmp(<span class="stringliteral">"HTTP_"</span>, e, 5) == 0)
00286         {
00287             memset(buf, 0, <span class="keyword">sizeof</span>(buf));
00288 
00289             <span class="comment">/* make a copy of e so we can modify it */</span>
00290             strncpy(buf, e + 5, MIN(BUFSZ, strlen(e + 5)));
00291             buf[BUFSZ-1] = 0;
00292 
00293             eq = strchr(buf, <span class="charliteral">'='</span>);
00294             <span class="keywordflow">if</span>(eq == NULL)
00295                 <span class="keywordflow">continue</span>; <span class="comment">/* malformed */</span>
00296 
00297             *eq = 0; <span class="comment">/* put a \0 between name and value */</span>
00298 
00299             <span class="comment">/* subst '_' with '-' */</span>
00300             <span class="keywordflow">for</span>(t = 0, blen = strlen(buf); t &lt; blen; ++t)
00301                 <span class="keywordflow">if</span>(buf[t] == <span class="charliteral">'_'</span>)
00302                     buf[t] = <span class="charliteral">'-'</span>;
00303 
00304             dbg_if(header_set_field(h, buf, 1 + eq));
00305         }
00306     }
00307 
00308     <span class="keywordflow">return</span> 0;
00309 err:
00310     <span class="keywordflow">return</span> ~0;
00311 }
00312 
00313 <span class="keywordtype">int</span> header_load_ex(header_t *h , io_t *io, <span class="keywordtype">int</span> mode)
00314 {
00315     <span class="keyword">enum</span> { HEADER_MAX_FIELD_COUNT = 256 }; <span class="comment">/* max num of header fields */</span>
00316     u_string_t *line = NULL, *unfolded = NULL;
00317     <span class="keyword">const</span> <span class="keywordtype">char</span> *ln;
00318     size_t len, c;
00319 
00320     dbg_err_if (h == NULL);
00321     dbg_err_if (io == NULL);
00322 
00323     dbg_err_if(u_string_create(NULL, 0, &amp;line));
00324     dbg_err_if(u_string_create(NULL, 0, &amp;unfolded));
00325 
00326     <span class="keywordflow">for</span>(c = HEADER_MAX_FIELD_COUNT; <a class="code" href="group__ut.html#ga37">u_getline</a>(io, line) == 0; --c)
00327     {
00328         warn_err_ifm(c == 0, <span class="stringliteral">"too much header fields"</span>);
00329 
00330         ln = u_string_c(line);
00331         len = u_string_len(line);
00332 
00333         <span class="comment">/* remove trailing nl(s) */</span>
00334         <span class="keywordflow">while</span>(len &amp;&amp; u_isnl(ln[len-1]))
00335             u_string_set_length(line, --len);
00336 
00337         <span class="keywordflow">if</span>(u_string_len(line) == 0)
00338             <span class="keywordflow">break</span>; <span class="comment">/* empty line */</span>
00339 
00340         <span class="keywordflow">if</span>(u_isblank(ln[0])) 
00341         {   <span class="comment">/* this is a chunk of a folded line */</span>
00342             dbg_err_if(u_string_append(unfolded, ln, u_string_len(line)));
00343         } <span class="keywordflow">else</span> {
00344             <span class="keywordflow">if</span>(u_string_len(unfolded))
00345             {
00346                 <span class="comment">/* go process this (already unfolded) line */</span>
00347                 header_process_line(h, unfolded, mode);
00348                 u_string_clear(unfolded);
00349             }
00350             <span class="comment">/* this may be the first line of a folded line so wait next lines */</span>
00351             u_string_copy(unfolded, line);
00352         }
00353     }
00354 
00355     <span class="keywordflow">if</span>(u_string_len(unfolded))
00356         header_process_line(h, unfolded, mode);
00357 
00358     u_string_free(unfolded);
00359     u_string_free(line);
00360 
00361     <span class="keywordflow">return</span> 0;
00362 err:
00363     <span class="keywordflow">if</span>(line)
00364         u_string_free(line);
00365     <span class="keywordflow">if</span>(unfolded)
00366         u_string_free(unfolded);
00367     <span class="keywordflow">return</span> ~0;
00368 }
00369 
00370 <span class="keywordtype">int</span> header_load(header_t *h , io_t *io)
00371 {
00372     <span class="keywordflow">return</span> header_load_ex(h, io, HLM_ADD);
00373 }
00374 
00375 <span class="keywordtype">int</span> header_create(header_t **ph)
00376 {
00377     header_t *h = NULL;
00378 
00379     dbg_err_if (ph == NULL);
00380 
00381     h = u_zalloc(<span class="keyword">sizeof</span>(header_t));
00382     dbg_err_if(h == NULL);
00383 
00384     TAILQ_INIT(&amp;h-&gt;fields);
00385 
00386     *ph = h;
00387 
00388     <span class="keywordflow">return</span> 0;
00389 err:
00390     <span class="keywordflow">return</span> ~0;
00391 }
00392 
00393 <span class="keywordtype">int</span> header_free(header_t *h)
00394 {
00395     <span class="keywordflow">if</span> (h)
00396     {
00397         (<span class="keywordtype">void</span>) header_clear(h);
00398         U_FREE(h);
00399     }
00400 
00401     <span class="keywordflow">return</span> 0;
00402 }
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


