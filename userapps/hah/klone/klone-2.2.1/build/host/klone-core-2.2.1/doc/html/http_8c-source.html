<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: http.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>http.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: http.c,v 1.68 2009/07/25 12:45:17 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00013 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00014 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00015 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#include &lt;openssl/ssl.h&gt;</span>
00017 <span class="preprocessor">#include &lt;openssl/err.h&gt;</span>
00018 <span class="preprocessor">#endif  </span><span class="comment">/* HAVE_LIBOPENSSL */</span>
00019 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00020 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00021 <span class="preprocessor">#include &lt;klone/os.h&gt;</span>
00022 <span class="preprocessor">#include &lt;klone/server.h&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/context.h&gt;</span>
00024 <span class="preprocessor">#include &lt;klone/broker.h&gt;</span>
00025 <span class="preprocessor">#include &lt;klone/request.h&gt;</span>
00026 <span class="preprocessor">#include &lt;klone/ses_prv.h&gt;</span>
00027 <span class="preprocessor">#include &lt;<a class="code" href="response_8h.html">klone/response.h</a>&gt;</span>
00028 <span class="preprocessor">#include &lt;klone/backend.h&gt;</span>
00029 <span class="preprocessor">#include &lt;klone/io.h&gt;</span>
00030 <span class="preprocessor">#include &lt;klone/timer.h&gt;</span>
00031 <span class="preprocessor">#include &lt;klone/tls.h&gt;</span>
00032 <span class="preprocessor">#include &lt;klone/ses_prv.h&gt;</span>
00033 <span class="preprocessor">#include &lt;klone/hook.h&gt;</span>
00034 <span class="preprocessor">#include &lt;klone/hookprv.h&gt;</span>
00035 <span class="preprocessor">#include &lt;klone/access.h&gt;</span>
00036 <span class="preprocessor">#include &lt;klone/vhost.h&gt;</span>
00037 <span class="preprocessor">#include &lt;klone/supplier.h&gt;</span>
00038 <span class="preprocessor">#include "http_s.h"</span>
00039 
00040 <span class="keyword">struct </span>http_status_map_s
00041 {
00042     <span class="keywordtype">int</span> status;
00043     <span class="keyword">const</span> <span class="keywordtype">char</span> *desc;
00044 } http_status_map[] = {
00045     { <a class="code" href="http_8h.html#a32a2">HTTP_STATUS_OK</a>                    , <span class="stringliteral">"OK"</span>                      },
00046     { <a class="code" href="http_8h.html#a32a8">HTTP_STATUS_NOT_MODIFIED</a>          , <span class="stringliteral">"Not Modified"</span>            },
00047     { <a class="code" href="http_8h.html#a32a12">HTTP_STATUS_NOT_FOUND</a>             , <span class="stringliteral">"Not Found"</span>               },
00048     { <a class="code" href="http_8h.html#a32a16">HTTP_STATUS_INTERNAL_SERVER_ERROR</a> , <span class="stringliteral">"Internal Server Error"</span>   },
00049     { <a class="code" href="http_8h.html#a32a6">HTTP_STATUS_MOVED_PERMANENTLY</a>     , <span class="stringliteral">"Moved Permanently"</span>       },
00050     { <a class="code" href="http_8h.html#a32a7">HTTP_STATUS_MOVED_TEMPORARILY</a>     , <span class="stringliteral">"Moved Temporarily"</span>       },
00051     { <a class="code" href="http_8h.html#a32a3">HTTP_STATUS_CREATED</a>               , <span class="stringliteral">"Created"</span>                 },
00052     { <a class="code" href="http_8h.html#a32a4">HTTP_STATUS_ACCEPTED</a>              , <span class="stringliteral">"Accepted"</span>                },
00053     { <a class="code" href="http_8h.html#a32a5">HTTP_STATUS_NO_CONTENT</a>            , <span class="stringliteral">"No Content"</span>              },
00054     { <a class="code" href="http_8h.html#a32a9">HTTP_STATUS_BAD_REQUEST</a>           , <span class="stringliteral">"Bad Request"</span>             },
00055     { <a class="code" href="http_8h.html#a32a10">HTTP_STATUS_UNAUTHORIZED</a>          , <span class="stringliteral">"Unauthorized"</span>            },
00056     { <a class="code" href="http_8h.html#a32a11">HTTP_STATUS_FORBIDDEN</a>             , <span class="stringliteral">"Forbidden"</span>               },
00057     { <a class="code" href="http_8h.html#a32a14">HTTP_STATUS_LENGTH_REQUIRED</a>       , <span class="stringliteral">"Content-Length required"</span> },
00058     { <a class="code" href="http_8h.html#a32a15">HTTP_STATUS_REQUEST_TOO_LARGE</a>     , <span class="stringliteral">"Request data too big"</span>    },
00059     { <a class="code" href="http_8h.html#a32a17">HTTP_STATUS_NOT_IMPLEMENTED</a>       , <span class="stringliteral">"Not Implemented"</span>         },
00060     { <a class="code" href="http_8h.html#a32a18">HTTP_STATUS_BAD_GATEWAY</a>           , <span class="stringliteral">"Bad Gateway"</span>             },
00061     { <a class="code" href="http_8h.html#a32a19">HTTP_STATUS_SERVICE_UNAVAILABLE</a>   , <span class="stringliteral">"Service Unavailable"</span>     },
00062     { 0                                 , NULL                      }
00063 };
00064 
00065 <span class="keyword">enum</span> { URI_MAX = 2048 };
00066 
00067 <span class="comment">/* in cgi.c */</span>
00068 <span class="keywordtype">int</span> cgi_set_request(request_t *rq);
00069 
00070 session_opt_t *http_get_session_opt(http_t *http)
00071 {
00072     dbg_return_if (http == NULL, NULL);
00073 
00074     <span class="keywordflow">return</span> http-&gt;sess_opt;
00075 }
00076 
00077 u_config_t *http_get_config(http_t* http)
00078 {
00079     dbg_return_if (http == NULL, NULL);
00080 
00081     <span class="keywordflow">return</span> http-&gt;config;
00082 }
00083 
00084 <span class="keyword">const</span> <span class="keywordtype">char</span> *http_get_status_desc(<span class="keywordtype">int</span> status)
00085 {
00086     <span class="keyword">struct </span>http_status_map_s *map = http_status_map;
00087     <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="stringliteral">"Unknown Status Code"</span>;
00088 
00089     <span class="keywordflow">for</span>( ; map-&gt;status; ++map)
00090         <span class="keywordflow">if</span>(map-&gt;status == status)
00091         {
00092             msg = map-&gt;desc;
00093             <span class="keywordflow">break</span>;
00094         }
00095 
00096     <span class="keywordflow">return</span> msg;
00097 }
00098 
00099 <span class="keyword">static</span> <span class="keywordtype">int</span> http_try_resolv(<span class="keyword">const</span> <span class="keywordtype">char</span> *alias, <span class="keywordtype">char</span> *dst, <span class="keyword">const</span> <span class="keywordtype">char</span> *uri, 
00100         size_t sz)
00101 {
00102     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *WP = <span class="stringliteral">" \t"</span>;
00103     <span class="keywordtype">char</span> *src, *res, *pp = NULL;
00104     <span class="keywordtype">char</span> v[1024];
00105 
00106     dbg_err_if(dst == NULL);
00107     dbg_err_if(uri == NULL);
00108     dbg_err_if(alias == NULL);
00109 
00110     <span class="comment">/* copy the alias in a buffer, strtok_r modifies it */</span>
00111     dbg_err_if(strlcpy(v, alias, <span class="keyword">sizeof</span>(v)) &gt;= <span class="keyword">sizeof</span>(v));
00112 
00113     <span class="comment">/* src is the source directory */</span>
00114     src = strtok_r(v, WP, &amp;pp); 
00115     dbg_err_if(src == NULL);
00116 
00117     <span class="comment">/* exit if the URI doesn't match this alias */</span>
00118     nop_err_if(strncmp(src, uri, strlen(src)));
00119 
00120     <span class="comment">/* if src doesn't end with a slash check that the next char in uri is a / */</span>
00121     <span class="keywordflow">if</span>(src[strlen(src)-1] != <span class="charliteral">'/'</span>)
00122         nop_err_if(uri[strlen(src)] != <span class="charliteral">'/'</span>);
00123 
00124     <span class="comment">/* alias found, get the resolved prefix */</span>
00125     res = strtok_r(NULL, WP, &amp;pp);
00126     dbg_err_if(res == NULL);
00127 
00128     <span class="comment">/* copy-out the resolved uri to dst */</span>
00129     dbg_err_if(u_path_snprintf(dst, sz, <span class="charliteral">'/'</span>, <span class="stringliteral">"%s/%s"</span>, res, uri + strlen(src)));
00130 
00131     <span class="keywordflow">return</span> 0;
00132 err:
00133     <span class="keywordflow">return</span> ~0;
00134 }
00135 
00136 vhost_list_t* http_get_vhost_list(http_t *http)
00137 {
00138     dbg_err_if(http == NULL);
00139 
00140     <span class="keywordflow">return</span> http-&gt;vhosts;
00141 err:
00142     <span class="keywordflow">return</span> NULL;
00143 }
00144 
00145 vhost_t* http_get_vhost(http_t *h, request_t *rq)
00146 {
00147     <span class="keyword">const</span> <span class="keywordtype">char</span> *host;
00148     <span class="keywordtype">char</span> *p, hostcp[128];
00149     vhost_t *vh = NULL;
00150 
00151     dbg_err_if (h == NULL);
00152     dbg_err_if (rq == NULL);
00153 
00154     <span class="keywordflow">if</span>((vh = request_get_vhost(rq)) != NULL)
00155         <span class="keywordflow">return</span> vh; <span class="comment">/* cached */</span>
00156 
00157     <span class="keywordflow">if</span>((host = <a class="code" href="group__request.html#ga13">request_get_field_value</a>(rq, <span class="stringliteral">"Host"</span>)) != NULL)
00158     {
00159         dbg_err_if(strlcpy(hostcp, host, <span class="keyword">sizeof</span>(hostcp)) &gt;= <span class="keyword">sizeof</span>(hostcp));
00160 
00161         <span class="comment">/* remove :port part */</span>   
00162         <span class="keywordflow">if</span>((p = strrchr(hostcp, <span class="charliteral">':'</span>)) != NULL)
00163             *p = 0;
00164 
00165         vh = vhost_list_get(h-&gt;vhosts, hostcp);
00166     }
00167 
00168     <span class="keywordflow">if</span>(vh == NULL)
00169     {
00170         <span class="comment">/* get the default vhost */</span>
00171         vh = vhost_list_get_n(h-&gt;vhosts, 0);
00172         dbg_err_if(vh == NULL);
00173     }
00174 
00175     <span class="keywordflow">return</span> vh;
00176 err:
00177     <span class="keywordflow">return</span> NULL;
00178 }
00179 
00180 <span class="keywordtype">int</span> http_alias_resolv(http_t *h, request_t *rq, <span class="keywordtype">char</span> *dst, <span class="keyword">const</span> <span class="keywordtype">char</span> *uri, 
00181         size_t sz)
00182 {
00183     u_config_t *config, *cgi;
00184     vhost_t *vhost;
00185     <span class="keywordtype">int</span> i;
00186 
00187     dbg_err_if (h == NULL);
00188     dbg_err_if (dst == NULL);
00189     dbg_err_if (uri == NULL);
00190 
00191     dbg_err_if((vhost = http_get_vhost(h, rq)) == NULL);
00192 
00193     <span class="comment">/* for each dir_alias config item */</span>
00194     <span class="keywordflow">for</span>(i = 0; !u_config_get_subkey_nth(vhost-&gt;config,<span class="stringliteral">"dir_alias"</span>, i, &amp;config); 
00195         ++i)
00196     {
00197         <span class="keywordflow">if</span>(!http_try_resolv(u_config_get_value(config), dst, uri, sz))
00198             <span class="keywordflow">return</span> 0;   <span class="comment">/* alias found, uri resolved */</span>
00199     }
00200 
00201     <span class="comment">/* if there's a cgi tree also try to resolv script_alias rules */</span>
00202     <span class="keywordflow">if</span>(!u_config_get_subkey(vhost-&gt;config, <span class="stringliteral">"cgi"</span>, &amp;cgi))
00203     {
00204         <span class="keywordflow">for</span>(i = 0; !u_config_get_subkey_nth(cgi, <span class="stringliteral">"script_alias"</span>, i, &amp;config);
00205             ++i)
00206         {
00207             <span class="keywordflow">if</span>(!http_try_resolv(u_config_get_value(config), dst, uri, sz))
00208                 <span class="keywordflow">return</span> 0;   <span class="comment">/* alias found, uri resolved */</span>
00209         }
00210     }
00211 
00212     <span class="comment">/* alias not found, prepend dir_root to the uri */</span>
00213     dbg_err_if(u_path_snprintf(dst, sz, <span class="charliteral">'/'</span>, <span class="stringliteral">"%s/%s"</span>, vhost-&gt;dir_root, uri));
00214 
00215     <span class="keywordflow">return</span> 0;
00216 err:
00217     <span class="keywordflow">return</span> ~0;
00218 }
00219 
00220 <span class="keyword">static</span> <span class="keywordtype">int</span> http_is_valid_uri(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t len)
00221 {
00222     <span class="keywordtype">char</span> resolved[U_FILENAME_MAX], uri[URI_MAX];
00223     http_t *h = NULL;
00224 
00225     dbg_err_if (rq == NULL);
00226     dbg_err_if (buf == NULL);
00227 
00228     dbg_err_if (len &gt;= URI_MAX);
00229 
00230     h = <a class="code" href="group__request.html#ga8">request_get_http</a>(rq);
00231     dbg_err_if (h == NULL);
00232     
00233     strncpy(uri, buf, len);
00234     uri[len] = 0;
00235 
00236     <span class="comment">/* try the url itself */</span>
00237     <span class="keywordflow">if</span>(broker_is_valid_uri(h-&gt;broker, h, rq, uri, strlen(uri)))
00238         <span class="keywordflow">return</span> 1;
00239 
00240     <span class="comment">/* try the path-resolved url */</span>
00241     dbg_err_if(http_alias_resolv(h, rq, resolved, uri, U_FILENAME_MAX));
00242 
00243     <span class="keywordflow">return</span> broker_is_valid_uri(h-&gt;broker, h, rq, resolved, strlen(resolved));
00244 err:
00245     <span class="keywordflow">return</span> 0; <span class="comment">/* error, not a valid uri */</span>
00246 }
00247 
00248 <span class="keyword">static</span> <span class="keywordtype">int</span> http_resolv_request(http_t *h, request_t *rq)
00249 {
00250     <span class="keyword">const</span> <span class="keywordtype">char</span> *cstr;
00251     <span class="keywordtype">char</span> resolved[U_FILENAME_MAX];
00252 
00253     dbg_err_if(h == NULL);
00254     dbg_err_if(rq == NULL);
00255     
00256     <span class="comment">/* unalias rq-&gt;filename */</span>
00257     <span class="keywordflow">if</span>((cstr = <a class="code" href="group__request.html#ga17">request_get_filename</a>(rq)) != NULL)
00258     {
00259         dbg_err_if(http_alias_resolv(h, rq, resolved, cstr, U_FILENAME_MAX));
00260 
00261         dbg_err_if(request_set_resolved_filename(rq, resolved));
00262     }
00263 
00264     <span class="comment">/* unalias rq-&gt;path_info */</span>
00265     <span class="keywordflow">if</span>((cstr = <a class="code" href="group__request.html#ga20">request_get_path_info</a>(rq)) != NULL)
00266     {
00267         dbg_err_if(http_alias_resolv(h, rq, resolved, cstr, U_FILENAME_MAX));
00268 
00269         dbg_err_if(request_set_resolved_path_info(rq, resolved));
00270     }
00271 
00272     <span class="keywordflow">return</span> 0;
00273 err:
00274     <span class="keywordflow">return</span> ~0;
00275 }
00276 
00277 <span class="keyword">static</span> <span class="keywordtype">int</span> http_is_valid_index(http_t *h, request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *uri)
00278 {
00279     <span class="keywordtype">char</span> resolved[U_FILENAME_MAX] = { 0 };
00280 
00281     dbg_err_if(u_path_snprintf(resolved, U_FILENAME_MAX, <span class="charliteral">'/'</span>, <span class="stringliteral">"%s/%s"</span>, 
00282             <a class="code" href="group__request.html#ga18">request_get_resolved_filename</a>(rq), uri));
00283 
00284     <span class="keywordflow">if</span>(broker_is_valid_uri(h-&gt;broker, h, rq, resolved, strlen(resolved)))
00285         <span class="keywordflow">return</span> 1; <span class="comment">/* index found */</span>
00286 
00287 err:
00288     <span class="keywordflow">return</span> 0; <span class="comment">/* index not found */</span>
00289 }
00290 
00291 <span class="keyword">static</span> <span class="keywordtype">int</span> http_get_config_index(http_t *h, request_t *rq, <span class="keywordtype">char</span> *idx, size_t sz)
00292 {
00293     vhost_t *vhost;
00294     <span class="keywordtype">char</span> buf[256], *tok, *src, *pp = NULL;
00295     <span class="keyword">const</span> <span class="keywordtype">char</span> *cindex = NULL;
00296 
00297     dbg_err_if (h == NULL);
00298     dbg_err_if (rq == NULL);
00299 
00300     dbg_err_if((vhost = http_get_vhost(h, rq)) == NULL);
00301 
00302     <span class="keywordflow">if</span>((cindex = u_config_get_subkey_value(vhost-&gt;config, <span class="stringliteral">"index"</span>)) == NULL)
00303         <span class="keywordflow">return</span> ~0; <span class="comment">/* index config key missing */</span>
00304 
00305     <span class="comment">/* copy the string (u_tokenize will modify it) */</span>
00306     dbg_err_if(strlcpy(buf, cindex, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="keyword">sizeof</span>(buf));
00307 
00308     <span class="keywordflow">for</span>(src = buf; (tok = strtok_r(src, <span class="stringliteral">" \t"</span>, &amp;pp)) != NULL; src = NULL)
00309     {
00310         <span class="keywordflow">if</span>(!strcmp(tok, <span class="stringliteral">""</span>))
00311             <span class="keywordflow">continue</span>; 
00312 
00313         <span class="keywordflow">if</span>(http_is_valid_index(h, rq, tok))
00314         {
00315             dbg_err_if(strlcpy(idx, tok, sz) &gt;= sz);
00316             <span class="keywordflow">return</span> 0; <span class="comment">/* index page found */</span>
00317         }
00318     }
00319 
00320     <span class="comment">/* fall through */</span>
00321 err:
00322     <span class="keywordflow">return</span> ~0;
00323 }
00324 
00325 <span class="keyword">static</span> <span class="keywordtype">int</span> http_get_default_index(http_t *h, request_t *rq, <span class="keywordtype">char</span> *cindex, 
00326         size_t sz)
00327 {
00328     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *indexes[] = { <span class="stringliteral">"/index.klone"</span>, <span class="stringliteral">"/index.kl1"</span>,
00329         <span class="stringliteral">"/index.klc"</span>, <span class="stringliteral">"/index.klx"</span>, <span class="stringliteral">"/index.html"</span>, <span class="stringliteral">"/index.htm"</span>, NULL };
00330     <span class="keyword">const</span> <span class="keywordtype">char</span> **pg;
00331 
00332     dbg_err_if (h == NULL);
00333     dbg_err_if (rq == NULL);
00334 
00335     <span class="comment">/* try to find an index page between default index uris */</span>
00336     <span class="keywordflow">for</span>(pg = indexes; *pg; ++pg)
00337     {
00338         <span class="keywordflow">if</span>(http_is_valid_index(h, rq, *pg))
00339         {
00340             dbg_err_if(strlcpy(cindex, *pg, sz) &gt;= sz);
00341             <span class="keywordflow">return</span> 0; <span class="comment">/* index page found */</span>
00342         }
00343     }
00344 
00345     <span class="comment">/* fall through */</span>
00346 err:
00347     <span class="keywordflow">return</span> ~0;
00348 }
00349 
00350 <span class="keyword">static</span> <span class="keywordtype">int</span> http_set_index_request(http_t *h, request_t *rq)
00351 {
00352     <span class="keywordtype">char</span> idx[128], uri[1024];
00353 
00354     dbg_err_if (h == NULL);
00355     dbg_err_if (rq == NULL);
00356 
00357     <span class="comment">/* find an index page; try first config options then static index names */</span>
00358     nop_err_if(http_get_config_index(h, rq, idx, <span class="keyword">sizeof</span>(idx)) &amp;&amp;
00359             http_get_default_index(h, rq, idx, <span class="keyword">sizeof</span>(idx)));
00360 
00361     dbg_err_if(u_snprintf(uri, <span class="keyword">sizeof</span>(uri), <span class="stringliteral">"%s%s"</span>, 
00362                 <a class="code" href="group__request.html#ga17">request_get_filename</a>(rq), idx));
00363 
00364     dbg_if(request_set_filename(rq, uri));
00365 
00366     dbg_err_if(http_resolv_request(h, rq));
00367 
00368     <span class="keywordflow">return</span> 0;
00369 err:
00370     <span class="keywordflow">return</span> ~0;
00371 }
00372 
00373 <span class="keyword">static</span> <span class="keywordtype">int</span> http_add_default_header(http_t *h, request_t *rq, response_t *rs)
00374 {
00375     vhost_t *vhost;
00376     time_t now;
00377 
00378     dbg_err_if (h == NULL);
00379     dbg_err_if (rs == NULL);
00380     
00381     dbg_err_if((vhost = http_get_vhost(h, rq)) == NULL);
00382 
00383     <span class="comment">/* set server signature */</span>
00384     dbg_err_if(<a class="code" href="group__response.html#ga20">response_set_field</a>(rs, <span class="stringliteral">"Server"</span>, vhost-&gt;server_sig));
00385 
00386     now = time(NULL);
00387     dbg_err_if(<a class="code" href="group__response.html#ga25">response_set_date</a>(rs, now));
00388 
00389     <span class="keywordflow">return</span> 0;
00390 err:
00391     <span class="keywordflow">return</span> ~0;
00392 }
00393 
00394 <span class="keyword">static</span> <span class="keywordtype">int</span> http_print_error_page(http_t *h, request_t *rq, response_t *rs, 
00395     <span class="keywordtype">int</span> http_status)
00396 {
00397     <span class="keyword">enum</span> { BUFSZ = 64 };
00398     <span class="keyword">const</span> <span class="keywordtype">char</span> *err_page;
00399     <span class="keywordtype">char</span> buf[BUFSZ];
00400     vhost_t *vhost;
00401 
00402     dbg_err_if (h == NULL);
00403     dbg_err_if (rq == NULL);
00404     dbg_err_if (rs == NULL);
00405     dbg_err_if (http_status == 0);
00406     
00407     <span class="comment">/* clean dirty header fields (not for redirects) */</span>
00408     <span class="keywordflow">if</span>(http_status != 302)
00409         dbg_err_if(header_clear(<a class="code" href="group__response.html#ga17">response_get_header</a>(rs)));
00410 
00411     <span class="comment">/* add default header fields */</span>
00412     dbg_err_if(http_add_default_header(h, rq, rs));
00413 
00414     <span class="comment">/* disable page caching */</span>
00415     dbg_err_if(<a class="code" href="group__response.html#ga11">response_disable_caching</a>(rs));
00416 
00417     <span class="comment">/* looking for user provided error page */</span>
00418     dbg_err_if(u_snprintf(buf, BUFSZ, <span class="stringliteral">"error.%d"</span>, http_status));
00419     <span class="keywordflow">if</span>((vhost = http_get_vhost(h, rq)) == NULL)
00420         err_page = u_config_get_subkey_value(h-&gt;config, buf);
00421     <span class="keywordflow">else</span>
00422         err_page = u_config_get_subkey_value(vhost-&gt;config, buf);
00423 
00424     <span class="keywordflow">if</span>(err_page &amp;&amp; !request_set_uri(rq, err_page, NULL, NULL))
00425     {
00426         dbg_err_if(http_resolv_request(h, rq));
00427         <span class="keywordflow">if</span>(http_is_valid_uri(rq, err_page, strlen(err_page)))
00428         {
00429             <span class="comment">/* user provided error page found */</span>
00430             broker_serve(h-&gt;broker, h, rq, rs);
00431             <span class="keywordflow">return</span> 0;
00432         }
00433 
00434         <span class="comment">/* page not found */</span>
00435         warn(<span class="stringliteral">"%d handler page (%s) not found"</span>, http_status, err_page);
00436     }
00437 
00438     <span class="comment">/* be sure that the status code is properly set */</span>
00439     <a class="code" href="group__response.html#ga6">response_set_status</a>(rs, http_status);
00440 
00441     <a class="code" href="group__response.html#ga13">response_print_header</a>(rs);
00442 
00443     <span class="keywordflow">if</span>(<a class="code" href="group__request.html#ga22">request_get_method</a>(rq) == <a class="code" href="http_8h.html#a33a22">HM_HEAD</a>)
00444         <span class="keywordflow">return</span> 0; <span class="comment">/* just the header is requested */</span>
00445 
00446     <span class="comment">/* print default error page */</span>
00447     dbg_err_if(<a class="code" href="group__basic.html#ga28">io_printf</a>(<a class="code" href="group__response.html#ga16">response_io</a>(rs), 
00448         <span class="stringliteral">"&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;"</span>
00449         <span class="stringliteral">"&lt;html&gt;&lt;head&gt;&lt;title&gt;%d %s&lt;/title&gt;&lt;/head&gt;\n"</span>
00450         <span class="stringliteral">"&lt;body&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;URL: %s&lt;/p&gt;&lt;hr&gt;"</span>
00451         <span class="stringliteral">"&lt;address&gt;KLone/%s web server - www.koanlogic.com&lt;/address&gt;"</span>
00452         <span class="stringliteral">"&lt;/body&gt;&lt;/html&gt;"</span>, 
00453         http_status, http_get_status_desc(http_status), 
00454         http_get_status_desc(http_status), 
00455         (<a class="code" href="group__request.html#ga15">request_get_uri</a>(rq) ? <a class="code" href="group__request.html#ga15">request_get_uri</a>(rq) : <span class="stringliteral">""</span>),
00456         KLONE_VERSION
00457         ) &lt; 0);
00458 
00459     <span class="keywordflow">return</span> 0;
00460 err:
00461     <span class="keywordflow">return</span> ~0;
00462 }
00463 
00464 <span class="keyword">static</span> <span class="keywordtype">int</span> http_serve(http_t *h, <span class="keywordtype">int</span> fd)
00465 {
00466     request_t *rq = NULL;
00467     response_t *rs = NULL;
00468     io_t *in = NULL, *out = NULL;
00469     <span class="keywordtype">int</span> cgi = 0, port, rc = <a class="code" href="http_8h.html#a32a16">HTTP_STATUS_INTERNAL_SERVER_ERROR</a>;
00470     <span class="keyword">const</span> <span class="keywordtype">char</span> *gwi = NULL, *cstr;
00471     talarm_t *al = NULL;
00472     kaddr_t *addr;
00473     vhost_t *vhost;
00474     <span class="keyword">struct </span>sockaddr sa;
00475     socklen_t sasz;
00476     <span class="keywordtype">char</span> *uri, nuri[URI_MAX];
00477     supplier_t *sup;
00478 
00479     u_unused_args(al);
00480 
00481     dbg_err_if (h == NULL);
00482     dbg_err_if (fd &lt; 0);
00483     
00484     <span class="keywordflow">if</span>(fd == 0 &amp;&amp; (gwi = getenv(<span class="stringliteral">"GATEWAY_INTERFACE"</span>)) != NULL)
00485         cgi++; <span class="comment">/* klone is being used as a CGI */</span>
00486 
00487     <span class="comment">/* create a request object */</span>
00488     dbg_err_if(request_create(h, &amp;rq));
00489     request_set_cgi(rq, cgi);
00490 
00491     <span class="comment">/* save local and peer address into the request object */</span>
00492     dbg_err_if(addr_create(&amp;addr));
00493 
00494     <span class="keywordflow">if</span>(cgi)
00495     {
00496         <span class="keywordflow">if</span>(getenv(<span class="stringliteral">"REMOTE_ADDR"</span>) &amp;&amp; getenv(<span class="stringliteral">"REMOTE_PORT"</span>))
00497         {
00498             port = atoi(getenv(<span class="stringliteral">"REMOTE_PORT"</span>));
00499             dbg_err_if(addr_set(addr, getenv(<span class="stringliteral">"REMOTE_ADDR"</span>), port));
00500             dbg_err_if(request_set_addr(rq, addr));
00501         }
00502 
00503         <span class="keywordflow">if</span>(getenv(<span class="stringliteral">"SERVER_ADDR"</span>))
00504         {
00505             <span class="keywordflow">if</span>(getenv(<span class="stringliteral">"SERVER_PORT"</span>))
00506                 port = atoi(getenv(<span class="stringliteral">"SERVER_PORT"</span>));
00507             <span class="keywordflow">else</span>
00508                 port = 80;
00509             dbg_err_if(addr_set(addr, getenv(<span class="stringliteral">"SERVER_ADDR"</span>), port));
00510             dbg_err_if(request_set_peer_addr(rq, addr));
00511         }
00512     } <span class="keywordflow">else</span> {
00513         <span class="comment">/* set local addr */</span>
00514         sasz = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr);
00515         dbg_err_if(getsockname(fd, &amp;sa, &amp;sasz));
00516         dbg_err_if(addr_set_from_sa(addr, &amp;sa, sasz));
00517         dbg_err_if(request_set_addr(rq, addr));
00518 
00519         <span class="comment">/* set peer addr */</span>
00520         sasz = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr);
00521         dbg_err_if(getpeername(fd, &amp;sa, &amp;sasz));
00522         dbg_err_if(addr_set_from_sa(addr, &amp;sa, sasz));
00523         dbg_err_if(request_set_peer_addr(rq, addr));
00524     }
00525 
00526     addr_free(addr);
00527     addr = NULL;
00528 
00529 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL</span>
00530 <span class="preprocessor"></span>    <span class="comment">/* create input io buffer */</span>
00531     <span class="keywordflow">if</span>(h-&gt;ssl &amp;&amp; !cgi)
00532         dbg_err_if(io_ssl_create(fd, IO_FD_CLOSE, 0, h-&gt;ssl_ctx, &amp;in));
00533     <span class="keywordflow">else</span>
00534         dbg_err_if(io_fd_create(fd, IO_FD_CLOSE, &amp;in));
00535 <span class="preprocessor">#else</span>
00536 <span class="preprocessor"></span>    <span class="comment">/* create input io buffer */</span>
00537     dbg_err_if(io_fd_create(fd, IO_FD_CLOSE, &amp;in));
00538 <span class="preprocessor">#endif</span>
00539 <span class="preprocessor"></span>
00540     <span class="comment">/* bind the request object to the 'in' io_t */</span>
00541     dbg_err_if(request_bind(rq, in));
00542     in = NULL; 
00543 
00544     <span class="comment">/* create a response object */</span>
00545     dbg_err_if(response_create(h, &amp;rs));
00546 
00547     response_set_cgi(rs, cgi);
00548 
00549     <span class="keywordflow">if</span>(cgi)
00550         dbg_err_if(cgi_set_request(rq));
00551 
00552     <span class="comment">/* create the output io_t */</span>
00553     <span class="keywordflow">if</span>(cgi)
00554         dbg_err_if(io_fd_create((cgi ? 1 : dup(fd)), IO_FD_CLOSE, &amp;out));
00555     <span class="keywordflow">else</span> {
00556         <span class="comment">/* create the response io_t dup'ping the request io_t object */</span>
00557         dbg_err_if(<a class="code" href="group__basic.html#ga15">io_dup</a>(<a class="code" href="group__request.html#ga7">request_io</a>(rq), &amp;out));
00558     }
00559 
00560     <span class="comment">/* default method used if we cannot parse the request (bad request) */</span>
00561     <a class="code" href="group__response.html#ga8">response_set_method</a>(rs, HM_GET);
00562 
00563     <span class="comment">/* bind the response to the connection c */</span>
00564     dbg_err_if(response_bind(rs, out));
00565     out = NULL;
00566 
00567     <span class="comment">/* server ready, parse the request */</span>
00568     dbg_err_if(<a class="code" href="group__response.html#ga6">response_set_status</a>(rs, HTTP_STATUS_BAD_REQUEST));
00569     rc = <a class="code" href="http_8h.html#a32a9">HTTP_STATUS_BAD_REQUEST</a>;
00570 
00571     <span class="comment">/* parse request. may fail on timeout */</span>
00572     dbg_err_if(request_parse_header(rq, http_is_valid_uri, rq));
00573 
00574     <a class="code" href="group__response.html#ga8">response_set_method</a>(rs, <a class="code" href="group__request.html#ga22">request_get_method</a>(rq));
00575 
00576     <span class="comment">/* get and cache the vhost ptr to speed up next lookups */</span>
00577     dbg_err_if((vhost = http_get_vhost(h, rq)) == NULL);
00578     request_set_vhost(rq, vhost);
00579 
00580     <span class="comment">/* if we're running in server mode then resolv aliases and dir_root */</span>
00581     dbg_err_if(http_resolv_request(h, rq));
00582 
00583     <span class="comment">/* if the uri end with a slash then return an index page */</span>
00584     request_get_sup_info(rq, &amp;sup, NULL, NULL);
00585     <span class="keywordflow">if</span>(sup == NULL &amp;&amp; (cstr = <a class="code" href="group__request.html#ga17">request_get_filename</a>(rq)) != NULL &amp;&amp; 
00586             cstr[strlen(cstr)-1] == <span class="charliteral">'/'</span>)
00587         dbg_if(http_set_index_request(h, rq)); <span class="comment">/* set the index page */</span>
00588 
00589     <span class="comment">/* add default header fields */</span>
00590     dbg_err_if(http_add_default_header(h, rq, rs));
00591 
00592     <span class="comment">/* set default successfull status code */</span>
00593     dbg_err_if(<a class="code" href="group__response.html#ga6">response_set_status</a>(rs, HTTP_STATUS_OK));
00594 
00595     <span class="comment">/* serve the page; on error write out a simple error page */</span>
00596     rc = broker_serve(h-&gt;broker, h, rq, rs);
00597 
00598     <span class="comment">/* on 404 (file not found) try to find out if this is a directory request </span>
00599 <span class="comment">       i.e. http://site:port/dir redirects to /dir/ */</span>
00600     <span class="keywordflow">if</span>(<a class="code" href="group__response.html#ga7">response_get_status</a>(rs) == 404 &amp;&amp; (uri = <a class="code" href="group__request.html#ga15">request_get_uri</a>(rq)) != NULL &amp;&amp;
00601             uri[strlen(uri)-1] != <span class="charliteral">'/'</span>)
00602     {
00603         <span class="keywordflow">if</span>(!http_set_index_request(h, rq))
00604         {
00605             strlcpy(nuri, <a class="code" href="group__request.html#ga15">request_get_uri</a>(rq), <span class="keyword">sizeof</span>(nuri));
00606             strlcat(nuri, <span class="stringliteral">"/"</span>, <span class="keyword">sizeof</span>(nuri));
00607 
00608             <span class="keywordflow">if</span>(<a class="code" href="group__request.html#ga20">request_get_path_info</a>(rq))
00609                 strlcat(nuri, <a class="code" href="group__request.html#ga20">request_get_path_info</a>(rq), <span class="keyword">sizeof</span>(nuri));
00610 
00611             <span class="keywordflow">if</span>(<a class="code" href="group__request.html#ga19">request_get_query_string</a>(rq))
00612             {
00613                 strlcat(nuri, <span class="stringliteral">"?"</span>, <span class="keyword">sizeof</span>(nuri));
00614                 strlcat(nuri, <a class="code" href="group__request.html#ga19">request_get_query_string</a>(rq), <span class="keyword">sizeof</span>(nuri));
00615             }
00616 
00617             <a class="code" href="group__response.html#ga5">response_redirect</a>(rs, nuri);
00618             rc = <a class="code" href="http_8h.html#a32a7">HTTP_STATUS_MOVED_TEMPORARILY</a>;
00619         }
00620     }
00621 
00622     <span class="comment">/* log the request */</span>
00623     <span class="keywordflow">if</span>(vhost-&gt;klog)
00624         dbg_if(access_log(h, vhost-&gt;al_config, rq, rs));
00625 
00626     <span class="comment">/* call the hook that fires on each request */</span>
00627     hook_call(request, rq, rs);
00628 
00629     <span class="comment">/* on broker_serve error jump to err */</span>
00630     nop_err_if(rc != 0);
00631 
00632     <span class="comment">/* page successfully served */</span>
00633 
00634     request_free(rq);
00635     response_free(rs); <span class="comment">/* must be free'd after the request object because</span>
00636 <span class="comment">                          the rsfilter references the response object during</span>
00637 <span class="comment">                          the flush of the codec (so the response object must</span>
00638 <span class="comment">                          not be free'd) that happens during the io_free call */</span>
00639     <span class="keywordflow">return</span> 0;
00640 err:
00641     <span class="comment">/* hook get fired also on error */</span>
00642     <span class="keywordflow">if</span>(rq &amp;&amp; rs)
00643         hook_call(request, rq, rs);
00644 
00645     <span class="keywordflow">if</span>(rc &amp;&amp; rq &amp;&amp; rs &amp;&amp; <a class="code" href="group__response.html#ga16">response_io</a>(rs))
00646         http_print_error_page(h, rq, rs, rc); <span class="comment">/* print the error page */</span>
00647     <span class="keywordflow">if</span>(in)
00648         <a class="code" href="group__basic.html#ga14">io_free</a>(in);
00649     <span class="keywordflow">if</span>(out)
00650         <a class="code" href="group__basic.html#ga14">io_free</a>(out);
00651     <span class="keywordflow">if</span>(rq)
00652         request_free(rq);
00653     <span class="keywordflow">if</span>(rs)
00654         response_free(rs);
00655     <span class="keywordflow">return</span> ~0;
00656 }
00657 
00658 <span class="keyword">static</span> <span class="keywordtype">int</span> http_free(http_t *h)
00659 {
00660     dbg_return_if (h == NULL, 0);   <span class="comment">/* it's ok */</span>
00661 
00662     <span class="keywordflow">if</span>(h-&gt;broker)
00663         broker_free(h-&gt;broker);
00664 
00665     <span class="keywordflow">if</span>(h-&gt;vhosts)
00666         vhost_list_free(h-&gt;vhosts);
00667 
00668     U_FREE(h);
00669 
00670     <span class="keywordflow">return</span> 0;
00671 }
00672 
00673 <span class="keyword">static</span> <span class="keywordtype">int</span> http_add_vhost(http_t *http, <span class="keyword">const</span> <span class="keywordtype">char</span> *host, u_config_t *c)
00674 {
00675     vhost_t *top, *vhost = NULL;
00676     u_config_t *child;
00677     <span class="keyword">const</span> <span class="keywordtype">char</span> *v;
00678 
00679     dbg_err_if (http == NULL);
00680     dbg_err_if (host == NULL);
00681     dbg_err_if (c == NULL);
00682 
00683     dbg_err_if(vhost_create(&amp;vhost));
00684     
00685     vhost-&gt;host = host;
00686     vhost-&gt;config = c;
00687     vhost-&gt;http = http;
00688 
00689     <span class="comment">/* set defaults */</span>
00690     vhost-&gt;server_sig = <span class="stringliteral">"klone/"</span> KLONE_VERSION;
00691     vhost-&gt;dir_root = <span class="stringliteral">""</span>;
00692     vhost-&gt;index = NULL;
00693     vhost-&gt;send_enc_deflate = 0; 
00694 
00695     <span class="comment">/* if there's a per-vhost access_log open it, otherwise inherit from the</span>
00696 <span class="comment">       main server configuration */</span>
00697     <span class="keywordflow">if</span>((child = u_config_get_child(c, <span class="stringliteral">"access_log"</span>)) != NULL)
00698     {
00699         v = u_config_get_value(child);
00700 
00701         <span class="comment">/* if the access_log key is not "no" then load the log configuration */</span>
00702         <span class="keywordflow">if</span>(v == NULL || strcasecmp(v, <span class="stringliteral">"no"</span>))
00703             dbg_err_if(klog_open_from_config(child, &amp;vhost-&gt;klog));
00704 
00705         vhost-&gt;al_config = child;
00706     } <span class="keywordflow">else</span> {
00707         <span class="comment">/* if there's a global access log use it */</span>
00708         <span class="keywordflow">if</span>((top = vhost_list_get_n(http-&gt;vhosts, 0)) != NULL)
00709         {
00710             <span class="comment">/* inherit from the main config (may be NULL) */</span>
00711             vhost-&gt;klog = top-&gt;klog;
00712             vhost-&gt;al_config = top-&gt;al_config;
00713         }
00714     }
00715 
00716     <span class="comment">/* send_enc_deflate (disable if not configured) */</span>
00717     dbg_err_if(u_config_get_subkey_value_b(c, <span class="stringliteral">"send_enc_deflate"</span>, 0, 
00718         &amp;vhost-&gt;send_enc_deflate));
00719 
00720     <span class="comment">/* server signature */</span>
00721     <span class="keywordflow">if</span>((v = u_config_get_subkey_value(c, <span class="stringliteral">"server_sig"</span>)) != NULL)
00722         vhost-&gt;server_sig = v;
00723 
00724     <span class="comment">/* html dir root */</span>
00725     <span class="keywordflow">if</span>((v = u_config_get_subkey_value(c, <span class="stringliteral">"dir_root"</span>)) != NULL)
00726         vhost-&gt;dir_root = v;
00727     <span class="keywordflow">else</span>
00728         crit_err(<span class="stringliteral">"dir_root must be set (vhost: %s)"</span>, vhost-&gt;host);
00729 
00730     <span class="comment">/* index page */</span>
00731     <span class="keywordflow">if</span>((v = u_config_get_subkey_value(c, <span class="stringliteral">"index"</span>)) != NULL)
00732         vhost-&gt;index = v;
00733 
00734     dbg_err_if(vhost_list_add(http-&gt;vhosts, vhost));
00735 
00736     <span class="keywordflow">return</span> 0;
00737 err:
00738     <span class="keywordflow">if</span>(vhost)
00739         vhost_free(vhost);
00740     <span class="keywordflow">return</span> ~0;
00741 }
00742 
00743 <span class="keyword">static</span> <span class="keywordtype">int</span> config_inherit(u_config_t *dst, u_config_t *from)
00744 {
00745     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *dont_inherit[] = {
00746         <span class="stringliteral">"addr"</span>, <span class="stringliteral">"model"</span>, <span class="stringliteral">"type"</span>, <span class="stringliteral">"dir_root"</span>, <span class="stringliteral">"dir_alias"</span>, <span class="stringliteral">"script_alias"</span>, 
00747         <span class="stringliteral">"access_log"</span>, NULL
00748     };
00749     u_config_t *config, *child = NULL;
00750     <span class="keyword">const</span> <span class="keywordtype">char</span> **di, *key, *value;
00751     <span class="keywordtype">int</span> n;
00752 
00753     dbg_err_if (dst == NULL);
00754     dbg_err_if (from == NULL);
00755 
00756     <span class="keywordflow">for</span>(n = 0; (config = u_config_get_child_n(from, NULL, n)); ++n)
00757     {
00758         <span class="keywordflow">if</span>(u_config_get_child(config, <span class="stringliteral">"dir_root"</span>))
00759             <span class="keywordflow">continue</span>; <span class="comment">/* skip vhost config subtree */</span>
00760         
00761         key = u_config_get_key(config);
00762         value = u_config_get_value(config);
00763 
00764         <span class="comment">/* don't inherit keys listed in dont_inherit array */</span>
00765         <span class="keywordflow">for</span>(di = dont_inherit; *di; ++di)
00766             <span class="keywordflow">if</span>(strcasecmp(*di, key) == 0)
00767                 <span class="keywordflow">goto</span> next;
00768 
00769         dbg_err_if(u_config_add_child(dst, key, &amp;child));
00770         dbg_err_if(u_config_set_value(child, value));
00771 
00772         dbg_err_if(config_inherit(child, config));
00773 
00774     next:;
00775     }
00776 
00777     <span class="keywordflow">return</span> 0;
00778 err:
00779     <span class="keywordflow">return</span> ~0;
00780 }
00781 
00782 <span class="keyword">static</span> <span class="keywordtype">int</span> http_set_vhost_list(http_t *http)
00783 {
00784     u_config_t *config;
00785     <span class="keywordtype">int</span> n;
00786 
00787     dbg_err_if (http == NULL);
00788 
00789     <span class="comment">/* virtual vhost that stores the main server config */</span>
00790     dbg_err_if(http_add_vhost(http, <span class="stringliteral">""</span>, http-&gt;config));
00791 
00792     <span class="comment">/* look for vhosts (any key that contain a dir_root subkey is a vhost) */</span>
00793     <span class="keywordflow">for</span>(n = 0; (config = u_config_get_child_n(http-&gt;config, NULL, n)); ++n)
00794     {
00795         <span class="keywordflow">if</span>(u_config_get_child(config, <span class="stringliteral">"dir_root"</span>) == NULL)
00796             <span class="keywordflow">continue</span>; <span class="comment">/* it's not a vhost config branch */</span>
00797 
00798         dbg_err_if(u_config_get_key(config) == NULL);
00799 
00800         info(<span class="stringliteral">"configuring virtual host [%s]"</span>, u_config_get_key(config));
00801 
00802         <span class="comment">/* inherit top-level values */</span>
00803         dbg_err_if(config_inherit(config, http-&gt;config));
00804 
00805         dbg_err_if(http_add_vhost(http, u_config_get_key(config), config));
00806     }
00807 
00808     <span class="keywordflow">return</span> 0;
00809 err:
00810     <span class="keywordflow">return</span> ~0;
00811 }
00812 
00813 <span class="keyword">static</span> <span class="keywordtype">int</span> http_create(u_config_t *config, http_t **ph)
00814 {
00815     http_t *h = NULL;
00816 
00817     dbg_err_if (config == NULL);
00818     dbg_err_if (ph == NULL);
00819 
00820     h = u_zalloc(<span class="keyword">sizeof</span>(http_t));
00821     dbg_err_if(h == NULL);
00822 
00823     h-&gt;config = config;
00824 
00825     dbg_err_if(vhost_list_create(&amp;h-&gt;vhosts));
00826 
00827     <span class="comment">/* init page broker (and page suppliers) */</span>
00828     dbg_err_if(broker_create(&amp;h-&gt;broker));
00829 
00830     <span class="comment">/* load main server and vhosts config */</span>
00831     dbg_err_if(http_set_vhost_list(h));
00832 
00833     <span class="comment">/* print-out config with inherited values */</span>
00834     <span class="keywordflow">if</span>(ctx-&gt;debug &gt; 1)
00835         u_config_print(ctx-&gt;config, 0);
00836 
00837     *ph = h;
00838 
00839     <span class="keywordflow">return</span> 0;
00840 err:
00841     <span class="keywordflow">if</span>(h)
00842         http_free(h);
00843     <span class="keywordflow">return</span> ~0;
00844 }
00845 
00846 <span class="keyword">static</span> <span class="keywordtype">int</span> http_backend_serve(<span class="keyword">struct</span> backend_s *be, <span class="keywordtype">int</span> fd)
00847 {
00848     http_t *h;
00849     <span class="keywordtype">int</span> rc;
00850 
00851     dbg_err_if (be == NULL);
00852     dbg_err_if (be-&gt;arg == NULL);
00853     dbg_err_if (fd &lt; 0);
00854     
00855     h = (http_t *) be-&gt;arg;
00856     
00857     <span class="comment">/* new connection accepted on http listening socket, handle it */</span>
00858     rc = http_serve(h, fd);
00859 
00860     <span class="keywordflow">return</span> rc;
00861 err:
00862     <span class="keywordflow">return</span> ~0;
00863 }
00864 
00865 <span class="keyword">static</span> <span class="keywordtype">int</span> http_backend_term(<span class="keyword">struct</span> backend_s *be)
00866 {
00867     http_t *http;
00868 
00869     dbg_return_if (be == NULL, 0);
00870     dbg_return_if (be-&gt;arg == NULL, 0);
00871 
00872     http = (http_t *) be-&gt;arg;
00873 
00874     dbg_err_if(session_module_term(http-&gt;sess_opt));
00875 
00876     http_free(http);
00877 
00878     <span class="keywordflow">return</span> 0;
00879 err:
00880     <span class="keywordflow">return</span> ~0;
00881 }
00882 
00883 <span class="keyword">static</span> <span class="keywordtype">int</span> http_backend_init(<span class="keyword">struct</span> backend_s *be)
00884 {
00885     http_t *http = NULL;
00886     broker_t *broker = NULL;
00887 
00888     dbg_err_if (be == NULL);
00889  
00890     dbg_err_if(http_create(be-&gt;config, &amp;http));
00891 
00892     be-&gt;arg = http;
00893 
00894     dbg_err_if(session_module_init(http-&gt;config, &amp;http-&gt;sess_opt));
00895 
00896     <span class="keywordflow">return</span> 0;
00897 err:
00898     <span class="keywordflow">if</span>(http)
00899         http_free(http);
00900     <span class="keywordflow">if</span>(broker)
00901         broker_free(broker);
00902     <span class="keywordflow">return</span> ~0;
00903 }
00904 
00905 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL</span>
00906 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> https_backend_init(<span class="keyword">struct</span> backend_s *be)
00907 {
00908     http_t *https;
00909 
00910     dbg_err_if (be == NULL);
00911 
00912     dbg_err_if(http_backend_init(be));
00913 
00914     https = (http_t *) be-&gt;arg;
00915 
00916     <span class="comment">/* turn on SSL encryption */</span>
00917     https-&gt;ssl = 1;
00918 
00919     <span class="comment">/* load config values and set SSL_CTX accordingly */</span>
00920     https-&gt;ssl_ctx = tls_load_init_ctx(http_get_config(https));
00921     warn_err_ifm (https-&gt;ssl_ctx == NULL, <span class="stringliteral">"bad or missing HTTPS credentials"</span>);
00922 
00923     dbg_err_if(session_module_init(https-&gt;config, &amp;https-&gt;sess_opt));
00924 
00925     <span class="keywordflow">return</span> 0;
00926 err:
00927     <span class="keywordflow">return</span> ~0;
00928 }
00929 
00930 <span class="keyword">static</span> <span class="keywordtype">int</span> https_backend_term(<span class="keyword">struct</span> backend_s *be)
00931 {
00932     http_t *https;
00933 
00934     dbg_err_if (be == NULL);
00935 
00936     https = (http_t *) be-&gt;arg;
00937     <span class="keywordflow">if</span> (https == NULL)
00938         <span class="keywordflow">return</span> 0;
00939 
00940     SSL_CTX_free(https-&gt;ssl_ctx);
00941 
00942     <span class="keywordflow">return</span> http_backend_term(be); 
00943 err:
00944     <span class="keywordflow">return</span> ~0;
00945 }
00946 
00947 <span class="comment">/* same http functions but different '_init' */</span>
00948 backend_t be_https =
00949     BACKEND_STATIC_INITIALIZER( <span class="stringliteral">"https"</span>, 
00950         https_backend_init, 
00951         http_backend_serve, 
00952         https_backend_term );
00953 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_LIBOPENSSL */</span>
00954 
00955 backend_t be_http =
00956     BACKEND_STATIC_INITIALIZER( <span class="stringliteral">"http"</span>, 
00957         http_backend_init, 
00958         http_backend_serve, 
00959         http_backend_term );
00960 
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


