<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LibU: hmap.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>hmap.c</h1><div class="fragment"><pre>00001 <span class="comment">/* </span>
00002 <span class="comment"> * Copyright (c) 2005-2008 by KoanLogic s.r.l. - All rights reserved.  </span>
00003 <span class="comment"> */</span>
00004 
00005 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00006 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00007 <span class="preprocessor">#include &lt;string.h&gt;</span>
00008 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00009 
00010 <span class="preprocessor">#include &lt;toolbox/memory.h&gt;</span>
00011 <span class="preprocessor">#include &lt;toolbox/carpal.h&gt;</span>
00012 <span class="preprocessor">#include &lt;toolbox/hmap.h&gt;</span>
00013 <span class="preprocessor">#include &lt;toolbox/misc.h&gt;</span>
00014 
00020 <span class="comment">/* default limits handled by policies */</span>
00021 <span class="preprocessor">#define U_HMAP_MAX_SIZE      512</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define U_HMAP_MAX_ELEMS     U_HMAP_MAX_SIZE</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#define U_HMAP_RATE_FULL     0.75</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#define U_HMAP_RATE_RESIZE   3</span>
00025 <span class="preprocessor"></span>
00026 
00027 <span class="comment">/* policy queue object */</span>
00028 <span class="keyword">struct </span>u_hmap_q_s 
00029 {
00030     <span class="keywordtype">void</span> *key,
00031          *o;
00032 
00033     TAILQ_ENTRY(u_hmap_q_s) next;
00034 };
00035 
00036 <span class="comment">/* hmap policy representation */</span>
00037 <span class="keyword">struct </span>u_hmap_pcy_s 
00038 {
00039     int (*pop)(u_hmap_t *hmap, u_hmap_o_t **obj); 
00040     int (*push)(u_hmap_t *hmap, u_hmap_o_t *obj,
00041             u_hmap_q_t **data); 
00042 
00043     <span class="keyword">enum</span> {
00044         U_HMAP_PCY_OP_PUT = 0x1,
00045         U_HMAP_PCY_OP_GET = 0x2
00046     } ops;
00047     
00048     TAILQ_HEAD(u_hmap_q_h_s, u_hmap_q_s) queue;
00049 };
00050 <span class="keyword">typedef</span> <span class="keyword">struct </span>u_hmap_q_h_s u_hmap_q_h_t;
00051 
00052 <span class="comment">/* hmap representation */</span>
00053 <span class="keyword">struct </span>u_hmap_s 
00054 {
00055     <a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *opts;        <span class="comment">/* hmap options */</span>
00056 
00057     size_t sz,                  <span class="comment">/* current size */</span>
00058            size,                <span class="comment">/* array size */</span>
00059            threshold,           <span class="comment">/* when to resize */</span>
00060            px;                  <span class="comment">/* index into prime numbers array */</span>
00061 
00062     u_hmap_pcy_t pcy;    <span class="comment">/* discard policy */</span>
00063 
00064     LIST_HEAD(u_hmap_e_s, u_hmap_o_s) *hmap;    <span class="comment">/* the hashmap */</span>
00065 };
00066 <span class="keyword">typedef</span> <span class="keyword">struct </span>u_hmap_e_s u_hmap_e_t;
00067 
00068 <span class="keyword">static</span> <span class="keywordtype">int</span> _get (u_hmap_t *hmap, <span class="keywordtype">void</span> *key, 
00069         u_hmap_o_t **o);
00070 
00071 <span class="keyword">static</span> <span class="keywordtype">int</span> _opts_check (<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *opts);
00072 <span class="keyword">static</span> <span class="keywordtype">int</span> _pcy_setup (u_hmap_t *hmap);
00073 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *_pcy2str(u_hmap_pcy_type_t policy);
00074 
00075 <span class="keyword">static</span> <span class="keywordtype">void</span> _o_free (u_hmap_t *hmap, u_hmap_o_t *obj);
00076 
00077 <span class="keyword">static</span> u_hmap_q_t *_q_o_new (<span class="keywordtype">void</span> *key);
00078 <span class="keyword">static</span> <span class="keywordtype">void</span> _q_o_free (u_hmap_q_t *s);
00079 
00080 <span class="keyword">static</span> size_t _f_hash (<span class="keywordtype">void</span> *key, size_t size);
00081 <span class="keyword">static</span> <span class="keywordtype">int</span> _f_comp (<span class="keywordtype">void</span> *k1, <span class="keywordtype">void</span> *k2);
00082 <span class="keyword">static</span> <span class="keywordtype">void</span> _f_free (u_hmap_o_t *obj);
00083 <span class="keyword">static</span> u_string_t *_f_str (u_hmap_o_t *obj);
00084 
00085 <span class="keyword">static</span> <span class="keywordtype">int</span> _queue_push (u_hmap_t *hmap, u_hmap_o_t *obj, 
00086         u_hmap_q_t **data);
00087 <span class="keyword">static</span> <span class="keywordtype">int</span> _queue_push_count (u_hmap_t *hmap, u_hmap_o_t *obj,
00088         u_hmap_q_t **counts);
00089 <span class="keyword">static</span> <span class="keywordtype">int</span> _queue_pop_front (u_hmap_t *hmap, u_hmap_o_t **obj);
00090 <span class="keyword">static</span> <span class="keywordtype">int</span> _queue_pop_back (u_hmap_t *hmap, u_hmap_o_t **obj);
00091 
00092 <span class="keyword">static</span> <span class="keywordtype">int</span> _resize(u_hmap_t *hmap);
00093 <span class="keyword">static</span> <span class="keywordtype">int</span> _next_prime(size_t *prime, size_t sz, size_t *idx);
00094 
00095 
<a name="l00103"></a><a class="code" href="group__hmap.html#ga19">00103</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__hmap.html#ga19">u_hmap_strerror</a> (u_hmap_ret_t rc)
00104 {
00105     <span class="keywordflow">switch</span> (rc)
00106     {
00107         <span class="keywordflow">case</span> U_HMAP_ERR_NONE:
00108             <span class="keywordflow">return</span> <span class="stringliteral">"success"</span>;
00109         <span class="keywordflow">case</span> U_HMAP_ERR_FAIL:
00110             <span class="keywordflow">return</span> <span class="stringliteral">"general failure"</span>;
00111         <span class="keywordflow">case</span> U_HMAP_ERR_EXISTS:
00112             <span class="keywordflow">return</span> <span class="stringliteral">"element already exists in table"</span>;
00113     }
00114     <span class="keywordflow">return</span> NULL;
00115 }
00116 
00117 <span class="comment">/* Default hash function */</span>
00118 <span class="keyword">static</span> size_t _f_hash (<span class="keywordtype">void</span> *key, size_t size)
00119 {
00120     size_t h = 0;
00121     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *k = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) key;
00122 
00123     dbg_ifb (key == NULL) <span class="keywordflow">return</span> -1;
00124 
00125     <span class="keywordflow">while</span> (*k)
00126     {
00127         h += *k++;
00128         h += (h &lt;&lt; 10);
00129         h ^= (h &gt;&gt; 6);
00130     }
00131 
00132     h += (h &lt;&lt; 3);
00133     h ^= (h &gt;&gt; 11);
00134 
00135     <span class="keywordflow">return</span> (h + (h &lt;&lt; 15)) % size;
00136 }
00137 
00138 <span class="comment">/* Default comparison function for key comparison */</span>
00139 <span class="keyword">static</span> <span class="keywordtype">int</span> _f_comp (<span class="keywordtype">void</span> *k1, <span class="keywordtype">void</span> *k2) 
00140 {
00141     dbg_ifb (k1 == NULL) <span class="keywordflow">return</span> -1;    
00142     dbg_ifb (k2 == NULL) <span class="keywordflow">return</span> -1;  
00143     
00144     <span class="keywordflow">return</span> strcmp((<span class="keywordtype">char</span> *)k1, (<span class="keywordtype">char</span> *)k2);
00145 }
00146 
00147 <span class="comment">/* Default function for freeing hmap objects  */</span>
00148 <span class="keyword">static</span> <span class="keywordtype">void</span> _f_free (u_hmap_o_t *obj)
00149 {
00150     dbg_ifb (obj == NULL) <span class="keywordflow">return</span>;
00151 
00152     <a class="code" href="group__alloc.html#ga8">u_free</a>(obj-&gt;key); 
00153     <a class="code" href="group__alloc.html#ga8">u_free</a>(obj-&gt;val); 
00154 }
00155 
00156 <span class="comment">/* Default string representation of objects */</span>
00157 <span class="keyword">static</span> u_string_t *_f_str (u_hmap_o_t *obj)
00158 {
00159     <span class="keyword">enum</span> { MAX_OBJ_STR = 256 };
00160     <span class="keywordtype">char</span> buf[MAX_OBJ_STR];
00161     u_string_t *s = NULL;
00162     <span class="keywordtype">char</span> *key,
00163          *val;
00164 
00165     dbg_err_if (obj == NULL);
00166 
00167     key = (<span class="keywordtype">char</span> *) obj-&gt;key,
00168     val = (<span class="keywordtype">char</span> *) obj-&gt;val;
00169 
00170     dbg_err_if (<a class="code" href="group__misc.html#ga12">u_snprintf</a>(buf, MAX_OBJ_STR, <span class="stringliteral">"[%s:%s]"</span>, key, val));    
00171     dbg_err_if (<a class="code" href="group__string.html#ga9">u_string_create</a>(buf, strlen(buf)+1, &amp;s));
00172 
00173     <span class="keywordflow">return</span> s;
00174 
00175 err:
00176     <span class="keywordflow">return</span> NULL;
00177 }
00178 
00179 <span class="comment">/* Check validity of options */</span>
00180 <span class="keyword">static</span> <span class="keywordtype">int</span> _opts_check (<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *opts)
00181 {
00182     dbg_err_if (opts == NULL);
00183 
00184     dbg_err_if (opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o0">size</a> == 0);
00185     dbg_err_if (opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o1">max</a> == 0);
00186     dbg_err_if (opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o2">type</a> != U_HMAP_TYPE_CHAIN &amp;&amp; 
00187             opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o2">type</a> != U_HMAP_TYPE_LINEAR);
00188     dbg_err_if (opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o3">policy</a> &lt; U_HMAP_PCY_NONE || 
00189             opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o3">policy</a> &gt; U_HMAP_PCY_LFU);
00190     dbg_err_if (opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o5">f_hash</a> == NULL);
00191     dbg_err_if (opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o6">f_comp</a> == NULL);
00192 
00193     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00194 
00195 err:
00196     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00197 }
00198 
00199 <span class="comment">/* Setup policy parameters */</span>
00200 <span class="keyword">static</span> <span class="keywordtype">int</span> _pcy_setup (u_hmap_t *hmap) 
00201 {
00202     dbg_return_if (hmap == NULL, ~0);
00203 
00204     <span class="keywordflow">switch</span> (hmap-&gt;opts-&gt;policy) 
00205     {
00206         <span class="keywordflow">case</span> U_HMAP_PCY_NONE:
00207             hmap-&gt;pcy.push = NULL;
00208             hmap-&gt;pcy.pop = NULL;
00209             hmap-&gt;pcy.ops = 0;
00210             <span class="keywordflow">break</span>;
00211         <span class="keywordflow">case</span> U_HMAP_PCY_LRU:
00212             hmap-&gt;pcy.push = _queue_push;
00213             hmap-&gt;pcy.pop = _queue_pop_back;
00214             hmap-&gt;pcy.ops = U_HMAP_PCY_OP_PUT | U_HMAP_PCY_OP_GET;
00215             <span class="keywordflow">break</span>;
00216         <span class="keywordflow">case</span> U_HMAP_PCY_FIFO:
00217             hmap-&gt;pcy.push = _queue_push;
00218             hmap-&gt;pcy.pop = _queue_pop_back;
00219             hmap-&gt;pcy.ops = U_HMAP_PCY_OP_PUT;
00220             <span class="keywordflow">break</span>;
00221         <span class="keywordflow">case</span> U_HMAP_PCY_LFU:
00222             hmap-&gt;pcy.push = _queue_push_count;
00223             hmap-&gt;pcy.pop = _queue_pop_front;
00224             hmap-&gt;pcy.ops = U_HMAP_PCY_OP_PUT | U_HMAP_PCY_OP_GET;
00225             <span class="keywordflow">break</span>;
00226         <span class="keywordflow">default</span>:
00227             dbg(<span class="stringliteral">"Invalid policy: %d"</span>, hmap-&gt;opts-&gt;policy);
00228             <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00229     }
00230 
00231     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00232 }
00233 
<a name="l00246"></a><a class="code" href="group__hmap.html#ga20">00246</a> <span class="keywordtype">int</span> <a class="code" href="group__hmap.html#ga20">u_hmap_new</a> (<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *opts, u_hmap_t **hmap)
00247 {
00248     size_t i;
00249     u_hmap_t *c = NULL;
00250 
00251     <span class="comment">/* allow (opts == NULL) */</span>
00252     dbg_return_if (hmap == NULL, ~0);
00253    
00254     dbg_return_sif ((c = (u_hmap_t *) <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(u_hmap_t))) == NULL, ~0);
00255     
00256     dbg_err_if (<a class="code" href="group__hmap.html#ga30">u_hmap_opts_new</a>(&amp;c-&gt;opts));
00257     <span class="keywordflow">if</span> (opts)
00258     {
00259         dbg_err_if (<a class="code" href="group__hmap.html#ga31">u_hmap_opts_copy</a>(c-&gt;opts, opts));
00260         dbg_err_if (_opts_check(c-&gt;opts));
00261     }
00262     <a class="code" href="group__hmap.html#ga34">u_hmap_opts_dbg</a>(c-&gt;opts);
00263     dbg_err_if (_pcy_setup(c));
00264 
00265     c-&gt;size = c-&gt;opts-&gt;size;
00266     dbg_err_if (_next_prime(&amp;c-&gt;size, c-&gt;size, &amp;c-&gt;px));
00267     c-&gt;threshold = U_HMAP_RATE_FULL * c-&gt;size;
00268 
00269     dbg_err_sif ((c-&gt;hmap = (u_hmap_e_t *) 
00270                 <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(u_hmap_e_t) * 
00271                     c-&gt;size)) == NULL);
00272 
00273     <span class="comment">/* initialise entries */</span>
00274     <span class="keywordflow">for</span> (i = 0; i &lt; c-&gt;size; ++i)
00275         LIST_INIT(&amp;c-&gt;hmap[i]);
00276 
00277     TAILQ_INIT(&amp;c-&gt;pcy.queue);
00278     
00279     dbg(<span class="stringliteral">"[hmap]"</span>);
00280     dbg(<span class="stringliteral">"threshold: %u"</span>, c-&gt;threshold);
00281 
00282     *hmap = c;
00283 
00284     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00285 
00286 err:
00287     <a class="code" href="group__alloc.html#ga8">u_free</a>(c);
00288     *hmap = NULL;    
00289     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00290 }
00291 
<a name="l00303"></a><a class="code" href="group__hmap.html#ga21">00303</a> <span class="keywordtype">int</span> <a class="code" href="group__hmap.html#ga21">u_hmap_copy</a> (u_hmap_t *to, u_hmap_t *from)
00304 {
00305     u_hmap_o_t *obj;
00306     size_t i;
00307     
00308     dbg_err_if (to == NULL);
00309     dbg_err_if (from == NULL);
00310 
00311     <span class="keywordflow">for</span> (i = 0; i &lt; from-&gt;size; ++i) 
00312     { 
00313         <span class="keywordflow">while</span> ((obj = LIST_FIRST(&amp;from-&gt;hmap[i])) != NULL) 
00314         {
00315             LIST_REMOVE(obj, next);
00316             dbg_err_if (<a class="code" href="group__hmap.html#ga25">u_hmap_put</a>(to, obj, NULL));
00317         }
00318     }
00319 
00320     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00321 
00322 err:
00323     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00324 }
00325 
<a name="l00333"></a><a class="code" href="group__hmap.html#ga22">00333</a> <span class="keywordtype">void</span> <a class="code" href="group__hmap.html#ga22">u_hmap_dbg</a> (u_hmap_t *hmap)
00334 {
00335     <span class="keyword">enum</span> { MAX_LINE = 255 };
00336     u_string_t *s = NULL, *st = NULL;
00337     u_hmap_o_t *obj;
00338     size_t i;
00339 
00340     dbg_ifb (hmap == NULL) <span class="keywordflow">return</span>;
00341 
00342     dbg (<span class="stringliteral">"&lt;hmap&gt;"</span>);
00343     <span class="keywordflow">for</span> (i = 0; i &lt; hmap-&gt;size; ++i) 
00344     {
00345         dbg_ifb (<a class="code" href="group__string.html#ga9">u_string_create</a>(<span class="stringliteral">""</span>, 1, &amp;s)) <span class="keywordflow">return</span>;
00346         dbg_err_if (<a class="code" href="group__string.html#ga8">u_string_clear</a>(s));
00347         dbg_err_if (<a class="code" href="group__string.html#ga14">u_string_append</a>(s, <span class="stringliteral">"|"</span>, 1));
00348 
00349         LIST_FOREACH(obj, &amp;hmap-&gt;hmap[i], next) 
00350         {
00351             <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;f_str == NULL) 
00352             {
00353                 dbg_err_if (<a class="code" href="group__string.html#ga14">u_string_append</a>(s, <span class="stringliteral">"[]"</span>, 2));
00354             } <span class="keywordflow">else</span> {
00355                 st = hmap-&gt;opts-&gt;f_str(obj);
00356                 dbg_err_if (<a class="code" href="group__string.html#ga14">u_string_append</a>(s, <a class="code" href="group__string.html#ga6">u_string_c</a>(st),
00357                             <a class="code" href="group__string.html#ga5">u_string_len</a>(st)-1));
00358                 <a class="code" href="group__string.html#ga10">u_string_free</a>(st);
00359             }
00360         } 
00361         dbg_err_if (<a class="code" href="group__string.html#ga14">u_string_append</a>(s, <span class="stringliteral">"|"</span>, 1));
00362         dbg(<a class="code" href="group__string.html#ga6">u_string_c</a>(s));
00363         dbg_ifb (<a class="code" href="group__string.html#ga10">u_string_free</a>(s)) <span class="keywordflow">return</span>;
00364     }
00365     dbg(<span class="stringliteral">"&lt;/hmap&gt;"</span>);
00366     <span class="keywordflow">return</span>;
00367 
00368 err:
00369     U_FREEF(st, <a class="code" href="group__string.html#ga9">u_string_free</a>);
00370     U_FREEF(s, <a class="code" href="group__string.html#ga9">u_string_free</a>);
00371     <span class="keywordflow">return</span>;   
00372 }
00373 
00374 <span class="comment">/*</span>
00375 <span class="comment"> * \brief   Delete an object from the hmap</span>
00376 <span class="comment"> * </span>
00377 <span class="comment"> * Delete object with given \a key from \a hmap and return it (if the object is</span>
00378 <span class="comment"> * owned by user).</span>
00379 <span class="comment"> * </span>
00380 <span class="comment"> * \param hmap      hmap object</span>
00381 <span class="comment"> * \param key       key of object to be deleted </span>
00382 <span class="comment"> * \param obj       deleted object</span>
00383 <span class="comment"> * </span>
00384 <span class="comment"> * \return U_HMAP_ERR_NONE on success, U_HMAP_ERR_FAIL on failure</span>
00385 <span class="comment"> */</span>
00386 <span class="keywordtype">int</span> u_hmap_del (u_hmap_t *hmap, <span class="keywordtype">void</span> *key, u_hmap_o_t **obj) 
00387 {
00388     u_hmap_o_t *o = NULL;
00389 
00390     dbg_err_if (hmap == NULL);
00391     dbg_err_if (key == NULL);
00392 
00393     <span class="keywordflow">if</span> (obj)
00394         *obj = NULL;
00395 
00396     <span class="keywordflow">if</span> (_get(hmap, key, &amp;o))
00397         <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00398 
00399     dbg_err_if (o == NULL);
00400     LIST_REMOVE(o, next);
00401 
00402     <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_OWNSDATA)
00403         _o_free(hmap, o);
00404     <span class="keywordflow">else</span>
00405         <span class="keywordflow">if</span> (obj)
00406             *obj = o;
00407 
00408     hmap-&gt;sz--;
00409 
00410     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00411     
00412 err:
00413     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00414 }
00415 
00416 <span class="comment">/* Retrieve an hmap element given a key */</span>
00417 <span class="keyword">static</span> <span class="keywordtype">int</span> _get (u_hmap_t *hmap, <span class="keywordtype">void</span> *key, 
00418                        u_hmap_o_t **o)
00419 {
00420     u_hmap_o_t *obj;
00421     u_hmap_e_t *x;
00422     <span class="keywordtype">int</span> comp;
00423         size_t hash;
00424 
00425     dbg_err_if (hmap == NULL);
00426     dbg_err_if (key == NULL);
00427     dbg_err_if (o == NULL);
00428 
00429         hash = hmap-&gt;opts-&gt;f_hash(key, hmap-&gt;size);
00430 
00431         <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;f_hash != &amp;_f_hash &amp;&amp; 
00432                         !(hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_HASH_STRONG)) {
00433                 <span class="keyword">enum</span> { MAX_INT = 20 };
00434                 <span class="keywordtype">char</span> h[MAX_INT];
00435 
00436                 <a class="code" href="group__misc.html#ga12">u_snprintf</a>(h, MAX_INT, <span class="stringliteral">"%u"</span>, hash);
00437                 hash = _f_hash(h, hmap-&gt;size);
00438         }
00439 
00440         x = &amp;hmap-&gt;hmap[hash];
00441 
00442     <span class="keywordflow">switch</span> (hmap-&gt;opts-&gt;type)
00443     {
00444         <span class="keywordflow">case</span> U_HMAP_TYPE_CHAIN:
00445 
00446             LIST_FOREACH(obj, x, next) 
00447             {
00448                 <span class="keywordflow">if</span> ((comp = hmap-&gt;opts-&gt;f_comp(key, obj-&gt;key)) == 0) 
00449                 { <span class="comment">/* object found */</span> 
00450                     *o = obj;
00451                     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00452                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (comp &lt; 0) { <span class="comment">/* cannot be in list (ordered) */</span>
00453                     *o = NULL;
00454                     <span class="keywordflow">break</span>;
00455                 }
00456             }
00457             <span class="keywordflow">break</span>;
00458 
00459 
00460         <span class="keywordflow">case</span> U_HMAP_TYPE_LINEAR:
00461             {
00462                 size_t last = ((hash + hmap-&gt;size -1) % hmap-&gt;size);
00463 
00464                 <span class="keywordflow">for</span> (; hash != last; hash = ((hash +1) % hmap-&gt;size), 
00465                         x = &amp;hmap-&gt;hmap[hash])
00466                 {
00467                     <span class="keywordflow">if</span> (!LIST_EMPTY(x)) 
00468                     {
00469                         obj = LIST_FIRST(x);
00470                         
00471                         <span class="keywordflow">if</span> ((hmap-&gt;opts-&gt;f_comp(key, obj-&gt;key)) == 0)
00472                         {
00473                             *o = obj;
00474                             <span class="keywordflow">return</span> U_HMAP_ERR_NONE; 
00475                         }
00476                     }
00477                 }
00478             }
00479 
00480             <span class="keywordflow">break</span>;
00481     }
00482 
00483 err: 
00484     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00485 }
00486 
<a name="l00494"></a><a class="code" href="group__hmap.html#ga24">00494</a> <span class="keywordtype">void</span> <a class="code" href="group__hmap.html#ga24">u_hmap_pcy_dbg</a> (u_hmap_t *hmap)
00495 {
00496     u_hmap_q_t *data;
00497     u_string_t *s = NULL;
00498 
00499     dbg_ifb (hmap == NULL) <span class="keywordflow">return</span>;
00500 
00501     dbg_ifb (<a class="code" href="group__string.html#ga9">u_string_create</a>(<span class="stringliteral">""</span>, 1, &amp;s)) <span class="keywordflow">return</span>;
00502     dbg_err_if (<a class="code" href="group__string.html#ga8">u_string_clear</a>(s));
00503     dbg_err_if (<a class="code" href="group__string.html#ga14">u_string_append</a>(s, <span class="stringliteral">"Policy: ["</span>, strlen(<span class="stringliteral">"Policy: ["</span>)));
00504 
00505     TAILQ_FOREACH(data, &amp;hmap-&gt;pcy.queue, next) 
00506     {
00507         dbg_err_if (<a class="code" href="group__string.html#ga14">u_string_append</a>(s, <span class="stringliteral">"("</span>, 1));
00508         dbg_err_if (<a class="code" href="group__string.html#ga14">u_string_append</a>(s, data-&gt;key, strlen(data-&gt;key)));
00509         dbg_err_if (<a class="code" href="group__string.html#ga14">u_string_append</a>(s, <span class="stringliteral">")"</span>, 1));
00510     }
00511     dbg_err_if (<a class="code" href="group__string.html#ga14">u_string_append</a>(s, <span class="stringliteral">"]"</span>, 1));
00512     dbg(<a class="code" href="group__string.html#ga6">u_string_c</a>(s));
00513     dbg_if (<a class="code" href="group__string.html#ga10">u_string_free</a>(s));
00514 
00515     <span class="keywordflow">return</span>;
00516     
00517  err:
00518     U_FREEF(s, <a class="code" href="group__string.html#ga9">u_string_free</a>);
00519     <span class="keywordflow">return</span>;
00520 }
00521 
00522 <span class="comment">/* pop the front of an object queue */</span>
00523 <span class="keyword">static</span> <span class="keywordtype">int</span> _queue_pop_front (u_hmap_t *hmap, u_hmap_o_t **obj)
00524 {
00525     u_hmap_q_t *first;
00526 
00527     dbg_err_if (hmap == NULL);
00528 
00529     dbg_err_if ((first = TAILQ_FIRST(&amp;hmap-&gt;pcy.queue)) == NULL);
00530     dbg_err_if (u_hmap_del(hmap, first-&gt;key, obj));
00531     TAILQ_REMOVE(&amp;hmap-&gt;pcy.queue, first, next);
00532     _q_o_free(first);
00533 
00534     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00535 
00536 err:
00537     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00538 }
00539 
00540 <span class="comment">/* pop the back of an object queue */</span>
00541 <span class="keyword">static</span> <span class="keywordtype">int</span> _queue_pop_back (u_hmap_t *hmap, u_hmap_o_t **obj)
00542 {
00543     u_hmap_q_t *last;
00544 
00545     dbg_err_if (hmap == NULL);
00546 
00547     dbg_err_if ((last = TAILQ_LAST(&amp;hmap-&gt;pcy.queue, u_hmap_q_h_s))
00548             == NULL);
00549     dbg_err_if (u_hmap_del(hmap, last-&gt;key, obj));
00550     TAILQ_REMOVE(&amp;hmap-&gt;pcy.queue, last, next);
00551     _q_o_free(last);
00552     
00553     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00554 
00555 err: 
00556     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00557 }
00558 
00559 <span class="comment">/* push object data onto queue */</span>
00560 <span class="keyword">static</span> <span class="keywordtype">int</span> _queue_push (u_hmap_t *hmap, u_hmap_o_t *obj,
00561         u_hmap_q_t **data)
00562 {
00563     u_hmap_q_t *<span class="keyword">new</span>;
00564 
00565     dbg_err_if (hmap == NULL);
00566     dbg_err_if (obj == NULL);
00567     dbg_err_if (data == NULL);
00568 
00569     <span class="keywordflow">if</span> (*data == NULL) 
00570     {  <span class="comment">/* no reference to queue entry */</span>
00571         dbg_err_if ((<span class="keyword">new</span> = _q_o_new(obj-&gt;key)) == NULL);
00572         TAILQ_INSERT_HEAD(&amp;hmap-&gt;pcy.queue, <span class="keyword">new</span>, next);
00573         *data = <span class="keyword">new</span>;
00574     } <span class="keywordflow">else</span> { <span class="comment">/* have element in queue - move to head */</span>
00575         TAILQ_REMOVE(&amp;hmap-&gt;pcy.queue, *data, next);
00576         TAILQ_INSERT_HEAD(&amp;hmap-&gt;pcy.queue, *data, next);
00577     }
00578     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00579     
00580 err:
00581     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00582 }
00583 
00584 <span class="comment">/* Increment count data object and push onto queue */</span>
00585 <span class="keyword">static</span> <span class="keywordtype">int</span> _queue_push_count (u_hmap_t *hmap, u_hmap_o_t *obj, 
00586         u_hmap_q_t **counts)
00587 {
00588     u_hmap_q_t *<span class="keyword">new</span>, *t;
00589     <span class="keywordtype">int</span> *count;
00590 
00591     dbg_err_if (hmap == NULL);
00592     dbg_err_if (obj == NULL);
00593     dbg_err_if (counts == NULL);
00594 
00595     <span class="keywordflow">if</span> (*counts == NULL) <span class="comment">/* no reference to queue entry */</span>
00596     {  
00597         dbg_err_if ((<span class="keyword">new</span> = _q_o_new(obj-&gt;key)) == NULL);
00598         TAILQ_INSERT_HEAD(&amp;hmap-&gt;pcy.queue, <span class="keyword">new</span>, next);
00599         *counts = TAILQ_FIRST(&amp;hmap-&gt;pcy.queue);
00600         dbg_err_sif ((count = (<span class="keywordtype">int</span> *) <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>))) == NULL);
00601         <span class="keyword">new</span>-&gt;o = (<span class="keywordtype">void</span> *) count;
00602         *counts = <span class="keyword">new</span>;
00603     } <span class="keywordflow">else</span> { <span class="comment">/* have element in queue - move to head */</span>
00604         count = (<span class="keywordtype">int</span> *) (*counts)-&gt;o;
00605         memset((<span class="keywordtype">void</span> *) count, (*count)++, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00606 
00607         <span class="keywordflow">if</span> ((t = TAILQ_NEXT(*counts, next))) 
00608         {
00609             <span class="keywordflow">for</span> (; t &amp;&amp; ((*count) &gt; *((<span class="keywordtype">int</span> *) t-&gt;o)); t = TAILQ_NEXT(t, next))
00610                 ;
00611             TAILQ_REMOVE(&amp;hmap-&gt;pcy.queue, *counts, next);
00612             <span class="keywordflow">if</span> (t)
00613                 TAILQ_INSERT_BEFORE(t, *counts, next);
00614             <span class="keywordflow">else</span>
00615                 TAILQ_INSERT_TAIL(&amp;hmap-&gt;pcy.queue, *counts, next);
00616         }
00617     }
00618     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00619     
00620 err:
00621     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00622 }
00623 
<a name="l00638"></a><a class="code" href="group__hmap.html#ga25">00638</a> <span class="keywordtype">int</span> <a class="code" href="group__hmap.html#ga25">u_hmap_put</a> (u_hmap_t *hmap, u_hmap_o_t *obj, u_hmap_o_t **old)
00639 {
00640     u_hmap_o_t *o;
00641     u_hmap_e_t *x;
00642     <span class="keywordtype">int</span> comp;
00643         size_t hash;
00644 
00645     dbg_err_if (hmap == NULL);
00646     dbg_err_if (obj == NULL);
00647 
00648     <span class="keywordflow">if</span> (old)
00649         *old = NULL;
00650 
00651     <span class="keywordflow">if</span> (hmap-&gt;sz &gt;= hmap-&gt;threshold) {
00652         dbg(<span class="stringliteral">"hmap full"</span>);
00653         <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;policy == U_HMAP_PCY_NONE) {
00654             dbg_err_if (_resize(hmap));
00655         } <span class="keywordflow">else</span> {
00656             dbg(<span class="stringliteral">"freeing according to policy %d"</span>, hmap-&gt;opts-&gt;policy);
00657             dbg_err_if (hmap-&gt;pcy.pop(hmap, old));
00658         }
00659     }
00660 
00661     hash = hmap-&gt;opts-&gt;f_hash(obj-&gt;key, hmap-&gt;size);
00662 
00663     <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;f_hash != &amp;_f_hash &amp;&amp;
00664             !(hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_HASH_STRONG)) {
00665         <span class="keyword">enum</span> { MAX_INT = 20 };
00666         <span class="keywordtype">char</span> h[MAX_INT];
00667 
00668         <a class="code" href="group__misc.html#ga12">u_snprintf</a>(h, MAX_INT, <span class="stringliteral">"%u"</span>, hash);
00669         hash = _f_hash(h, hmap-&gt;size);
00670     }
00671 
00672     <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;policy != U_HMAP_PCY_NONE &amp;&amp;
00673             hmap-&gt;sz &gt;= hmap-&gt;opts-&gt;max) 
00674     {
00675         dbg(<span class="stringliteral">"Cache full - freeing according to policy %d"</span>, hmap-&gt;opts-&gt;policy);
00676         hmap-&gt;pcy.pop(hmap, old);
00677     }
00678 
00679         x = &amp;hmap-&gt;hmap[hash];
00680 
00681     <span class="keywordflow">switch</span> (hmap-&gt;opts-&gt;type) 
00682     {
00683         <span class="keywordflow">case</span> U_HMAP_TYPE_CHAIN:
00684 
00685             <span class="keywordflow">if</span> (LIST_EMPTY(x))
00686             {
00687                 LIST_INSERT_HEAD(x, obj, next);
00688                 <span class="keywordflow">goto</span> end;
00689             } <span class="keywordflow">else</span> {
00690                 LIST_FOREACH(o, x, next) 
00691                 {
00692                     <span class="comment">/* object already hmapd */</span>
00693                     <span class="keywordflow">if</span> ((comp = hmap-&gt;opts-&gt;f_comp(obj-&gt;key, o-&gt;key)) == 0) 
00694                     { 
00695                         <span class="comment">/* overwrite */</span>
00696                         <span class="keywordflow">if</span> (!(hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_NO_OVERWRITE))
00697                         {
00698                             LIST_INSERT_AFTER(o, obj, next);
00699                             LIST_REMOVE(o, next);
00700                             hmap-&gt;sz--;
00701                             <span class="comment">/* XXX pop from policy queue */</span>
00702 
00703                             <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_OWNSDATA)
00704                                 _o_free(hmap, o);
00705                             <span class="keywordflow">else</span>
00706                                 <span class="keywordflow">if</span> (old)
00707                                     *old = o;
00708 
00709                             <span class="keywordflow">goto</span> end;
00710 
00711                         <span class="comment">/* don't overwrite */</span>
00712                         } <span class="keywordflow">else</span> {
00713 
00714                             <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_OWNSDATA)
00715                                 _o_free(hmap, obj);                          
00716                             <span class="keywordflow">else</span>
00717                                 <span class="keywordflow">if</span> (old) 
00718                                     *old = obj; 
00719                             
00720                             <span class="keywordflow">return</span> U_HMAP_ERR_EXISTS; 
00721                         }
00722                     } <span class="keywordflow">else</span> { 
00723                         <span class="keywordflow">if</span> (comp &lt; 0) 
00724                         {
00725                             LIST_INSERT_BEFORE(o, obj, next); 
00726                             <span class="keywordflow">goto</span> end;
00727                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!LIST_NEXT(o, next)) {
00728                             LIST_INSERT_AFTER(o, obj, next);
00729                             <span class="keywordflow">goto</span> end;
00730                         }
00731                     }
00732                 }
00733             }
00734             <span class="keywordflow">break</span>;
00735 
00736         <span class="keywordflow">case</span> U_HMAP_TYPE_LINEAR:
00737 
00738             {
00739                 size_t last = ((hash + hmap-&gt;size -1) % hmap-&gt;size);
00740 
00741                 <span class="keywordflow">for</span> (; hash != last; hash = ((hash+1) % hmap-&gt;size), 
00742                         x = &amp;hmap-&gt;hmap[hash])
00743                 {
00744                     <span class="keywordflow">if</span> (LIST_EMPTY(x)) 
00745                     {
00746                         LIST_INSERT_HEAD(x, obj, next);
00747                         <span class="keywordflow">goto</span> end;
00748 
00749                     } <span class="keywordflow">else</span> {
00750 
00751                         o = LIST_FIRST(x);
00752 
00753                         <span class="comment">/* object already hmapd */</span>
00754                         <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;f_comp(o-&gt;key, obj-&gt;key) == 0)
00755                         {
00756                             <span class="comment">/* overwrite */</span>
00757                             <span class="keywordflow">if</span> (!(hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_NO_OVERWRITE)) 
00758                             {
00759                                 LIST_INSERT_AFTER(o, obj, next);
00760                                 LIST_REMOVE(o, next);
00761                                 hmap-&gt;sz--;
00762                                 <span class="comment">/* XXX pop from policy queue */</span>
00763 
00764                                 <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_OWNSDATA)
00765                                     _o_free(hmap, obj);
00766                                 <span class="keywordflow">else</span> 
00767                                     <span class="keywordflow">if</span> (old)
00768                                         *old = obj;
00769 
00770                                 <span class="keywordflow">goto</span> end;
00771 
00772                             <span class="comment">/* don't overwrite */</span>
00773                             } <span class="keywordflow">else</span> {
00774 
00775                                 <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_OWNSDATA)
00776                                     _o_free(hmap, obj);
00777                                 <span class="keywordflow">else</span> 
00778                                     <span class="keywordflow">if</span> (old)
00779                                         *old = obj;
00780 
00781                                 <span class="keywordflow">return</span> U_HMAP_ERR_EXISTS;
00782                             }
00783                         }
00784                     }
00785                 }
00786             }
00787             <span class="keywordflow">break</span>;
00788     }
00789 
00790 err:
00791     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00792 
00793 end:
00794     hmap-&gt;sz++;
00795 
00796     <span class="keywordflow">if</span> (hmap-&gt;pcy.ops &amp; U_HMAP_PCY_OP_PUT)
00797         hmap-&gt;pcy.push(hmap, obj, &amp;obj-&gt;pqe);
00798 
00799     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00800 }
00801 
<a name="l00815"></a><a class="code" href="group__hmap.html#ga26">00815</a> <span class="keywordtype">int</span> <a class="code" href="group__hmap.html#ga26">u_hmap_get</a> (u_hmap_t *hmap, <span class="keywordtype">void</span> *key, u_hmap_o_t **obj) 
00816 {
00817     dbg_err_if (hmap == NULL);
00818     dbg_err_if (key == NULL);
00819     dbg_err_if (obj == NULL);
00820 
00821     <span class="keywordflow">if</span> (_get(hmap, key, obj)) 
00822     {
00823         *obj = NULL;
00824         <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00825     }
00826     dbg_err_if (obj == NULL);
00827 
00828     <span class="keywordflow">if</span> (hmap-&gt;pcy.ops &amp; U_HMAP_PCY_OP_GET)
00829         hmap-&gt;pcy.push(hmap, *obj, &amp;(*obj)-&gt;pqe);
00830         
00831     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00832 
00833 err:
00834     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00835 }
00836 
<a name="l00848"></a><a class="code" href="group__hmap.html#ga27">00848</a> <span class="keywordtype">int</span> <a class="code" href="group__hmap.html#ga27">u_hmap_foreach</a> (u_hmap_t *hmap, <span class="keywordtype">int</span> f(<span class="keywordtype">void</span> *val))
00849 {
00850     u_hmap_o_t *obj;
00851     size_t i;
00852 
00853     dbg_err_if (hmap == NULL);
00854     dbg_err_if (f == NULL);
00855 
00856     <span class="keywordflow">for</span> (i = 0; i &lt; hmap-&gt;size; ++i) 
00857     { 
00858         LIST_FOREACH(obj, &amp;hmap-&gt;hmap[i], next)
00859             dbg_err_if (f(obj-&gt;val));
00860     }
00861 
00862     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00863 
00864 err:
00865     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00866 }
00867 
<a name="l00879"></a><a class="code" href="group__hmap.html#ga28">00879</a> <span class="keywordtype">int</span> <a class="code" href="group__hmap.html#ga28">u_hmap_foreach_keyval</a>(u_hmap_t *hmap, <span class="keywordtype">int</span> f(<span class="keywordtype">void</span> *key, <span class="keywordtype">void</span> *val))
00880 {
00881     <span class="keyword">struct </span>u_hmap_o_s *obj;
00882     size_t i;
00883 
00884     dbg_err_if (hmap == NULL);
00885     dbg_err_if (f == NULL);
00886 
00887     <span class="keywordflow">for</span> (i = 0; i &lt; hmap-&gt;size; ++i) 
00888     {
00889         LIST_FOREACH(obj, &amp;hmap-&gt;hmap[i], next)
00890                 dbg_err_if (f(obj-&gt;key,obj-&gt;val));
00891     }
00892 
00893     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00894 err:
00895     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00896 }
00897 
00898 
<a name="l00908"></a><a class="code" href="group__hmap.html#ga29">00908</a> <span class="keywordtype">void</span> <a class="code" href="group__hmap.html#ga29">u_hmap_free</a> (u_hmap_t *hmap)
00909 {
00910     u_hmap_o_t *obj;
00911     u_hmap_q_t *data;
00912     size_t i;
00913 
00914     dbg_ifb (hmap == NULL) <span class="keywordflow">return</span>;
00915 
00916     <span class="comment">/* free the hashhmap */</span>
00917     <span class="keywordflow">for</span> (i = 0; i &lt; hmap-&gt;size; ++i) 
00918     {
00919         <span class="keywordflow">while</span> ((obj = LIST_FIRST(&amp;hmap-&gt;hmap[i])) != NULL) 
00920         {
00921             LIST_REMOVE(obj, next);
00922             _o_free(hmap, obj);
00923         }
00924     }
00925 
00926     <a class="code" href="group__alloc.html#ga8">u_free</a>(hmap-&gt;hmap);
00927 
00928     <span class="comment">/* free the policy queue */</span>
00929     <span class="keywordflow">while</span> ((data = TAILQ_FIRST(&amp;hmap-&gt;pcy.queue)) != NULL) 
00930     {
00931         TAILQ_REMOVE(&amp;hmap-&gt;pcy.queue, data, next);
00932         _q_o_free(data);
00933     }
00934 
00935     <a class="code" href="group__alloc.html#ga8">u_free</a>(hmap-&gt;opts);
00936     <a class="code" href="group__alloc.html#ga8">u_free</a>(hmap);
00937 
00938     <span class="keywordflow">return</span>;
00939 }
00940 
<a name="l00952"></a><a class="code" href="group__hmap.html#ga30">00952</a> <span class="keywordtype">int</span> <a class="code" href="group__hmap.html#ga30">u_hmap_opts_new</a> (<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> **opts)
00953 {
00954     <a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *o;
00955 
00956     dbg_err_if (opts == NULL);
00957 
00958     dbg_err_sif ((o = (<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *) <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(u_hmap_opts_t))) 
00959             == NULL);
00960     
00961     <a class="code" href="group__hmap.html#ga32">u_hmap_opts_init</a>(o);
00962 
00963     *opts = o;
00964     
00965     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00966 err:
00967     *opts = NULL;
00968     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00969 }
00970 
<a name="l00981"></a><a class="code" href="group__hmap.html#ga31">00981</a> <span class="keywordtype">int</span> <a class="code" href="group__hmap.html#ga31">u_hmap_opts_copy</a> (<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *to, <a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *from)
00982 {
00983     dbg_err_if (to == NULL);
00984     dbg_err_if (from == NULL);
00985 
00986     memcpy(to, from, <span class="keyword">sizeof</span>(<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a>));
00987 
00988     <span class="keywordflow">return</span> U_HMAP_ERR_NONE;
00989         
00990 err:
00991     <span class="keywordflow">return</span> U_HMAP_ERR_FAIL;
00992 }
00993 
<a name="l01001"></a><a class="code" href="group__hmap.html#ga32">01001</a> <span class="keywordtype">void</span> <a class="code" href="group__hmap.html#ga32">u_hmap_opts_init</a> (<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *opts)
01002 {
01003     dbg_ifb (opts == NULL) <span class="keywordflow">return</span>;
01004 
01005     opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o0">size</a> = U_HMAP_MAX_SIZE;
01006     opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o2">type</a> = U_HMAP_TYPE_CHAIN;
01007     opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o1">max</a> = U_HMAP_MAX_ELEMS;
01008     opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o3">policy</a> = U_HMAP_PCY_NONE;
01009     opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o4">options</a> = 0;
01010     opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o5">f_hash</a> = &amp;_f_hash;
01011     opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o6">f_comp</a> = &amp;_f_comp;
01012     opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o7">f_free</a> = &amp;_f_free;
01013     opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o8">f_str</a> = &amp;_f_str;
01014     
01015     <span class="keywordflow">return</span>;
01016 }
01017 
<a name="l01025"></a><a class="code" href="group__hmap.html#ga33">01025</a> <span class="keywordtype">void</span> <a class="code" href="group__hmap.html#ga33">u_hmap_opts_free</a> (<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *opts)
01026 {
01027     dbg_ifb (opts == NULL) <span class="keywordflow">return</span>;
01028 
01029     <a class="code" href="group__alloc.html#ga8">u_free</a>(opts);
01030 }
01031 
<a name="l01039"></a><a class="code" href="group__hmap.html#ga34">01039</a> <span class="keywordtype">void</span> <a class="code" href="group__hmap.html#ga34">u_hmap_opts_dbg</a> (<a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *opts)
01040 {
01041     dbg_ifb (opts == NULL) <span class="keywordflow">return</span>;
01042 
01043     dbg(<span class="stringliteral">"[hmap options]"</span>);
01044     dbg(<span class="stringliteral">"size: %u"</span>, opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o0">size</a>);
01045     dbg(<span class="stringliteral">"max: %u"</span>, opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o1">max</a>);
01046     dbg(<span class="stringliteral">"policy: %s"</span>, _pcy2str(opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o3">policy</a>));
01047     dbg(<span class="stringliteral">"ownsdata: %d, &amp;f_free: %x"</span>, 
01048             (opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o4">options</a> &amp; U_HMAP_OPTS_OWNSDATA)&gt;0,
01049             &amp;opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o7">f_free</a>);
01050     dbg(<span class="stringliteral">"no_overwrite: %d"</span>, (opts-&gt;<a class="code" href="structu__hmap__opts__s.html#o4">options</a> &amp; U_HMAP_OPTS_NO_OVERWRITE)&gt;0);
01051 }
01052 
<a name="l01065"></a><a class="code" href="group__hmap.html#ga35">01065</a> u_hmap_o_t *<a class="code" href="group__hmap.html#ga35">u_hmap_o_new</a> (<span class="keywordtype">void</span> *key, <span class="keywordtype">void</span> *val)
01066 {
01067     u_hmap_o_t *obj = NULL;
01068 
01069     dbg_return_if (key == NULL, NULL);
01070     dbg_return_if (val == NULL, NULL);
01071 
01072     dbg_err_sif ((obj = (u_hmap_o_t *) 
01073                 <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(u_hmap_o_t))) == NULL);
01074     
01075     obj-&gt;key = key;
01076     obj-&gt;val = val;
01077     obj-&gt;pqe = NULL;
01078 
01079     <span class="keywordflow">return</span> obj;
01080  
01081 err:
01082     <a class="code" href="group__alloc.html#ga8">u_free</a>(obj);
01083     <span class="keywordflow">return</span> NULL;
01084 }
01085 
<a name="l01097"></a><a class="code" href="group__hmap.html#ga36">01097</a> <span class="keywordtype">void</span> <a class="code" href="group__hmap.html#ga36">u_hmap_o_free</a> (u_hmap_o_t *obj)
01098 {
01099     dbg_ifb (obj == NULL) <span class="keywordflow">return</span>;
01100 
01101     <a class="code" href="group__alloc.html#ga8">u_free</a>(obj);
01102 }
01103 
01108 <span class="comment">/* Free a data object including content if U_HMAP_OPTS_OWNSDATA */</span>
01109 <span class="keyword">static</span> <span class="keywordtype">void</span> _o_free (u_hmap_t *hmap, u_hmap_o_t *obj)
01110 {
01111     dbg_ifb (hmap == NULL) <span class="keywordflow">return</span>;
01112     dbg_ifb (obj == NULL) <span class="keywordflow">return</span>;
01113 
01114     <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;options &amp; U_HMAP_OPTS_OWNSDATA) 
01115     {
01116         <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;f_free)
01117             hmap-&gt;opts-&gt;f_free(obj);
01118     }
01119 
01120     <a class="code" href="group__hmap.html#ga36">u_hmap_o_free</a>(obj); 
01121 }
01122 
01123 <span class="comment">/* Allocate a new queue data object */</span>
01124 <span class="keyword">static</span> u_hmap_q_t *_q_o_new (<span class="keywordtype">void</span> *key)
01125 {
01126     u_hmap_q_t *data = NULL;
01127 
01128     dbg_return_if (key == NULL, NULL);
01129 
01130     dbg_err_sif ((data = (u_hmap_q_t *)
01131                 <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(u_hmap_q_t))) == NULL);
01132 
01133     data-&gt;key = key;
01134     data-&gt;o = NULL;
01135     
01136     <span class="keywordflow">return</span> data;
01137 
01138 err:
01139     <a class="code" href="group__alloc.html#ga8">u_free</a>(data);
01140     <span class="keywordflow">return</span> NULL;
01141 }
01142 
01143 <span class="comment">/* Free a data queue object */</span>
01144 <span class="keyword">static</span> <span class="keywordtype">void</span> _q_o_free (u_hmap_q_t *data)
01145 {
01146     dbg_ifb (data == NULL) <span class="keywordflow">return</span>;
01147 
01148     <a class="code" href="group__alloc.html#ga8">u_free</a>(data-&gt;o);
01149     <a class="code" href="group__alloc.html#ga8">u_free</a>(data);
01150 }
01151 
01152 <span class="comment">/* Get a string representation of a policy */</span>
01153 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *_pcy2str (u_hmap_pcy_type_t policy)
01154 {
01155     <span class="keywordflow">switch</span> (policy)
01156     {
01157         <span class="keywordflow">case</span> U_HMAP_PCY_NONE:
01158             <span class="keywordflow">return</span> <span class="stringliteral">"none"</span>;
01159         <span class="keywordflow">case</span> U_HMAP_PCY_FIFO:
01160             <span class="keywordflow">return</span> <span class="stringliteral">"fifo"</span>;
01161         <span class="keywordflow">case</span> U_HMAP_PCY_LRU:
01162             <span class="keywordflow">return</span> <span class="stringliteral">"fifo"</span>;
01163         <span class="keywordflow">case</span> U_HMAP_PCY_LFU:
01164             <span class="keywordflow">return</span> <span class="stringliteral">"lfu"</span>;
01165     }
01166     <span class="keywordflow">return</span> NULL;
01167 }
01168 
01169 <span class="keyword">static</span> <span class="keywordtype">int</span> _next_prime(size_t *prime, size_t sz, size_t *idx) 
01170 {
01171     <span class="keyword">static</span> size_t primes[] = {
01172         13, 19, 29, 41, 59, 79, 107, 149, 197, 263, 347, 457, 599, 787, 1031,
01173         1361, 1777, 2333, 3037, 3967, 5167, 6719, 8737, 11369, 14783, 19219,
01174         24989, 32491, 42257, 54941, 71429, 92861, 120721, 156941, 204047,
01175         265271, 344857, 448321, 582821, 757693, 985003, 1280519, 1664681,
01176         2164111, 2813353, 3657361, 4754591, 6180989, 8035301, 10445899,
01177         13579681, 17653589, 22949669, 29834603, 38784989, 50420551, 65546729,
01178         85210757, 110774011, 144006217, 187208107, 243370577, 316381771,
01179         411296309, 534685237, 695090819, 903618083, 1174703521, 1527114613,
01180         1837299131, 2147483647
01181     };
01182 
01183     size_t i;
01184 
01185     dbg_err_if (prime == NULL);
01186     dbg_err_if (sz == 0);
01187     dbg_err_if (idx == NULL);
01188     
01189     <span class="keywordflow">for</span> (i = *idx; i &lt; <span class="keyword">sizeof</span>(primes)/<span class="keyword">sizeof</span>(size_t); ++i) {
01190         <span class="keywordflow">if</span> (primes[i] &gt;= sz) {
01191             *idx = i;
01192             *prime = primes[i];
01193             <span class="keywordflow">goto</span> ok;
01194         }
01195     }
01196     dbg_err_ifm (1, <span class="stringliteral">"hmap size limit exceeded"</span>); 
01197 
01198 ok:
01199     <span class="keywordflow">return</span> 0;
01200 
01201 err:    
01202     <span class="keywordflow">return</span> ~0;    
01203 }
01204 
01205 <span class="keyword">static</span> <span class="keywordtype">int</span> _resize(u_hmap_t *hmap)
01206 {
01207     <a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> *newopts = NULL;
01208     u_hmap_t *newmap = NULL;
01209 
01210     dbg_err_if (hmap == NULL);
01211 
01212     <span class="keywordflow">if</span> (hmap-&gt;opts-&gt;policy != U_HMAP_PCY_NONE)
01213         <span class="keywordflow">return</span> 0;
01214 
01215     dbg(<span class="stringliteral">"resize from: %u"</span>, hmap-&gt;size);
01216     
01217     <span class="comment">/* copy old options */</span>
01218     dbg_err_if (<a class="code" href="group__hmap.html#ga30">u_hmap_opts_new</a>(&amp;newopts));
01219     dbg_err_if (<a class="code" href="group__hmap.html#ga31">u_hmap_opts_copy</a>(newopts, hmap-&gt;opts));
01220     
01221     <span class="comment">/* set rate and create the new hashmap */</span>
01222     dbg_err_if (_next_prime(&amp;newopts-&gt;<a class="code" href="structu__hmap__opts__s.html#o0">size</a>, 
01223             U_HMAP_RATE_RESIZE * newopts-&gt;<a class="code" href="structu__hmap__opts__s.html#o0">size</a>, 
01224             &amp;hmap-&gt;px));
01225     dbg_err_if (<a class="code" href="group__hmap.html#ga20">u_hmap_new</a>(newopts, &amp;newmap));
01226     <a class="code" href="group__hmap.html#ga33">u_hmap_opts_free</a>(newopts);
01227 
01228     <span class="comment">/* remove any ownership from old map to copy elements */</span>
01229     hmap-&gt;opts-&gt;options &amp;= !U_HMAP_OPTS_OWNSDATA;
01230     
01231     <span class="comment">/* copy old elements to new map policy */</span>
01232     dbg_err_if (<a class="code" href="group__hmap.html#ga21">u_hmap_copy</a>(newmap, hmap));
01233 
01234     <span class="comment">/* free old allocated objects */</span>
01235     <a class="code" href="group__hmap.html#ga33">u_hmap_opts_free</a>(hmap-&gt;opts);
01236     <a class="code" href="group__alloc.html#ga8">u_free</a>(hmap-&gt;hmap);
01237 
01238     <span class="comment">/* copy new map to this hmap */</span>
01239     memcpy(hmap, newmap, <span class="keyword">sizeof</span>(u_hmap_t));
01240     <a class="code" href="group__alloc.html#ga8">u_free</a>(newmap);
01241 
01242     dbg(<span class="stringliteral">"resized to: %u"</span>, hmap-&gt;size);
01243 
01244     <span class="keywordflow">return</span> 0;
01245 
01246 err:
01247     <span class="keywordflow">return</span> ~0;
01248 }
01249 
</pre></div><hr>
<div>
  <div style="text-align:left">
    <a href="http://www.koanlogic.com/kl/cont/gb/html/products.html">&larr;Products</a>
  </div>
  <div style="text-align:center;">
    &copy; 2005-2008 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
  </div>
</div>

</body>
</html>
