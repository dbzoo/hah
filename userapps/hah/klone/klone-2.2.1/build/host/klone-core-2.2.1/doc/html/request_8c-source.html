<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: request.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>request.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: request.c,v 1.66 2009/05/29 10:26:00 tho Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00013 <span class="preprocessor">#include &lt;string.h&gt;</span>
00014 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00015 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00016 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00017 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00018 <span class="preprocessor">#include &lt;klone/request.h&gt;</span>
00019 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00020 <span class="preprocessor">#include &lt;klone/io.h&gt;</span>
00021 <span class="preprocessor">#include &lt;klone/ioprv.h&gt;</span>
00022 <span class="preprocessor">#include &lt;<a class="code" href="http_8h.html">klone/http.h</a>&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/addr.h&gt;</span>
00024 <span class="preprocessor">#include &lt;klone/vars.h&gt;</span>
00025 <span class="preprocessor">#include &lt;klone/timer.h&gt;</span>
00026 <span class="preprocessor">#include &lt;klone/vhost.h&gt;</span>
00027 <span class="preprocessor">#include &lt;klone/supplier.h&gt;</span>
00028 
00029 <span class="keyword">struct </span>request_s
00030 {
00031     http_t *http;               <span class="comment">/* http server handle                       */</span>
00032     header_t *header;           <span class="comment">/* input header                             */</span>
00033     io_t *io;                   <span class="comment">/* input io stream                          */</span>
00034     <span class="keywordtype">int</span> method;                 <span class="comment">/* get,post,etc.                            */</span>
00035     <span class="keywordtype">char</span> *cli_rq;               <span class="comment">/* verbatim client request line             */</span>
00036     <span class="keywordtype">char</span> *uri;                  <span class="comment">/* verbatim uri asked by the client         */</span>
00037     <span class="keywordtype">char</span> *protocol;             <span class="comment">/* proto/ver                                */</span>
00038     <span class="keywordtype">char</span> *path_info;            <span class="comment">/* extra info at the end of the path        */</span>
00039     <span class="keywordtype">char</span> *query;                <span class="comment">/* query string (data after '?')            */</span>
00040     <span class="keywordtype">char</span> *filename;             <span class="comment">/* path of the req resource                 */</span>
00041     <span class="keywordtype">char</span> *resolved_path_info;   <span class="comment">/* resolved path_info                       */</span>
00042     <span class="keywordtype">char</span> *resolved_filename;    <span class="comment">/* unaliased filename                       */</span>
00043     vars_t *args;               <span class="comment">/* mixed get/post args                      */</span>
00044     vars_t *args_get;           <span class="comment">/* get variables                            */</span>
00045     vars_t *args_post;          <span class="comment">/* post variables                           */</span>
00046     vars_t *cookies;            <span class="comment">/* cookies                                  */</span>
00047     vars_t *uploads;            <span class="comment">/* uploaded file list                       */</span>
00048     <span class="keywordtype">char</span> *content_type;         <span class="comment">/* type/subtype                             */</span>
00049     <span class="keywordtype">char</span> *content_encoding;     <span class="comment">/* 7bit/8bit/base64/qp, etc                 */</span>
00050         size_t content_length;      <span class="comment">/* content-length http header field         */</span>
00051     time_t if_modified_since;   <span class="comment">/* time_t IMS header                        */</span>
00052     kaddr_t local_addr, peer_addr; <span class="comment">/* local and perr address                 */</span>
00053     <span class="keywordtype">int</span> cgi;                    <span class="comment">/* if running in cgi mode                   */</span>
00054     size_t idle_timeout;        <span class="comment">/* max # of secs to wait for the request    */</span>
00055     size_t post_timeout;        <span class="comment">/* max # of secs for reading POSTed data    */</span>
00056     size_t post_maxsize;        <span class="comment">/* max # of POSTed bytes to accepts         */</span>
00057     <span class="keyword">const</span> <span class="keywordtype">char</span> *temp_dir;       <span class="comment">/* where temp files go                      */</span>
00058     vhost_t *vhost;             <span class="comment">/* cached vhost pointer                     */</span>
00059     size_t padding;
00060     <span class="comment">/* cached supplier info data */</span>
00061     supplier_t *si_sup;
00062     <span class="keywordtype">void</span> *si_handle;
00063     time_t si_mtime;
00064 };
00065 
00066 <span class="keyword">typedef</span> <span class="keyword">struct </span>upload_info_s    <span class="comment">/* uploaded file info struct         */</span>
00067 {
00068     <span class="keywordtype">char</span> mime_type[MIME_TYPE_BUFSZ];
00069     <span class="keywordtype">char</span> filename[U_FILENAME_MAX];
00070     size_t size;
00071 } upload_info_t;
00072 
00073 <span class="keyword">enum</span> { 
00074     REQUEST_DEFAULT_IDLE_TIMEOUT = 10,         <span class="comment">/* 10 secs */</span>
00075     REQUEST_DEFAULT_POST_TIMEOUT = 600,        <span class="comment">/* 10 mins */</span>
00076     REQUEST_DEFAULT_POST_MAXSIZE = 5*1024000,  <span class="comment">/* 5 MB    */</span>
00077 };
00078 
00079 
00080 <span class="preprocessor">#define REQUEST_SET_STRING_FIELD(lval, rval)        \</span>
00081 <span class="preprocessor">    do {                                            \</span>
00082 <span class="preprocessor">        U_FREE(lval);                               \</span>
00083 <span class="preprocessor">        if(rval)                                    \</span>
00084 <span class="preprocessor">        {                                           \</span>
00085 <span class="preprocessor">            lval = u_strdup(rval);                  \</span>
00086 <span class="preprocessor">            dbg_err_if(lval == NULL);               \</span>
00087 <span class="preprocessor">        }                                           \</span>
00088 <span class="preprocessor">    } while(0)</span>
00089 <span class="preprocessor"></span>
00090 
00091 <span class="keywordtype">int</span> request_is_encoding_accepted(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *encoding)
00092 {
00093     <span class="keywordtype">char</span> *pp, *tok, *src, *buf = NULL;
00094     <span class="keyword">const</span> <span class="keywordtype">char</span> *accept_encoding;
00095     <span class="keywordtype">int</span> rc = 0;
00096 
00097     dbg_err_if (rq == NULL);
00098     dbg_err_if (encoding == NULL);
00099     
00100     accept_encoding = header_get_field_value(rq-&gt;header, <span class="stringliteral">"Accept-Encoding"</span>);
00101     <span class="keywordflow">if</span>(accept_encoding)
00102     {
00103         <span class="comment">/* get a copy to work on */</span>
00104         buf = u_strdup(accept_encoding);
00105         dbg_err_if(buf == NULL);
00106 
00107         <span class="comment">/* foreach encoding pair... */</span>
00108         <span class="keywordflow">for</span>(src = buf; (tok = strtok_r(src, <span class="stringliteral">" ,"</span>, &amp;pp)) != NULL; src = NULL)
00109         {
00110             <span class="keywordflow">if</span>(strcasecmp(tok, encoding) == 0)
00111             {
00112                 rc++; <span class="comment">/* found */</span>
00113                 <span class="keywordflow">break</span>;
00114             }
00115         }
00116 
00117         U_FREE(buf);
00118     }
00119 
00120     <span class="keywordflow">return</span> rc;
00121 err:
00122     U_FREE(buf);
00123     <span class="keywordflow">return</span> 0;
00124 }
00125 
<a name="l00141"></a><a class="code" href="group__request.html#ga7">00141</a> io_t *<a class="code" href="group__request.html#ga7">request_io</a>(request_t *rq)
00142 {
00143     dbg_return_if (rq == NULL, NULL);
00144 
00145     <span class="keywordflow">return</span> rq-&gt;io;
00146 }
00147 
<a name="l00159"></a><a class="code" href="group__request.html#ga48">00159</a> vars_t *<a class="code" href="group__request.html#ga48">request_get_cookies</a>(request_t *rq)
00160 {
00161     dbg_return_if (rq == NULL, NULL);
00162 
00163     <span class="keywordflow">return</span> rq-&gt;cookies;
00164 }
00165 
<a name="l00177"></a><a class="code" href="group__request.html#ga49">00177</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga49">request_get_cookie</a>(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00178 {
00179     var_t *v;
00180 
00181     dbg_return_if (rq == NULL, NULL);
00182     dbg_return_if (name == NULL, NULL);
00183 
00184     v = vars_get(rq-&gt;cookies, name);
00185 
00186     <span class="keywordflow">return</span> v ? var_get_value(v): NULL;
00187 }
00188 
<a name="l00199"></a><a class="code" href="group__request.html#ga42">00199</a> vars_t *<a class="code" href="group__request.html#ga42">request_get_args</a>(request_t *rq)
00200 {
00201     dbg_return_if (rq == NULL, NULL);
00202 
00203     <span class="keywordflow">return</span> rq-&gt;args;
00204 }
00205 
<a name="l00216"></a><a class="code" href="group__request.html#ga44">00216</a> vars_t *<a class="code" href="group__request.html#ga44">request_get_getargs</a>(request_t *rq)
00217 {
00218     dbg_return_if (rq == NULL, NULL);
00219 
00220     <span class="keywordflow">return</span> rq-&gt;args_get;
00221 }
00222 
<a name="l00233"></a><a class="code" href="group__request.html#ga46">00233</a> vars_t *<a class="code" href="group__request.html#ga46">request_get_postargs</a>(request_t *rq)
00234 {
00235     dbg_return_if (rq == NULL, NULL);
00236 
00237     <span class="keywordflow">return</span> rq-&gt;args_post;
00238 }
00239 
<a name="l00253"></a><a class="code" href="group__request.html#ga43">00253</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga43">request_get_arg</a>(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00254 {
00255     var_t *v;
00256 
00257     dbg_return_if (rq == NULL, NULL);
00258     dbg_return_if (name == NULL, NULL);
00259 
00260     v = vars_get(rq-&gt;args, name);
00261 
00262     <span class="keywordflow">return</span> v ? var_get_value(v): NULL;
00263 }
00264 
<a name="l00278"></a><a class="code" href="group__request.html#ga45">00278</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga45">request_get_getarg</a>(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00279 {
00280     var_t *v;
00281 
00282     dbg_return_if (rq == NULL, NULL);
00283     dbg_return_if (name == NULL, NULL);
00284 
00285     v = vars_get(rq-&gt;args_get, name);
00286 
00287     <span class="keywordflow">return</span> v ? var_get_value(v): NULL;
00288 }
00289 
<a name="l00303"></a><a class="code" href="group__request.html#ga47">00303</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga47">request_get_postarg</a>(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00304 {
00305     var_t *v;
00306 
00307     dbg_return_if (rq == NULL, NULL);
00308     dbg_return_if (name == NULL, NULL);
00309 
00310     v = vars_get(rq-&gt;args_post, name);
00311 
00312     <span class="keywordflow">return</span> v ? var_get_value(v): NULL;
00313 }
00314 
00315 <span class="keywordtype">int</span> request_set_field(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *value)
00316 {
00317     dbg_return_if (rq == NULL, ~0);
00318     dbg_return_if (name == NULL, ~0);
00319     dbg_return_if (value == NULL, ~0);
00320 
00321     <span class="keywordflow">return</span> header_set_field(rq-&gt;header, name, value);
00322 }
00323 
<a name="l00334"></a><a class="code" href="group__request.html#ga15">00334</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga15">request_get_uri</a>(request_t *rq)
00335 {
00336     dbg_return_if (rq == NULL, NULL);
00337 
00338     <span class="keywordflow">return</span> rq-&gt;uri;
00339 }
00340 
<a name="l00351"></a><a class="code" href="group__request.html#ga17">00351</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga17">request_get_filename</a>(request_t *rq)
00352 {
00353     dbg_return_if (rq == NULL, NULL);
00354 
00355     <span class="keywordflow">return</span> rq-&gt;filename;
00356 }
00357 
00358 <span class="comment">/*</span>
00359 <span class="comment"> * \ingroup request</span>
00360 <span class="comment"> * \brief   Set the filename field of a request</span>
00361 <span class="comment"> *</span>
00362 <span class="comment"> * Set the filename field of request \p rq to \p filename.</span>
00363 <span class="comment"> *</span>
00364 <span class="comment"> * \param rq        request object</span>
00365 <span class="comment"> * \param filename  filename string</span>
00366 <span class="comment"> *</span>
00367 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
00368 <span class="comment"> */</span>
00369 <span class="keywordtype">int</span> request_set_filename(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
00370 {
00371     dbg_err_if (rq == NULL);
00372     dbg_err_if (filename == NULL);
00373     
00374     REQUEST_SET_STRING_FIELD(rq-&gt;filename, filename);
00375 
00376     <span class="keywordflow">return</span> 0;
00377 err:
00378     <span class="keywordflow">return</span> ~0;
00379 }
00380 
<a name="l00391"></a><a class="code" href="group__request.html#ga19">00391</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga19">request_get_query_string</a>(request_t *rq)
00392 {
00393     dbg_return_if (rq == NULL, NULL);
00394 
00395     <span class="keywordflow">return</span> rq-&gt;query;
00396 }
00397 
<a name="l00408"></a><a class="code" href="group__request.html#ga20">00408</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga20">request_get_path_info</a>(request_t *rq)
00409 {
00410     dbg_return_if (rq == NULL, NULL);
00411 
00412     <span class="keywordflow">return</span> rq-&gt;path_info;
00413 }
00414 
00415 <span class="comment">/* parse and set if-modified-since value */</span>
00416 <span class="keyword">static</span> <span class="keywordtype">int</span> request_parse_ims(request_t *rq)
00417 {
00418     <span class="keyword">const</span> <span class="keywordtype">char</span> *ims;
00419 
00420     dbg_err_if (rq == NULL);
00421     
00422     rq-&gt;if_modified_since = 0;
00423 
00424     ims = header_get_field_value(rq-&gt;header, <span class="stringliteral">"If-Modified-Since"</span>);
00425     <span class="keywordflow">if</span>(ims)
00426         dbg_err_if(<a class="code" href="group__ut.html#ga51">u_httpdate_to_tt</a>(ims, &amp;rq-&gt;if_modified_since));
00427 
00428 err: <span class="comment">/* ignore if it's not formatted properly */</span>
00429     <span class="keywordflow">return</span> 0;
00430 }
00431 
<a name="l00442"></a><a class="code" href="group__request.html#ga24">00442</a> time_t <a class="code" href="group__request.html#ga24">request_get_if_modified_since</a>(request_t *rq)
00443 {
00444     dbg_return_if (rq == NULL, (time_t) -1);
00445 
00446     <span class="keywordflow">return</span> rq-&gt;if_modified_since;
00447 }
00448 
00449 <span class="comment">/*</span>
00450 <span class="comment"> * \ingroup request</span>
00451 <span class="comment"> * \brief   Set the resolved filename field of a request</span>
00452 <span class="comment"> *</span>
00453 <span class="comment"> * Set the resolved filename field of request \p rq to \p resolved_fn</span>
00454 <span class="comment"> *</span>
00455 <span class="comment"> * \param rq          request object</span>
00456 <span class="comment"> * \param resolved_fn resolved filename</span>
00457 <span class="comment"> *</span>
00458 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
00459 <span class="comment"> */</span>
00460 <span class="keywordtype">int</span> request_set_resolved_filename(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *resolved_fn)
00461 {
00462     dbg_err_if (rq == NULL);
00463     dbg_err_if (resolved_fn == NULL);
00464 
00465     REQUEST_SET_STRING_FIELD(rq-&gt;resolved_filename, resolved_fn);
00466 
00467     <span class="keywordflow">return</span> 0;
00468 err:
00469     <span class="keywordflow">return</span> ~0;
00470 }
00471 
<a name="l00482"></a><a class="code" href="group__request.html#ga8">00482</a> http_t* <a class="code" href="group__request.html#ga8">request_get_http</a>(request_t *rq)
00483 {
00484     dbg_return_if (rq == NULL, NULL);
00485 
00486     <span class="keywordflow">return</span> rq-&gt;http;
00487 }
00488 
00489 <span class="comment">/*</span>
00490 <span class="comment"> * \ingroup request</span>
00491 <span class="comment"> * \brief   Bind request I/O to a given I/O. </span>
00492 <span class="comment"> *  </span>
00493 <span class="comment"> * Bind the I/O of request \p rq to \p in.</span>
00494 <span class="comment"> *</span>
00495 <span class="comment"> * \param rq    request object</span>
00496 <span class="comment"> * \param in    input I/O object</span>
00497 <span class="comment"> *</span>
00498 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
00499 <span class="comment"> */</span>
00500 <span class="keywordtype">int</span> request_bind(request_t *rq, io_t *in)
00501 {
00502     dbg_return_if (rq == NULL, ~0);
00503     dbg_return_if (in == NULL, ~0);
00504 
00505     rq-&gt;io = in;
00506 
00507     <span class="keywordflow">return</span> 0;
00508 }
00509 
00510 <span class="comment">/*</span>
00511 <span class="comment"> * \ingroup request</span>
00512 <span class="comment"> * \brief   Set the query string of a request</span>
00513 <span class="comment"> *</span>
00514 <span class="comment"> * Parse \p query string and build the \p rq-&gt;args list.</span>
00515 <span class="comment"> *</span>
00516 <span class="comment"> * \param rq     request object</span>
00517 <span class="comment"> * \param query  query string </span>
00518 <span class="comment"> *</span>
00519 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
00520 <span class="comment"> */</span>
00521 <span class="keywordtype">int</span> request_set_query_string(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *query)
00522 {
00523     dbg_err_if (rq == NULL);
00524     dbg_err_if (query == NULL);
00525     
00526     REQUEST_SET_STRING_FIELD(rq-&gt;query, query);
00527 
00528     <span class="keywordflow">return</span> 0;
00529 err:
00530     <span class="keywordflow">return</span> ~0;
00531 }
00532 
00533 <span class="keywordtype">void</span> request_clear_uri(request_t *rq)
00534 {
00535     U_FREE(rq-&gt;uri);
00536     U_FREE(rq-&gt;protocol);
00537     U_FREE(rq-&gt;path_info);
00538     U_FREE(rq-&gt;query);
00539     U_FREE(rq-&gt;filename);
00540     U_FREE(rq-&gt;resolved_path_info);
00541     U_FREE(rq-&gt;resolved_filename);
00542     U_FREE(rq-&gt;content_type);
00543     U_FREE(rq-&gt;content_encoding);
00544 }
00545 
00546 <span class="comment">/*</span>
00547 <span class="comment"> * \ingroup request</span>
00548 <span class="comment"> * \brief   Set the path info field of a request</span>
00549 <span class="comment"> *</span>
00550 <span class="comment"> * Set the path info field of request \p rq to \p path_info.</span>
00551 <span class="comment"> *</span>
00552 <span class="comment"> * \param rq         request object</span>
00553 <span class="comment"> * \param path_info  path info</span>
00554 <span class="comment"> *</span>
00555 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
00556 <span class="comment"> */</span>
00557 <span class="keywordtype">int</span> request_set_path_info(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *path_info)
00558 {
00559     dbg_err_if (rq == NULL);
00560     dbg_err_if (path_info == NULL);
00561 
00562     REQUEST_SET_STRING_FIELD(rq-&gt;path_info, path_info);
00563 
00564     <span class="keywordflow">return</span> 0;
00565 err:
00566     <span class="keywordflow">return</span> ~0;
00567 }
00568 
00569 <span class="comment">/*</span>
00570 <span class="comment"> * \ingroup request</span>
00571 <span class="comment"> * \brief   Set the resolved path info field of a request</span>
00572 <span class="comment"> *</span>
00573 <span class="comment"> * Set the resolved path info field of request \p rq to \p resolved_pi.</span>
00574 <span class="comment"> *</span>
00575 <span class="comment"> * \param rq           request object</span>
00576 <span class="comment"> * \param resolved_pi  resolved path info</span>
00577 <span class="comment"> *</span>
00578 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
00579 <span class="comment"> */</span>
00580 <span class="keywordtype">int</span> request_set_resolved_path_info(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *resolved_pi)
00581 {
00582     dbg_err_if (rq == NULL);
00583     dbg_err_if (resolved_pi == NULL);
00584 
00585     REQUEST_SET_STRING_FIELD(rq-&gt;resolved_path_info, resolved_pi);
00586 
00587     <span class="keywordflow">return</span> 0;
00588 err:
00589     <span class="keywordflow">return</span> ~0;
00590 }
00591 
00592 <span class="comment">/*</span>
00593 <span class="comment"> * \ingroup request</span>
00594 <span class="comment"> * \brief   Set the URI field of a request</span>
00595 <span class="comment"> *</span>
00596 <span class="comment"> * Set the URI field of request \p rq to \p uri given </span>
00597 <span class="comment"> *</span>
00598 <span class="comment"> * \param rq           request object</span>
00599 <span class="comment"> * \param uri          URI string</span>
00600 <span class="comment"> * \param is_valid_uri URI validation function </span>
00601 <span class="comment"> * \param arg          argument to is_valid_uri</span>
00602 <span class="comment"> *</span>
00603 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
00604 <span class="comment"> */</span>
00605 <span class="keywordtype">int</span> request_set_uri(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *uri,
00606         <span class="keywordtype">int</span> (*is_valid_uri)(<span class="keywordtype">void</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span> *, size_t),
00607         <span class="keywordtype">void</span>* arg)
00608 {
00609     <span class="keywordtype">char</span> *p, *fn, *pi;
00610     size_t uri_len = strlen(uri);
00611     <span class="keywordtype">char</span> cp[4096];
00612 
00613     dbg_err_if (rq == NULL);
00614     dbg_err_if (uri == NULL);
00615     <span class="comment">/* is_valid_uri may be NULL */</span>
00616     <span class="comment">/* arg may be NULL */</span>
00617  
00618     request_clear_uri(rq);
00619 
00620     <span class="comment">/* this is just to avoid recursive infinite redirect loops for pages that </span>
00621 <span class="comment">       appends something to the URI and redirects to the same page */</span>
00622     warn_err_ifm(uri_len &gt;= <span class="keyword">sizeof</span>(cp), <span class="stringliteral">"Request URI too long"</span>);
00623 
00624     REQUEST_SET_STRING_FIELD(rq-&gt;uri, uri);
00625 
00626     <span class="comment">/* save (undecoded) query string i.e. everything after '?' */</span>
00627     <span class="keywordflow">if</span>((p = strchr(uri, <span class="charliteral">'?'</span>)) != NULL)
00628         dbg_err_if(request_set_query_string(rq, ++p));
00629 
00630     <span class="comment">/* copy decoded url */</span>
00631     dbg_err_if(<a class="code" href="group__ut.html#ga30">u_urlncpy</a>(cp, rq-&gt;uri, uri_len, URLCPY_DECODE) &lt;= 0);
00632 
00633     <span class="keywordflow">if</span>((p = strchr(cp, <span class="charliteral">'?'</span>)) != NULL)
00634         *p++ = 0; <span class="comment">/* remove query string from the uri copy */</span>
00635 
00636     <span class="comment">/* normalize the URI (remove /../, /./, ecc) */</span>
00637     dbg_err_if(u_uri_normalize(cp));
00638 
00639     <span class="comment">/* set filename is case there's not path_info and/or file does not exists */</span>
00640     dbg_err_if(request_set_filename(rq, cp));
00641 
00642     <span class="comment">/* look for path_info */</span>
00643     fn = cp;                    <span class="comment">/* filename     */</span>
00644     pi = fn + strlen(fn);       <span class="comment">/* path_info    */</span>
00645     <span class="keywordflow">for</span>(;;)
00646     {
00647         <span class="keywordflow">if</span>(is_valid_uri == NULL || is_valid_uri(arg, fn, pi - fn))
00648         {
00649             dbg_err_if(request_set_filename(rq, fn));
00650             rq-&gt;filename[pi-fn] = 0; <span class="comment">/* trunc */</span>
00651             <span class="keywordflow">if</span>(strlen(pi))
00652                 dbg_err_if(request_set_path_info(rq, pi));
00653             <span class="keywordflow">break</span>;
00654         } <span class="keywordflow">else</span> {
00655             <span class="keywordflow">if</span>((p = <a class="code" href="group__ut.html#ga27">u_strnrchr</a>(fn, <span class="charliteral">'/'</span>, pi - fn)) == NULL)
00656                 <span class="keywordflow">break</span>; <span class="comment">/* file pointed by this uri does not exists */</span>
00657             pi = p; <span class="comment">/* try again */</span>
00658         }
00659     }
00660 
00661     <span class="keywordflow">return</span> 0;
00662 err:
00663     <span class="keywordflow">return</span> ~0;
00664 }
00665 
00666 <span class="keyword">static</span> <span class="keywordtype">int</span> request_set_proto(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *proto)
00667 {
00668     dbg_err_if (rq == NULL);
00669     dbg_err_if (proto == NULL);
00670 
00671     <span class="comment">/* be sure that the requested protocol is http */</span>
00672     <span class="keywordflow">if</span>(strncasecmp(proto, <span class="stringliteral">"http"</span>, 4))
00673         <span class="keywordflow">return</span> ~0; <span class="comment">/* unknown or unsupported protocol */</span>
00674 
00675     REQUEST_SET_STRING_FIELD(rq-&gt;protocol, proto);
00676 
00677     <span class="keywordflow">return</span> 0;
00678 err:
00679     <span class="keywordflow">return</span> ~0;
00680 }
00681 
00682 <span class="comment">/*</span>
00683 <span class="comment"> * \ingroup request</span>
00684 <span class="comment"> * \brief   Save client request</span>
00685 <span class="comment"> *</span>
00686 <span class="comment"> * Save client request line</span>
00687 <span class="comment"> *</span>
00688 <span class="comment"> * \param rq     request object</span>
00689 <span class="comment"> * \param ln     the request line</span>
00690 <span class="comment"> *</span>
00691 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
00692 <span class="comment"> */</span>
00693 <span class="keywordtype">int</span> request_set_client_request(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *ln)
00694 {
00695     <span class="keywordtype">char</span> *p;
00696     dbg_err_if(rq == NULL);
00697     dbg_err_if(ln == NULL);
00698 
00699     rq-&gt;cli_rq = u_strdup(ln);
00700     dbg_err_if(rq-&gt;cli_rq == NULL);
00701 
00702     <span class="comment">/* cut the trailing newline if any */</span>
00703     <span class="keywordflow">for</span>(p = rq-&gt;cli_rq; *p &amp;&amp; (*p != <span class="charliteral">'\r'</span> &amp;&amp; *p != <span class="charliteral">'\n'</span>); ++p)
00704         <span class="keywordflow">continue</span>;
00705     *p = 0;
00706 
00707     <span class="keywordflow">return</span> 0;
00708 err:
00709     <span class="keywordflow">return</span> ~0;
00710 }
00711 
<a name="l00722"></a><a class="code" href="group__request.html#ga14">00722</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga14">request_get_client_request</a>(request_t *rq)
00723 {
00724     <span class="keywordflow">return</span> rq-&gt;cli_rq;
00725 }
00726 
00727 <span class="comment">/*</span>
00728 <span class="comment"> * Set the \p method of request \p rq.  Refer to http.h for possible methods.</span>
00729 <span class="comment"> *</span>
00730 <span class="comment"> * \param rq     request object</span>
00731 <span class="comment"> * \param method the HTTP method </span>
00732 <span class="comment"> *</span>
00733 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
00734 <span class="comment"> */</span>
00735 <span class="keywordtype">int</span> request_set_method(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *method)
00736 {
00737     dbg_return_if (rq == NULL, ~0);
00738     dbg_return_if (method == NULL, ~0);
00739 
00740     <span class="keywordflow">if</span>(!strcasecmp(method, <span class="stringliteral">"get"</span>))
00741         rq-&gt;method = <a class="code" href="http_8h.html#a33a21">HM_GET</a>;
00742     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strcasecmp(method, <span class="stringliteral">"head"</span>))
00743         rq-&gt;method = <a class="code" href="http_8h.html#a33a22">HM_HEAD</a>;
00744     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strcasecmp(method, <span class="stringliteral">"post"</span>))
00745         rq-&gt;method = <a class="code" href="http_8h.html#a33a23">HM_POST</a>;
00746     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strcasecmp(method, <span class="stringliteral">"put"</span>))
00747         rq-&gt;method = <a class="code" href="http_8h.html#a33a24">HM_PUT</a>;
00748     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strcasecmp(method, <span class="stringliteral">"delete"</span>))
00749         rq-&gt;method = <a class="code" href="http_8h.html#a33a25">HM_DELETE</a>;
00750     <span class="keywordflow">else</span> {
00751         <span class="comment">/* put, delete, * */</span>
00752         rq-&gt;method = <a class="code" href="http_8h.html#a33a20">HM_UNKNOWN</a>;
00753         <span class="keywordflow">return</span> ~0; <span class="comment">/* unknown or unsupported method */</span>
00754     }
00755     
00756     <span class="keywordflow">return</span> 0;
00757 }
00758 
00759 <span class="keyword">static</span> <span class="keywordtype">int</span> request_set_content_length(request_t *rq)
00760 {
00761     <span class="keyword">const</span> <span class="keywordtype">char</span> *clen;
00762     size_t len;
00763 
00764     dbg_err_if (rq == NULL);
00765 
00766     clen = header_get_field_value(rq-&gt;header, <span class="stringliteral">"Content-Length"</span>);
00767     dbg_err_if(clen == NULL || (len = atoi(clen)) &lt; 0);
00768 
00769     rq-&gt;content_length = len;
00770 
00771     <span class="keywordflow">return</span> 0;
00772 err:
00773     <span class="keywordflow">return</span> ~0;
00774 }
00775 
00776 <span class="keyword">static</span> <span class="keywordtype">int</span> request_parse_cookie(request_t *rq, field_t *field)
00777 {
00778     <span class="keyword">enum</span> { BUFSZ = 4096 }; <span class="comment">/* cookie size limit */</span>
00779     <span class="keywordtype">char</span> *pp, *tok, *src, buf[BUFSZ];
00780 
00781     dbg_err_if (rq == NULL);
00782     dbg_err_if (field == NULL);
00783     
00784     dbg_err_if(field_get_value(field) == NULL);
00785 
00786     <span class="comment">/* save a copy to tokenize it */</span>
00787     strncpy(buf, field_get_value(field), BUFSZ);
00788 
00789     <span class="comment">/* foreach name=value pair... */</span>
00790     <span class="keywordflow">for</span>(src = buf; (tok = strtok_r(src, <span class="stringliteral">" ;"</span>, &amp;pp)) != NULL; src = NULL)
00791         dbg_if(vars_add_urlvar(rq-&gt;cookies, tok, NULL));
00792 
00793     <span class="keywordflow">return</span> 0;
00794 err:
00795     <span class="keywordflow">return</span> ~0;
00796 }
00797 
00798 <span class="keyword">static</span> <span class="keywordtype">int</span> request_parse_cookies(request_t *rq)
00799 {
00800     field_t *f;
00801     size_t i, count;
00802 
00803     dbg_err_if (rq == NULL);
00804     
00805     count = header_field_count(rq-&gt;header);
00806     <span class="keywordflow">for</span>(i = 0; i &lt; count; ++i)
00807     {
00808         f = header_get_fieldn(rq-&gt;header, i);
00809         dbg_err_if(f == NULL); <span class="comment">/* shouldn't happen */</span>
00810         <span class="keywordflow">if</span>(strcasecmp(field_get_name(f), <span class="stringliteral">"cookie"</span>) == 0)
00811             dbg_err_if(request_parse_cookie(rq, f));
00812     }
00813 
00814     <span class="keywordflow">return</span> 0;
00815 err:
00816     <span class="keywordflow">return</span> ~0;
00817 }
00818 
00819 <span class="keyword">static</span> <span class="keywordtype">int</span> request_cb_add_var(vars_t *args, vars_t *also_to, <span class="keyword">const</span> <span class="keywordtype">char</span> *tok)
00820 {
00821     var_t *v = NULL;
00822 
00823     dbg_err_if(args == NULL);
00824     dbg_err_if(also_to == NULL);
00825     dbg_err_if(tok == NULL);
00826 
00827     <span class="comment">/* may fail with bad var encoding (url?a=b&amp;v); bad vars are ignored */</span>
00828     dbg_if(vars_add_urlvar(args, tok, &amp;v));
00829 
00830     <span class="keywordflow">if</span>(v)
00831     {
00832         <span class="comment">/* add the ptr also to the other vars list */</span>
00833         dbg_err_if(vars_add(also_to, v));
00834     }
00835 
00836     <span class="keywordflow">return</span> 0;
00837 err:
00838     <span class="keywordflow">return</span> ~0;
00839 }
00840 
00841 
00842 <span class="keyword">static</span> <span class="keywordtype">int</span> request_cb_add_post_var(<span class="keywordtype">void</span> *arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *tok)
00843 {
00844     request_t *rq = (request_t*)arg;
00845 
00846     <span class="keywordflow">return</span> request_cb_add_var(rq-&gt;args, rq-&gt;args_post, tok);
00847 }
00848 
00849 <span class="keyword">static</span> <span class="keywordtype">int</span> request_cb_add_get_var(<span class="keywordtype">void</span> *arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *tok)
00850 {
00851     request_t *rq = (request_t*)arg;
00852 
00853     <span class="keywordflow">return</span> request_cb_add_var(rq-&gt;args, rq-&gt;args_get, tok);
00854 }
00855 
00856 <span class="keyword">static</span> <span class="keywordtype">int</span> foreach_query_var(<span class="keyword">const</span> <span class="keywordtype">char</span> *urlquery, <span class="keywordtype">int</span> offset, 
00857         <span class="keywordtype">int</span>(*cb)(<span class="keywordtype">void</span>*,<span class="keyword">const</span> <span class="keywordtype">char</span>*), <span class="keywordtype">void</span> *arg)
00858 {
00859     <span class="keywordtype">char</span> *pp, *tok, *src, *query = NULL;
00860 
00861     dbg_err_if(offset &lt; 0);
00862     dbg_err_if(cb == NULL);
00863 
00864     <span class="keywordflow">if</span>(!urlquery)
00865         <span class="keywordflow">return</span> 0; <span class="comment">/* no args */</span>
00866 
00867     <span class="comment">/* dup to tokenize it */</span>
00868     query = u_strdup(urlquery + offset);
00869     dbg_err_if(query == NULL);
00870 
00871     <span class="comment">/* foreach name=value pair... */</span>
00872     <span class="keywordflow">for</span>(src = query; (tok = strtok_r(src, <span class="stringliteral">"&amp;"</span>, &amp;pp)) != NULL; src = NULL)
00873     {
00874         <span class="comment">/* call the callback that will save this var */</span>
00875         dbg_err_if(cb(arg, tok));
00876     }
00877 
00878     U_FREE(query);
00879 
00880     <span class="keywordflow">return</span> 0;
00881 err:
00882     U_FREE(query);
00883     <span class="keywordflow">return</span> ~0;
00884 }
00885 
00886 <span class="keyword">static</span> <span class="keywordtype">int</span> request_parse_query_args(request_t *rq)
00887 {
00888     dbg_err_if(rq == NULL);
00889 
00890     <span class="keywordflow">return</span> foreach_query_var(rq-&gt;query, 0, request_cb_add_get_var, (<span class="keywordtype">void</span>*)rq); 
00891 err:
00892     <span class="keywordflow">return</span> ~0;
00893 }
00894 
00895 <span class="comment">/* set is-cgi flag */</span>
00896 <span class="keywordtype">void</span> request_set_cgi(request_t *rq, <span class="keywordtype">int</span> cgi)
00897 {
00898     rq-&gt;cgi = cgi;
00899     <span class="keywordflow">return</span>;
00900 }
00901 
<a name="l00913"></a><a class="code" href="group__request.html#ga23">00913</a> ssize_t <a class="code" href="group__request.html#ga23">request_get_content_length</a>(request_t *rq)
00914 {
00915     dbg_return_if (rq == NULL, -1);
00916 
00917     <span class="keywordflow">return</span> (ssize_t) rq-&gt;content_length;
00918 }
00919 
00920 <span class="keyword">static</span> <span class="keywordtype">int</span> match_content_type(header_t *h, <span class="keyword">const</span> <span class="keywordtype">char</span> *mime_type)
00921 {
00922     <span class="keyword">const</span> <span class="keywordtype">char</span> *ct;
00923 
00924     dbg_return_if (h == NULL, 0);
00925     dbg_return_if (mime_type == NULL, 0);
00926 
00927     ct = header_get_field_value(h, <span class="stringliteral">"Content-Type"</span>);
00928     <span class="keywordflow">if</span>(ct == NULL || strncasecmp(ct, mime_type, strlen(mime_type)))
00929         <span class="keywordflow">return</span> 0;
00930 
00931     <span class="keywordflow">return</span> 1;
00932 }
00933 
00934 <span class="keyword">static</span> <span class="keywordtype">int</span> request_is_content_type(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *ct)
00935 {
00936     <span class="keywordflow">return</span> match_content_type(rq-&gt;header, ct);
00937 }
00938 
00939 <span class="keyword">static</span> <span class="keywordtype">int</span> request_is_multipart_formdata(request_t *rq)
00940 {
00941     <span class="keywordflow">return</span> request_is_content_type(rq, <span class="stringliteral">"multipart/form-data"</span>);
00942 }
00943 
00944 <span class="keyword">static</span> <span class="keywordtype">int</span> request_is_urlencoded(request_t *rq)
00945 {
00946     <span class="keywordflow">if</span>(header_get_field_value(rq-&gt;header, <span class="stringliteral">"Content-Type"</span>) == NULL)
00947         <span class="keywordflow">return</span> 1; <span class="comment">/* yes; no content-type field provided */</span>
00948 
00949     <span class="keywordflow">if</span>(request_is_content_type(rq, <span class="stringliteral">"application/x-www-form-urlencoded"</span>))
00950         <span class="keywordflow">return</span> 1; <span class="comment">/* yes */</span>
00951 
00952     <span class="keywordflow">return</span> 0; <span class="comment">/* no */</span>
00953 }
00954 
00955 <span class="keyword">static</span> <span class="keywordtype">int</span> request_parse_urlencoded_data(request_t *rq)
00956 {
00957     ssize_t qsz, len;
00958 
00959     dbg_err_if (rq == NULL);
00960 
00961     len = rq-&gt;content_length; <span class="comment">/* shortcut */</span>
00962 
00963     qsz = (rq-&gt;query ? strlen(rq-&gt;query) : 0);
00964 
00965     <span class="comment">/* alloc or enlarge the query string buffer */</span>
00966     rq-&gt;query = u_realloc(rq-&gt;query, len + qsz + 2);
00967     dbg_err_if(rq-&gt;query == NULL);
00968 
00969     <span class="comment">/* dbg("rq-&gt;query %x  size %u", rq-&gt;query, len+qsz+2); */</span>
00970 
00971     rq-&gt;query[qsz] = 0; <span class="comment">/* must be zero-term for strcat to work */</span>
00972     <span class="keywordflow">if</span>(qsz)
00973     {   <span class="comment">/* append a '&amp;' */</span>
00974         strcat(rq-&gt;query, <span class="stringliteral">"&amp;"</span>);
00975         ++qsz;
00976     }
00977 
00978     <span class="comment">/* append to current query string */</span>
00979     dbg_err_if(<a class="code" href="group__basic.html#ga18">io_read</a>(rq-&gt;io, rq-&gt;query + qsz, len) != len);
00980 
00981     <span class="comment">/* zero terminate it */</span>
00982     rq-&gt;query[qsz + len] = 0;
00983 
00984     <span class="comment">/* parse and add post vars to the rq-&gt;args and rq-&gt;args_post array */</span>
00985     dbg_err_if(foreach_query_var(rq-&gt;query, qsz, 
00986                 request_cb_add_post_var, (<span class="keywordtype">void</span>*)rq));
00987 
00988     <span class="keywordflow">return</span> 0;
00989 err:
00990     <span class="keywordflow">return</span> ~0;
00991 }
00992 
00993 <span class="comment">/* return the value of the param named 'param_name' of the field 'field_name'</span>
00994 <span class="comment">   and save it to 'buffer' */</span>
00995 <span class="keyword">static</span> <span class="keywordtype">int</span> request_get_fieldparam(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name, 
00996     <span class="keyword">const</span> <span class="keywordtype">char</span> *param_name, <span class="keywordtype">char</span> *buf, size_t size)
00997 {
00998     <span class="keyword">const</span> <span class="keywordtype">char</span> *param_value, *field_value, *p;
00999     size_t pv_len;
01000 
01001     dbg_err_if (rq == NULL);
01002     dbg_err_if (field_name == NULL);
01003     dbg_err_if (param_name == NULL);
01004     dbg_err_if (buf == NULL);
01005     dbg_err_if (size == 0);
01006 
01007     field_value = header_get_field_value(rq-&gt;header, field_name);
01008     dbg_err_if(field_value == NULL);
01009 
01010     <span class="comment">/* look for param name=value pair */</span>
01011     param_value = <a class="code" href="group__ut.html#ga28">u_stristr</a>(field_value, param_name);
01012     dbg_err_if(param_value == NULL);
01013 
01014     <span class="comment">/* skip param name */</span>
01015     param_value += strlen(param_name);
01016 
01017     <span class="comment">/* first char must be an equal sign */</span>
01018     dbg_err_if(*param_value++ != <span class="charliteral">'='</span>);
01019 
01020     <span class="comment">/* a param value ends on the first ';', space or at the end of string */</span>
01021     <span class="keywordflow">for</span>(p = param_value; ;++p)
01022         <span class="keywordflow">if</span>(*p == <span class="charliteral">'\0'</span> || *p == <span class="charliteral">';'</span> || isspace(*p))
01023             <span class="keywordflow">break</span>; <span class="comment">/* end of param value */</span>
01024 
01025     <span class="comment">/* param value len */</span>
01026     pv_len = p - param_value;
01027 
01028     <span class="comment">/* boundary check */</span>
01029     dbg_err_if(pv_len &gt; size - 1); 
01030 
01031     <span class="comment">/* copy out the param value */</span>
01032     strncpy(buf, param_value, pv_len);
01033     buf[MIN(pv_len, size - 1)] = 0;
01034 
01035     <span class="keywordflow">return</span> 0;
01036 err:
01037     <span class="keywordflow">return</span> ~0;
01038 }
01039 
01040 <span class="keyword">static</span> <span class="keywordtype">int</span> is_multipart_mixed(header_t *h)
01041 {
01042     <span class="keywordflow">return</span> match_content_type(h, <span class="stringliteral">"multipart/mixed"</span>);
01043 }
01044 
01045 <span class="keyword">static</span> <span class="keywordtype">int</span> is_encoded(header_t *h)
01046 {
01047     <span class="keyword">const</span> <span class="keywordtype">char</span> *cte;
01048 
01049     dbg_return_if (h == NULL, 0);
01050 
01051     <span class="keywordflow">if</span>((cte = header_get_field_value(h, <span class="stringliteral">"Content-Transfer-Encoding"</span>)) == NULL)
01052         <span class="keywordflow">return</span> 0; <span class="comment">/* not encoded */</span>
01053 
01054     <span class="keywordflow">if</span>(strcasecmp(cte, <span class="stringliteral">"binary"</span>) == 0)
01055         <span class="keywordflow">return</span> 0; <span class="comment">/* not encoded */</span>
01056 
01057     <span class="keywordflow">return</span> 1; <span class="comment">/* encoded */</span>
01058 }
01059 
01060 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> is_nl(<span class="keywordtype">char</span> c)
01061 {
01062     <span class="keywordflow">return</span> (c == <span class="charliteral">'\n'</span> || c == <span class="charliteral">'\r'</span> ? c : 0);
01063 }
01064 
01065 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> is_quote(<span class="keywordtype">char</span> c)
01066 {
01067     <span class="keywordflow">return</span> (c == <span class="charliteral">'"'</span> || c == <span class="charliteral">'\''</span> ? c : 0);
01068 }
01069 
01070 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_content_disposition(header_t *h, <span class="keywordtype">char</span> *name, <span class="keywordtype">char</span> *filename,
01071     size_t prmsz)
01072 {
01073     <span class="keyword">enum</span> { BUFSZ = 512 };
01074     <span class="keywordtype">char</span> *pp, *tok, *src, buf[BUFSZ];
01075     size_t n_len, fn_len;
01076     <span class="keyword">const</span> <span class="keywordtype">char</span> *cd;
01077     <span class="keywordtype">int</span> q;
01078 
01079     dbg_err_if (h == NULL);
01080     dbg_err_if (name == NULL);
01081     dbg_err_if (filename == NULL);
01082     dbg_err_if (prmsz == 0);
01083     
01084     cd = header_get_field_value(h, <span class="stringliteral">"Content-Disposition"</span>);
01085     dbg_err_if(cd == NULL);
01086 
01087     dbg_err_if(strlen(cd) &gt;= BUFSZ);
01088 
01089     <span class="comment">/* must start with form-data */</span>
01090     dbg_err_if(strncmp(cd, <span class="stringliteral">"form-data"</span>, strlen(<span class="stringliteral">"form-data"</span>)));
01091 
01092     name[0] = filename[0] = 0;
01093 
01094     <span class="comment">/* save a copy to tokenize it */</span>
01095     strncpy(buf, cd, BUFSZ);
01096 
01097     <span class="comment">/* shortcut */</span>
01098     n_len = strlen(<span class="stringliteral">"name="</span>);
01099     fn_len = strlen(<span class="stringliteral">"filename="</span>);
01100 
01101     <span class="comment">/* foreach name=value pair... */</span>
01102     <span class="keywordflow">for</span>(src = buf; (tok = strtok_r(src, <span class="stringliteral">";"</span>, &amp;pp)) != NULL; src = NULL)
01103     {
01104         <span class="comment">/* skip trailing blanks */</span>
01105         <span class="keywordflow">while</span>(isspace(*tok))
01106             ++tok;
01107 
01108         <span class="keywordflow">if</span>(strncmp(tok, <span class="stringliteral">"form-data"</span>, strlen(<span class="stringliteral">"form-data"</span>)) == 0)
01109             <span class="keywordflow">continue</span>;   <span class="comment">/* skip */</span>
01110         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strncmp(tok, <span class="stringliteral">"name="</span>, n_len) == 0) {
01111             <span class="comment">/* skip the name part */</span>
01112             tok += n_len;
01113 
01114             <span class="comment">/* remove single or double quotes */</span>
01115             <span class="keywordflow">if</span>((q = is_quote(tok[0])) != 0)
01116                 ++tok;
01117             <span class="keywordflow">if</span>(strlen(tok) &amp;&amp; tok[strlen(tok) - 1] == q)
01118                 tok[strlen(tok) - 1] = 0;
01119 
01120             strncpy(name, tok, prmsz);
01121         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strncmp(tok, <span class="stringliteral">"filename="</span>, fn_len) == 0) {
01122             <span class="comment">/* skip the filename part */</span>
01123             tok += fn_len;
01124 
01125             <span class="comment">/* remove single or double quotes */</span>
01126             <span class="keywordflow">if</span>((q = is_quote(tok[0])) != 0)
01127                 ++tok;
01128             <span class="keywordflow">if</span>(strlen(tok) &amp;&amp; tok[strlen(tok) - 1] == q)
01129                 tok[strlen(tok) - 1] = 0;
01130 
01131             strncpy(filename, tok, prmsz);
01132         } 
01133         <span class="comment">/* else ignore unknown fields */</span>
01134     }
01135             
01136     <span class="keywordflow">return</span> 0;
01137 err:
01138     <span class="keywordflow">return</span> ~0;
01139 }
01140 
01141 <span class="comment">/* </span>
01142 <span class="comment"> * Read from io until obuf is full or until stop_at string is found.</span>
01143 <span class="comment"> *</span>
01144 <span class="comment"> * Boyer-Moore algorithm is used for efficiency. </span>
01145 <span class="comment"> *</span>
01146 <span class="comment"> * Returns the number of bytes written to obuf </span>
01147 <span class="comment"> */</span>
01148 <span class="keyword">static</span> ssize_t read_until(io_t *io, <span class="keyword">const</span> <span class="keywordtype">char</span> *stop_at, <span class="keywordtype">char</span> *obuf, 
01149     size_t size, <span class="keywordtype">int</span> *found)
01150 {
01151     <span class="comment">/* use this macro before accessing obuf[idx] elem. the macro will load from</span>
01152 <span class="comment">       the given io enough bytes to access the required byte. if the buffer</span>
01153 <span class="comment">       is too small (i.e. less then idx bytes long) the function will return */</span>
01154 <span class="preprocessor">    #define SETUP_BUF_ACCESS_AT(idx)                                        \</span>
01155 <span class="preprocessor">        if(idx &gt;= wtot) {                                                   \</span>
01156 <span class="preprocessor">            if(idx &gt;= size)                                                 \</span>
01157 <span class="preprocessor">                return wtot; </span><span class="comment">/* the output buffer is full */</span>                \
01158                                                                             \
01159             <span class="comment">/* we need to fetch some more bytes to access obuf[i] */</span>        \
01160             dbg_err_if((rc = io_read(io, wbuf, idx + 1 - wtot)) &lt; 0);       \
01161             if(rc == 0 || rc &lt; idx + 1 - wtot)                              \
01162                 return wtot + rc; <span class="comment">/* eof or short count */</span>                  \
01163             wbuf += rc;                                                     \
01164             wtot += rc;                                                     \
01165         }
01166 
01167     <span class="keywordtype">int</span> sa_len = strlen(stop_at);
01168     <span class="keywordtype">int</span> i, t, shift[256], rc;
01169     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
01170     size_t wtot = 0;
01171     <span class="keywordtype">char</span> *wbuf = obuf;
01172 
01173     dbg_err_if (io == NULL);
01174     dbg_err_if (stop_at == NULL);
01175     dbg_err_if (obuf == NULL);
01176     <span class="comment">/* size may be 0 */</span>
01177     dbg_err_if (found == NULL);
01178 
01179     <span class="keywordflow">for</span>(i = 0; i &lt; 256; ++i)  
01180         shift[i] = sa_len;
01181 
01182     <span class="keywordflow">for</span>(i = 0; i &lt; sa_len; ++i)
01183         shift[ (<span class="keywordtype">int</span>)stop_at[i] ] = sa_len - i - 1;
01184 
01185     *found = 0;
01186 
01187     <span class="keywordflow">for</span>(i = t = sa_len-1; t &gt;= 0; --i, --t)
01188     {
01189         SETUP_BUF_ACCESS_AT(i);
01190 
01191         <span class="keywordflow">while</span>((c = obuf[i]) != stop_at[t]) 
01192         {
01193             i += MAX(sa_len - t, shift[c]);
01194 
01195             SETUP_BUF_ACCESS_AT(i);
01196 
01197             t = sa_len - 1;
01198         }
01199     }
01200 
01201     *found = 1;
01202 
01203     <span class="comment">/* found; obuf[i] is where the matching string is */</span>
01204     <span class="keywordflow">return</span> wtot;
01205 err:
01206     <span class="keywordflow">return</span> -1;
01207 }
01208 
01209 
<a name="l01228"></a><a class="code" href="group__request.html#ga40">01228</a> vars_t *<a class="code" href="group__request.html#ga40">request_get_uploads</a>(request_t *rq)
01229 {
01230     <span class="keywordflow">return</span> rq-&gt;uploads;
01231 }
01232 
01233 <span class="comment">/*</span>
01234 <span class="comment"> * name:         form "name" &lt;input&gt; tag attribute value</span>
01235 <span class="comment"> * filename:     name of the uploaded file provided by the client</span>
01236 <span class="comment"> * tmp_filename: name on the temp file when the uploaded data has been saved</span>
01237 <span class="comment"> *               on the local disk</span>
01238 <span class="comment"> * mime_type:    uploaded MIME type as stated by the browser (may be NULL)</span>
01239 <span class="comment"> */</span>
01240 <span class="keyword">static</span> <span class="keywordtype">int</span> request_add_uploaded_file(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, 
01241     <span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *tmp_filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *mime_type)
01242 {
01243     <span class="keyword">struct </span>stat st;
01244     var_t *v = NULL;
01245     upload_info_t *info = NULL;
01246 
01247     dbg_err_if (rq == NULL);
01248     dbg_err_if (name == NULL);
01249     <span class="comment">/* filename may be NULL */</span>
01250     dbg_err_if (tmp_filename == NULL);
01251     <span class="comment">/* mime_type may be NULL */</span>
01252 
01253     dbg_err_sif (stat(tmp_filename, &amp;st) &lt; 0);
01254 
01255     <span class="comment">/* create a new var obj */</span>
01256     dbg_err_if(var_create(name, tmp_filename, &amp;v));
01257 
01258     <span class="comment">/* alloc an info struct to attach to the var_t obj */</span>
01259     dbg_err_if((info = u_zalloc(<span class="keyword">sizeof</span>(upload_info_t))) == NULL);
01260 
01261     <span class="comment">/* set info data */</span>
01262     info-&gt;size = st.st_size;
01263     <span class="keywordflow">if</span>(mime_type)
01264         snprintf(info-&gt;mime_type, MIME_TYPE_BUFSZ, <span class="stringliteral">"%s"</span>, mime_type);
01265     <span class="keywordflow">else</span>
01266         info-&gt;mime_type[0] = 0;
01267 
01268     <span class="keywordflow">if</span>(filename)
01269         snprintf(info-&gt;filename, U_FILENAME_MAX, <span class="stringliteral">"%s"</span>, filename);
01270 
01271     <span class="comment">/* attach info to v */</span>
01272     var_set_opaque(v, info);
01273     info = NULL;
01274 
01275     <span class="comment">/* push into the cookie list */</span>
01276     dbg_err_if(vars_add(rq-&gt;uploads, v));
01277 
01278     <span class="keywordflow">return</span> 0;
01279 err:
01280     <span class="keywordflow">if</span>(info)
01281         U_FREE(info);
01282     <span class="keywordflow">if</span>(v)
01283         var_free(v);
01284     <span class="keywordflow">return</span> ~0;
01285 }
01286 
01287 <span class="keyword">static</span> <span class="keywordtype">int</span> request_get_uploaded_filev(request_t *rq, var_t *v,
01288     <span class="keywordtype">char</span> local_filename[U_FILENAME_MAX], <span class="keywordtype">char</span> client_filename[U_FILENAME_MAX],
01289     <span class="keywordtype">char</span> mime_type[MIME_TYPE_BUFSZ], size_t *file_size)
01290 {           
01291     upload_info_t *info;
01292     <span class="keyword">const</span> <span class="keywordtype">char</span> *tmp_fqn;
01293 
01294     dbg_err_if (rq == NULL);
01295     dbg_err_if (v == NULL);
01296     dbg_err_if (local_filename == NULL);
01297     dbg_err_if (client_filename == NULL);
01298     dbg_err_if (mime_type == NULL);
01299     dbg_err_if (file_size == NULL);
01300 
01301     info = var_get_opaque(v);
01302     dbg_err_if(info == NULL);
01303 
01304     tmp_fqn = var_get_value(v);
01305     dbg_err_if(tmp_fqn == NULL);
01306 
01307     <span class="comment">/* copy out return values */</span>
01308     strncpy(local_filename, tmp_fqn, U_FILENAME_MAX);
01309     strncpy(mime_type, info-&gt;mime_type, MIME_TYPE_BUFSZ);
01310     strncpy(client_filename, info-&gt;filename, U_FILENAME_MAX);
01311     *file_size = info-&gt;size;
01312 
01313     <span class="keywordflow">return</span> 0;
01314 err:
01315     <span class="keywordflow">return</span> ~0;
01316 }
01317 
<a name="l01340"></a><a class="code" href="group__request.html#ga41">01340</a> <span class="keywordtype">int</span> <a class="code" href="group__request.html#ga41">request_get_uploaded_file</a>(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, size_t idx,
01341     <span class="keywordtype">char</span> local_filename[U_FILENAME_MAX], <span class="keywordtype">char</span> client_filename[U_FILENAME_MAX],
01342     <span class="keywordtype">char</span> mime_type[MIME_TYPE_BUFSZ], size_t *file_size)
01343 {
01344     var_t *v;
01345 
01346     dbg_err_if (rq == NULL);
01347     dbg_err_if (name == NULL);
01348     dbg_err_if (idx &gt;= vars_count(rq-&gt;uploads));
01349     dbg_err_if (local_filename == NULL);
01350     dbg_err_if (client_filename == NULL);
01351     dbg_err_if (mime_type == NULL);
01352     dbg_err_if (file_size == NULL);
01353 
01354     v = vars_geti(rq-&gt;uploads, name, idx);
01355     dbg_err_if(v == NULL);
01356 
01357     <span class="keywordflow">return</span> request_get_uploaded_filev(rq, v, local_filename, client_filename,
01358         mime_type, file_size);
01359 err:
01360     <span class="keywordflow">return</span> ~0;
01361 }
01362 
01363 <span class="keyword">static</span> ssize_t request_read_until_boundary(request_t *rq, io_t *io, 
01364         <span class="keyword">const</span> <span class="keywordtype">char</span> *boundary, <span class="keywordtype">char</span> *buf, size_t size, u_buf_t **pubuf)
01365 {
01366     u_buf_t *ubuf = NULL;
01367     <span class="keywordtype">int</span> found;
01368     size_t bound_len, trb;
01369     ssize_t rc;
01370 
01371     <span class="comment">/* shortcut */</span>
01372     bound_len = strlen(boundary);
01373 
01374     trb = 0;
01375 
01376     <span class="keywordflow">for</span>(found = 0; !found; <span class="comment">/* nothing */</span>)
01377     {
01378         rc = read_until(io, boundary, buf, size, &amp;found);
01379         dbg_err_if(rc &lt;= 0); <span class="comment">/* on error or eof exit */</span>
01380 
01381         <span class="comment">/* write all but the last bound_len + 2 (\r\n) bytes */</span>
01382         <span class="keywordflow">if</span>(found)
01383         {
01384             rc -= (bound_len + 2);
01385             dbg_err_if(rc &lt; 0);
01386 
01387             <span class="comment">/* zero-term the buffer (removing the boundary) */</span>
01388             buf[rc] = 0;
01389 
01390         } <span class="keywordflow">else</span> {
01391 
01392             <span class="comment">/* buffer too small, alloc (and use) a dynamic buffer */</span>
01393             <span class="keywordflow">if</span>(ubuf == NULL)
01394             {
01395                 dbg_err_if(u_buf_create(&amp;ubuf));
01396                 dbg_err_if(u_buf_reserve(ubuf, 2 * size));
01397             }
01398         }
01399 
01400         <span class="comment">/* total read bytes */</span>
01401         trb += rc;
01402 
01403         warn_err_ifm(trb &gt; rq-&gt;post_maxsize, <span class="stringliteral">"POST data exceed post_maxsize"</span>);
01404 
01405         <span class="comment">/* if we're using the buf on the heap then append read data */</span>
01406         <span class="keywordflow">if</span>(ubuf)
01407             dbg_err_if(u_buf_append(ubuf, buf, rc));
01408     }
01409 
01410     *pubuf = ubuf;
01411 
01412     <span class="keywordflow">return</span> (ubuf ? u_buf_len(ubuf) : rc);
01413 err:
01414     <span class="keywordflow">if</span>(ubuf)
01415         u_buf_free(ubuf);
01416     <span class="keywordflow">return</span> -1;
01417 
01418 }
01419 
01420 <span class="keyword">static</span> <span class="keywordtype">int</span> request_parse_multipart_chunk(request_t *rq, io_t *io, 
01421     <span class="keyword">const</span> <span class="keywordtype">char</span> *boundary, <span class="keywordtype">int</span> *eof)
01422 {
01423     <span class="keyword">enum</span> { PRMSZ = 512, BUFSZ = 4096 };
01424     header_t *h = NULL;
01425     io_t *tmpio = NULL;
01426     var_t *v = NULL;
01427     u_buf_t *ubuf = NULL;
01428     <span class="keywordtype">char</span> name[PRMSZ], filename[PRMSZ], buf[BUFSZ];
01429     size_t bound_len;
01430     <span class="keywordtype">int</span> found;
01431     ssize_t rc;
01432 
01433     <span class="comment">/* create an header object to parse MIME part headers */</span>
01434     dbg_err_if(header_create(&amp;h));
01435 
01436     <span class="comment">/* read header lines until the first blank line */</span>
01437     dbg_err_if(header_load(h, io));
01438 
01439     warn_err_ifm(is_multipart_mixed(h), 
01440         <span class="stringliteral">"multipart/mixed content is not supported yet"</span>);
01441 
01442     <span class="comment">/* HTTP should never use cte */</span>
01443     warn_err_ifm(is_encoded(h), 
01444         <span class="stringliteral">"encoded file upload is not supported"</span>);
01445 
01446     dbg_err_if(parse_content_disposition(h, name, filename, PRMSZ));
01447 
01448     <span class="comment">/* shortcut */</span>
01449     bound_len = strlen(boundary);
01450 
01451     <span class="keywordflow">if</span>(filename[0] != <span class="charliteral">'\0'</span>)
01452     {
01453         dbg_err_if(BUFSZ &lt;= bound_len);
01454 
01455         <span class="comment">/* open a temporary file to dump uploaded data */</span>
01456         dbg_err_if(<a class="code" href="group__ut.html#ga36">u_tmpfile_open</a>(rq-&gt;temp_dir, &amp;tmpio));
01457 
01458         <span class="keywordflow">for</span>(found = 0; !found; <span class="comment">/* nothing */</span>)
01459         {
01460             rc = read_until(io, boundary, buf, BUFSZ, &amp;found);
01461             dbg_err_if(rc &lt;= 0); <span class="comment">/* on error or eof exit */</span>
01462 
01463             <span class="comment">/* write all but the last bound_len + 2 (\r\n) bytes */</span>
01464             <span class="keywordflow">if</span>(found)
01465             {
01466                 rc -= (bound_len + 2);
01467                 dbg_err_if(rc &lt; 0);
01468             }
01469 
01470             <span class="comment">/* write to the temp file */</span>
01471             dbg_err_if(<a class="code" href="group__basic.html#ga19">io_write</a>(tmpio, buf, rc) &lt; 0);
01472         }
01473 
01474         <span class="comment">/* save the path/name of the tmp file to buf */</span>
01475         dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(tmpio, buf, BUFSZ));
01476 
01477         <span class="comment">/* flush and free */</span>
01478         <a class="code" href="group__basic.html#ga14">io_free</a>(tmpio); tmpio = NULL;
01479 
01480         <span class="comment">/* add this file to the uploaded file list */</span>
01481         dbg_err_if(request_add_uploaded_file(rq, name, filename, buf, 
01482             header_get_field_value(h, <span class="stringliteral">"Content-Type"</span>)));
01483 
01484         <span class="comment">/* could be "\r\n" for not-ending boundaries or "--\r\n" */</span>
01485         dbg_err_if(<a class="code" href="group__basic.html#ga25">io_gets</a>(io, buf, BUFSZ) &lt;= 0);
01486 
01487         <span class="keywordflow">if</span>(strncmp(buf, <span class="stringliteral">"--"</span>, 2) == 0)
01488             *eof = 1; <span class="comment">/* end of MIME stuff */</span>
01489 
01490     } <span class="keywordflow">else</span> {
01491         <span class="comment">/* read data before the boundary into the buffer. if the buffer is too </span>
01492 <span class="comment">           small the function will return all data in a new ubuf that must be </span>
01493 <span class="comment">           freed by the caller */</span>
01494         rc = request_read_until_boundary(rq, io, boundary, buf, BUFSZ, &amp;ubuf);
01495         dbg_err_if(rc &lt; 0);
01496 
01497         <span class="comment">/* add a new binary var to request arguments list */</span>
01498         dbg_err_if(var_bin_create(name, 
01499                     (ubuf ? u_buf_ptr(ubuf) : buf), 
01500                     (ubuf ? u_buf_len(ubuf) : rc), 
01501                     &amp;v));
01502 
01503         dbg_if(vars_add(rq-&gt;args, v));
01504 
01505         <span class="comment">/* also add it to the post array */</span>
01506         dbg_if(vars_add(rq-&gt;args_post, v));
01507 
01508         <span class="comment">/* could be "\r\n" for not-ending boundaries or "--\r\n" */</span>
01509         dbg_err_if(<a class="code" href="group__basic.html#ga25">io_gets</a>(io, buf, BUFSZ) &lt;= 0);
01510 
01511         <span class="keywordflow">if</span>(strncmp(buf, <span class="stringliteral">"--"</span>, 2) == 0)
01512             *eof = 1; <span class="comment">/* end of MIME stuff */</span>
01513     }
01514 
01515     <span class="keywordflow">if</span>(ubuf)
01516         u_buf_free(ubuf);
01517 
01518     header_free(h);
01519 
01520     <span class="keywordflow">return</span> 0;
01521 err:
01522     <span class="keywordflow">if</span>(ubuf)
01523         u_buf_free(ubuf);
01524     <span class="keywordflow">if</span>(tmpio)
01525         <a class="code" href="group__basic.html#ga14">io_free</a>(tmpio);
01526     <span class="keywordflow">if</span>(h)
01527         header_free(h);
01528     <span class="keywordflow">return</span> ~0;
01529 }
01530 
01531 <span class="keyword">static</span> <span class="keywordtype">int</span> request_parse_multipart_data(request_t *rq)
01532 {
01533     <span class="keyword">enum</span> { BOUNDARY_BUFSZ = 128, BUFSZ = 1024 }; 
01534     <span class="keywordtype">char</span> boundary[BOUNDARY_BUFSZ], buf[BUFSZ];
01535     <span class="keywordtype">int</span> eof;
01536 
01537     <span class="comment">/* boundaries always start with -- */</span>
01538     strcpy(boundary, <span class="stringliteral">"--"</span>);
01539 
01540     dbg_err_if(request_get_fieldparam(rq, <span class="stringliteral">"Content-Type"</span>, <span class="stringliteral">"boundary"</span>,
01541         boundary + 2, BOUNDARY_BUFSZ - 2));
01542 
01543     dbg_err_if(strlen(boundary) == 0);
01544 
01545     <span class="comment">/* skip the MIME preamble (usually not used in HTTP) */</span>
01546     <span class="keywordflow">for</span>(;;)
01547     {
01548         dbg_err_if(<a class="code" href="group__basic.html#ga25">io_gets</a>(rq-&gt;io, buf, BUFSZ) &lt;= 0);
01549         <span class="keywordflow">if</span>(!strncmp(buf, boundary, strlen(boundary)))
01550             <span class="keywordflow">break</span>; <span class="comment">/* boundary found */</span>
01551     }
01552 
01553     <span class="comment">/* cycle on each MIME part */</span>
01554     <span class="keywordflow">for</span>(eof = 0; eof == 0; )
01555         dbg_err_if(request_parse_multipart_chunk(rq, rq-&gt;io, boundary, &amp;eof));
01556 
01557     <span class="keywordflow">return</span> 0;
01558 err:
01559     <span class="keywordflow">return</span> ~0;
01560 }
01561 
01562 <span class="keyword">static</span> <span class="keywordtype">int</span> request_cb_close_socket(talarm_t *al, <span class="keywordtype">void</span> *arg)
01563 {
01564     io_t *io = (io_t*)arg;
01565 
01566     u_unused_args(al);
01567 
01568     warn(<span class="stringliteral">"[%x] connection timed out, closing"</span>, io);
01569     
01570     <span class="comment">/* close the stream (but not free it) */</span>
01571     <a class="code" href="group__basic.html#ga13">io_close</a>(io);
01572 
01573     <span class="keywordflow">return</span> 0;
01574 }
01575 
01576 <span class="keywordtype">int</span> request_parse_data(request_t *rq)
01577 {
01578     talarm_t *al = NULL;
01579     <span class="keywordtype">int</span> rc = <a class="code" href="http_8h.html#a32a9">HTTP_STATUS_BAD_REQUEST</a>;
01580 
01581     <span class="keywordflow">if</span>(rq-&gt;method == <a class="code" href="http_8h.html#a33a23">HM_POST</a>)
01582     {
01583         <span class="comment">/* some vars may be urlencoded */</span>
01584         dbg_err_if(request_parse_query_args(rq));
01585 
01586         <span class="comment">/* Content-Length is required when using POST */</span>
01587         dbg_err_if(request_set_content_length(rq) &amp;&amp; 
01588             (rc = HTTP_STATUS_LENGTH_REQUIRED));
01589 
01590         <span class="keywordflow">if</span>(rq-&gt;content_length == 0)
01591             <span class="keywordflow">return</span> 0; <span class="comment">/* no data posted */</span>
01592 
01593         <span class="comment">/* set a timeout to abort POST if it takes too long ... */</span>
01594         dbg_err_if(timerm_add(rq-&gt;post_timeout, request_cb_close_socket, 
01595             (<span class="keywordtype">void</span>*)rq-&gt;io, &amp;al));
01596 
01597         <span class="comment">/* abort if the client is pushing too much data */</span>
01598         dbg_err_if(rq-&gt;content_length &gt; rq-&gt;post_maxsize &amp;&amp;
01599             (rc = HTTP_STATUS_REQUEST_TOO_LARGE));
01600 
01601         <span class="keywordflow">if</span>(request_is_multipart_formdata(rq))
01602         { 
01603             <span class="comment">/* &lt;form enctype="multipart/form-data" ...&gt; */</span>
01604             dbg_err_if(request_parse_multipart_data(rq));
01605         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(request_is_urlencoded(rq)) {
01606             <span class="comment">/* if there's no content-type field or</span>
01607 <span class="comment">               &lt;form [enctype="application/x-www-form-urlencoded"] ...&gt; */</span>
01608             dbg_err_if(request_parse_urlencoded_data(rq));
01609         } <span class="keywordflow">else</span> {
01610             <span class="comment">/* nothing to do, the user will handle incoming data in his .kl1 */</span>
01611         }
01612 
01613         <span class="comment">/* post timeout not expired, clear it */</span>
01614         dbg_if(timerm_del(al)); al = NULL;
01615     } <span class="keywordflow">else</span> {
01616         <span class="comment">/* parse urlencoded variables and set var_t* array */</span>
01617         dbg_err_if(request_parse_query_args(rq));
01618     }
01619 
01620     <span class="keywordflow">return</span> 0;
01621 err:
01622     <span class="keywordflow">if</span>(al)
01623         dbg_if(timerm_del(al));
01624     <span class="keywordflow">return</span> rc;
01625 }
01626 
01627 <span class="comment">/* cache data found in broker_is_valid_uri so we don't have to look for it </span>
01628 <span class="comment">   again in broker_serve */</span>
01629 <span class="keywordtype">void</span> request_set_sup_info(request_t *rq, supplier_t *sup, <span class="keywordtype">void</span> *handle, 
01630         time_t mtime)
01631 {
01632     rq-&gt;si_sup = sup;
01633     rq-&gt;si_handle = handle;
01634     rq-&gt;si_mtime = mtime;
01635 
01636     <span class="keywordflow">return</span>;
01637 }
01638 
01639 <span class="keywordtype">void</span> request_get_sup_info(request_t *rq, supplier_t **psup, <span class="keywordtype">void</span> **phandle, 
01640         time_t *pmtime)
01641 {
01642     <span class="keywordflow">if</span>(psup)
01643         *psup = rq-&gt;si_sup;
01644 
01645     <span class="keywordflow">if</span>(phandle)
01646         *phandle = rq-&gt;si_handle;
01647 
01648     <span class="keywordflow">if</span>(pmtime)
01649         *pmtime = rq-&gt;si_mtime;
01650 
01651     <span class="keywordflow">return</span>;
01652 }
01653 
01654 <span class="comment">/*</span>
01655 <span class="comment"> * Parse request object \p rq.</span>
01656 <span class="comment"> *</span>
01657 <span class="comment"> * \param rq            request object</span>
01658 <span class="comment"> * \param is_valid_uri  URI validation function</span>
01659 <span class="comment"> * \param arg           argument to is_valid_uri</span>
01660 <span class="comment"> *</span>
01661 <span class="comment"> * \return \c 0 if successful, non-zero on error</span>
01662 <span class="comment"> */</span>
01663 <span class="keywordtype">int</span> request_parse_header(request_t *rq, 
01664         <span class="keywordtype">int</span> (*is_valid_uri)(<span class="keywordtype">void</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span> *, size_t),
01665         <span class="keywordtype">void</span>* arg)
01666 {
01667     <span class="keyword">enum</span> { BUFSZ = 4096 };
01668     <span class="keyword">const</span> <span class="keywordtype">char</span> WP[] = <span class="stringliteral">" \t\r\n"</span>;
01669     <span class="keywordtype">char</span> ln[BUFSZ], *pp, *method, *uri, *proto;
01670     talarm_t *al = NULL;
01671     
01672     dbg_err_if (rq == NULL);
01673     dbg_err_if (rq-&gt;io == NULL); <span class="comment">/* must call rq_bind before rq_parse */</span>
01674 
01675     <span class="comment">/* wait at most N seconds to receive the request */</span>
01676     dbg_err_if(timerm_add(rq-&gt;idle_timeout, request_cb_close_socket, 
01677         (<span class="keywordtype">void</span>*)rq-&gt;io, &amp;al));
01678 
01679     <span class="keywordflow">if</span>(!rq-&gt;cgi)
01680     {
01681         <span class="comment">/* cp the first line */</span>
01682         dbg_err_if(<a class="code" href="group__basic.html#ga25">io_gets</a>(rq-&gt;io, ln, BUFSZ) &lt;= 0);
01683 
01684         <span class="comment">/* save the verbatim request line */</span>
01685         dbg_err_if(request_set_client_request(rq, ln));
01686 
01687         method = strtok_r(ln, WP, &amp;pp); 
01688         dbg_err_if(!method || request_set_method(rq, method));
01689 
01690         uri = strtok_r(NULL, WP, &amp;pp);
01691         dbg_err_if(!uri || request_set_uri(rq, uri, is_valid_uri, arg));
01692 
01693         <span class="comment">/* HTTP/0.9 not supported yet */</span> 
01694         proto = strtok_r(NULL, WP, &amp;pp);
01695         dbg_err_if(!proto || request_set_proto(rq, proto)); 
01696 
01697         dbg_err_if(header_load(rq-&gt;header, rq-&gt;io));
01698     } <span class="keywordflow">else</span> {
01699         dbg_err_if(header_load_from_cgienv(rq-&gt;header));
01700     }
01701 
01702     <span class="comment">/* set if-modified-since time_t value */</span>
01703     dbg_err_if(request_parse_ims(rq));
01704 
01705     <span class="comment">/* parse "Cookie:" fields and set the cookies vars_t */</span>
01706     dbg_err_if(request_parse_cookies(rq));
01707 
01708     <span class="comment">/* Content-Length is required when using POST */</span>
01709     <span class="keywordflow">if</span>(<a class="code" href="group__request.html#ga22">request_get_method</a>(rq) == <a class="code" href="http_8h.html#a33a23">HM_POST</a>)
01710         dbg_err_if(request_set_content_length(rq));
01711 
01712     <span class="comment">/* idle timeout not expired, clear it */</span>
01713     dbg_if(timerm_del(al)); al = NULL;
01714 
01715     <span class="keywordflow">return</span> 0;
01716 err:
01717     <span class="keywordflow">if</span>(al)
01718         timerm_del(al);
01719     <span class="keywordflow">return</span> ~0;
01720 }
01721 
<a name="l01733"></a><a class="code" href="group__request.html#ga22">01733</a> <span class="keywordtype">int</span> <a class="code" href="group__request.html#ga22">request_get_method</a>(request_t *rq)
01734 {
01735     dbg_return_if (rq == NULL, <a class="code" href="http_8h.html#a33a20">HM_UNKNOWN</a>);
01736 
01737     <span class="keywordflow">return</span> rq-&gt;method;
01738 }
01739 
<a name="l01751"></a><a class="code" href="group__request.html#ga16">01751</a> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="group__request.html#ga16">request_get_protocol</a>(request_t *rq)
01752 {
01753     dbg_return_if (rq == NULL, <span class="stringliteral">"unknown"</span>);
01754 
01755     <span class="keywordflow">return</span> rq-&gt;protocol;
01756 }
01757 
<a name="l01768"></a><a class="code" href="group__request.html#ga18">01768</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga18">request_get_resolved_filename</a>(request_t *rq)
01769 {
01770     dbg_return_if (rq == NULL, NULL);
01771 
01772     <span class="keywordflow">return</span> rq-&gt;resolved_filename;
01773 }
01774 
<a name="l01785"></a><a class="code" href="group__request.html#ga21">01785</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__request.html#ga21">request_get_resolved_path_info</a>(request_t *rq)
01786 {
01787     dbg_return_if (rq == NULL, NULL);
01788 
01789     <span class="keywordflow">return</span> rq-&gt;resolved_path_info;
01790 }
01791 
01792 <span class="keywordtype">int</span> request_print(request_t *rq)
01793 {
01794     dbg_return_if (rq == NULL, ~0);
01795 
01796     dbg(<span class="stringliteral">"method: %u"</span>, rq-&gt;method);
01797     dbg(<span class="stringliteral">"uri: %s"</span>, rq-&gt;uri);
01798     dbg(<span class="stringliteral">"proto: %s"</span>, rq-&gt;protocol);
01799     dbg(<span class="stringliteral">"filename: %s"</span>, rq-&gt;filename);
01800     dbg(<span class="stringliteral">"resolved filename: %s"</span>, rq-&gt;resolved_filename);
01801     dbg(<span class="stringliteral">"path_info: %s"</span>, rq-&gt;path_info);
01802     dbg(<span class="stringliteral">"resolved path_info: %s"</span>, rq-&gt;resolved_path_info);
01803     dbg(<span class="stringliteral">"query: %s"</span>, rq-&gt;query);
01804 
01805     <span class="keywordflow">return</span> 0;
01806 }
01807 
01808 <span class="keyword">static</span> <span class="keywordtype">int</span> request_load_config(request_t *rq)
01809 {
01810     u_config_t *c;
01811     vhost_t *vhost;
01812     <span class="keyword">const</span> <span class="keywordtype">char</span> *v;
01813 
01814     dbg_err_if (rq == NULL);
01815     dbg_err_if (rq-&gt;http == NULL);
01816 
01817     dbg_err_if((vhost = http_get_vhost(rq-&gt;http, rq)) == NULL);
01818 
01819     <span class="comment">/* vhost can override those fields */</span>
01820     dbg_err_if((c = vhost-&gt;config) == NULL);
01821     
01822     <span class="comment">/* defaults */</span>
01823     rq-&gt;idle_timeout = REQUEST_DEFAULT_IDLE_TIMEOUT;
01824     rq-&gt;post_timeout = REQUEST_DEFAULT_POST_TIMEOUT;
01825     rq-&gt;post_maxsize = REQUEST_DEFAULT_POST_MAXSIZE;
01826     rq-&gt;temp_dir = NULL;    <span class="comment">/* use system default */</span>
01827 
01828     <span class="comment">/* idle timeout */</span>
01829     <span class="keywordflow">if</span>((v = u_config_get_subkey_value(c, <span class="stringliteral">"idle_timeout"</span>)) != NULL)
01830         rq-&gt;idle_timeout = MAX(1, atoi(v));
01831 
01832     <span class="comment">/* post timeout */</span>
01833     <span class="keywordflow">if</span>((v = u_config_get_subkey_value(c, <span class="stringliteral">"post_timeout"</span>)) != NULL)
01834         rq-&gt;post_timeout = MAX(5, atoi(v));
01835 
01836     <span class="comment">/* post maxsize */</span>
01837     <span class="keywordflow">if</span>((v = u_config_get_subkey_value(c, <span class="stringliteral">"post_maxsize"</span>)) != NULL)
01838         rq-&gt;post_maxsize = MAX(1024, atoi(v));
01839 
01840     <span class="comment">/* temp dir to use on file upload.  when 'NULL' use system default */</span>
01841     rq-&gt;temp_dir = u_config_get_subkey_value(c, <span class="stringliteral">"temp_dir"</span>);
01842 
01843     <span class="keywordflow">return</span> 0;
01844 err:
01845     <span class="keywordflow">return</span> ~0;
01846 }
01847 
01848 <span class="keywordtype">int</span> request_create(http_t *http, request_t **prq)
01849 {
01850     request_t *rq = NULL;
01851 
01852     dbg_return_if (prq == NULL, ~0);
01853     dbg_return_if (http == NULL, ~0);
01854 
01855     rq = u_zalloc(<span class="keyword">sizeof</span>(request_t));
01856     dbg_err_if(rq == NULL);
01857 
01858     dbg_err_if(header_create(&amp;rq-&gt;header));
01859 
01860     dbg_err_if(vars_create(&amp;rq-&gt;args));
01861     dbg_err_if(vars_create(&amp;rq-&gt;cookies));
01862     dbg_err_if(vars_create(&amp;rq-&gt;uploads));
01863 
01864     dbg_err_if(vars_create(&amp;rq-&gt;args_get));
01865     dbg_err_if(vars_create(&amp;rq-&gt;args_post));
01866 
01867     <span class="comment">/* args_get and args_post link to var_t owned by the rq-&gt;args list */</span>
01868     dbg_err_if(vars_set_flags(rq-&gt;args_get, VARS_FLAG_FOREIGN));
01869     dbg_err_if(vars_set_flags(rq-&gt;args_post, VARS_FLAG_FOREIGN));
01870 
01871     rq-&gt;http = http;
01872 
01873     dbg_err_if(request_load_config(rq));
01874 
01875     *prq = rq;
01876 
01877     <span class="keywordflow">return</span> 0;
01878 err:
01879     <span class="keywordflow">if</span>(rq)
01880         request_free(rq);
01881     <span class="keywordflow">return</span> ~0;
01882 }
01883 
01884 <span class="keyword">static</span> <span class="keywordtype">int</span> request_unlink_uploads(var_t *v, <span class="keywordtype">void</span> * arg)
01885 {
01886     dbg_err_if (v == NULL);
01887 
01888     u_unused_args(arg);
01889 
01890     <span class="keywordflow">if</span>(var_get_opaque(v) &amp;&amp; var_get_value(v))
01891     {   <span class="comment">/* it's a file var, unlink v-&gt;value */</span>
01892         u_remove(var_get_value(v));
01893     }
01894 
01895 err:
01896     <span class="keywordflow">return</span> 0;
01897 }
01898 
01899 <span class="keywordtype">int</span> request_free(request_t *rq)
01900 {
01901     <span class="keywordflow">if</span> (rq)
01902     {
01903         <span class="comment">/* free internal stuff */</span>
01904         request_clear_uri(rq);
01905 
01906         <span class="comment">/* verbatim client request line */</span>
01907         U_FREE(rq-&gt;cli_rq);
01908 
01909         <span class="keywordflow">if</span>(rq-&gt;header)
01910             header_free(rq-&gt;header);
01911 
01912         <span class="keywordflow">if</span>(rq-&gt;io)
01913             <a class="code" href="group__basic.html#ga14">io_free</a>(rq-&gt;io);
01914 
01915         <span class="keywordflow">if</span>(rq-&gt;uploads)
01916         {
01917             <span class="comment">/* unlink uploaded files (if any) */</span>
01918             vars_foreach(rq-&gt;uploads, request_unlink_uploads, NULL);
01919             vars_free(rq-&gt;uploads);
01920         }
01921 
01922         <span class="keywordflow">if</span>(rq-&gt;cookies)
01923             vars_free(rq-&gt;cookies);
01924 
01925         <span class="keywordflow">if</span>(rq-&gt;args_get)
01926             vars_free(rq-&gt;args_get);
01927 
01928         <span class="keywordflow">if</span>(rq-&gt;args_post)
01929             vars_free(rq-&gt;args_post);
01930 
01931         <span class="keywordflow">if</span>(rq-&gt;args)
01932             vars_free(rq-&gt;args);
01933 
01934         U_FREE(rq);
01935     }
01936 
01937     <span class="keywordflow">return</span> 0;
01938 }
01939 
01940 <span class="comment">/* save the local address struct (ip and port) in the request obj */</span>
01941 <span class="keywordtype">int</span> request_set_addr(request_t *rq, kaddr_t *addr)
01942 {
01943     dbg_return_if (rq == NULL, ~0);
01944     dbg_return_if (addr == NULL, ~0);
01945 
01946     memcpy(&amp;rq-&gt;local_addr, addr, <span class="keyword">sizeof</span>(kaddr_t));
01947 
01948     <span class="keywordflow">return</span> 0;
01949 }
01950 
01951 <span class="comment">/* save the peer address struct (ip and port) in the request obj */</span>
01952 <span class="keywordtype">int</span> request_set_peer_addr(request_t *rq, kaddr_t *addr)
01953 {
01954     dbg_return_if (rq == NULL, ~0);
01955     dbg_return_if (addr == NULL, ~0);
01956 
01957     memcpy(&amp;rq-&gt;peer_addr, addr, <span class="keyword">sizeof</span>(kaddr_t));
01958 
01959     <span class="keywordflow">return</span> 0;
01960 }
01961 
<a name="l01972"></a><a class="code" href="group__request.html#ga9">01972</a> kaddr_t* <a class="code" href="group__request.html#ga9">request_get_addr</a>(request_t *rq)
01973 {
01974     dbg_return_if (rq == NULL, NULL);
01975 
01976     <span class="keywordflow">return</span> &amp;rq-&gt;local_addr;
01977 }
01978 
<a name="l01989"></a><a class="code" href="group__request.html#ga10">01989</a> kaddr_t* <a class="code" href="group__request.html#ga10">request_get_peer_addr</a>(request_t *rq)
01990 {
01991     dbg_return_if (rq == NULL, NULL);
01992 
01993     <span class="keywordflow">return</span> &amp;rq-&gt;peer_addr;
01994 }
01995 
<a name="l02007"></a><a class="code" href="group__request.html#ga11">02007</a> header_t* <a class="code" href="group__request.html#ga11">request_get_header</a>(request_t *rq)
02008 {
02009     dbg_return_if (rq == NULL, NULL);
02010 
02011     <span class="keywordflow">return</span> rq-&gt;header;
02012 }
02013 
<a name="l02025"></a><a class="code" href="group__request.html#ga12">02025</a> field_t* <a class="code" href="group__request.html#ga12">request_get_field</a>(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
02026 {
02027     dbg_return_if (rq == NULL, NULL);
02028     dbg_return_if (name == NULL, NULL);
02029 
02030     <span class="keywordflow">return</span> header_get_field(rq-&gt;header, name);
02031 }
02032 
<a name="l02044"></a><a class="code" href="group__request.html#ga13">02044</a> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="group__request.html#ga13">request_get_field_value</a>(request_t *rq, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
02045 {
02046     dbg_return_if (rq == NULL, NULL);
02047     dbg_return_if (name == NULL, NULL);
02048 
02049     <span class="keywordflow">return</span> header_get_field_value(rq-&gt;header, name);
02050 }
02051 
02052 vhost_t* request_get_vhost(request_t *rq)
02053 {
02054     dbg_return_if (rq == NULL, NULL);
02055 
02056     <span class="keywordflow">return</span> rq-&gt;vhost; <span class="comment">/* may be NULL */</span>
02057 }
02058 
02059 <span class="keywordtype">int</span> request_set_vhost(request_t *rq, vhost_t *vhost)
02060 {
02061     dbg_return_if (rq == NULL, ~0);
02062 
02063     rq-&gt;vhost = vhost;
02064 
02065     <span class="keywordflow">return</span> 0;
02066 }
02067 
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


