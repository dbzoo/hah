<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: md5.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>md5.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: md5.c,v 1.4 2006/01/09 12:38:38 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">/*</span>
00012 <span class="comment">  Copyright (C) 1999, 2000, 2002 Aladdin Enterprises.  All rights reserved.</span>
00013 <span class="comment"></span>
00014 <span class="comment">  This software is provided 'as-is', without any express or implied</span>
00015 <span class="comment">  warranty.  In no event will the authors be held liable for any damages</span>
00016 <span class="comment">  arising from the use of this software.</span>
00017 <span class="comment"></span>
00018 <span class="comment">  Permission is granted to anyone to use this software for any purpose,</span>
00019 <span class="comment">  including commercial applications, and to alter it and redistribute it</span>
00020 <span class="comment">  freely, subject to the following restrictions:</span>
00021 <span class="comment"></span>
00022 <span class="comment">  1. The origin of this software must not be misrepresented; you must not</span>
00023 <span class="comment">     claim that you wrote the original software. If you use this software</span>
00024 <span class="comment">     in a product, an acknowledgment in the product documentation would be</span>
00025 <span class="comment">     appreciated but is not required.</span>
00026 <span class="comment">  2. Altered source versions must be plainly marked as such, and must not be</span>
00027 <span class="comment">     misrepresented as being the original software.</span>
00028 <span class="comment">  3. This notice may not be removed or altered from any source distribution.</span>
00029 <span class="comment"></span>
00030 <span class="comment">  L. Peter Deutsch</span>
00031 <span class="comment">  ghost@aladdin.com</span>
00032 <span class="comment"></span>
00033 <span class="comment"> */</span>
00034 <span class="comment">/* $Id: md5.c,v 1.4 2006/01/09 12:38:38 tat Exp $ */</span>
00035 <span class="comment">/*</span>
00036 <span class="comment">  Independent implementation of MD5 (RFC 1321).</span>
00037 <span class="comment"></span>
00038 <span class="comment">  This code implements the MD5 Algorithm defined in RFC 1321, whose</span>
00039 <span class="comment">  text is available at</span>
00040 <span class="comment">        http://www.ietf.org/rfc/rfc1321.txt</span>
00041 <span class="comment">  The code is derived from the text of the RFC, including the test suite</span>
00042 <span class="comment">  (section A.5) but excluding the rest of Appendix A.  It does not include</span>
00043 <span class="comment">  any code or documentation that is identified in the RFC as being</span>
00044 <span class="comment">  copyrighted.</span>
00045 <span class="comment"></span>
00046 <span class="comment">  The original and principal author of md5.c is L. Peter Deutsch</span>
00047 <span class="comment">  &lt;ghost@aladdin.com&gt;.  Other authors are noted in the change history</span>
00048 <span class="comment">  that follows (in reverse chronological order):</span>
00049 <span class="comment"></span>
00050 <span class="comment">  2002-09-13 dms move out any static byteorder check </span>
00051 <span class="comment">                 because dynamic one cost nothing</span>
00052 <span class="comment">  2002-04-13 lpd Clarified derivation from RFC 1321; now handles byte order</span>
00053 <span class="comment">        either statically or dynamically; added missing #include &lt;string.h&gt;</span>
00054 <span class="comment">        in library.</span>
00055 <span class="comment">  2002-03-11 lpd Corrected argument list for main(), and added int return</span>
00056 <span class="comment">        type, in test program and T value program.</span>
00057 <span class="comment">  2002-02-21 lpd Added missing #include &lt;stdio.h&gt; in test program.</span>
00058 <span class="comment">  2000-07-03 lpd Patched to eliminate warnings about "constant is</span>
00059 <span class="comment">        unsigned in ANSI C, signed in traditional"; made test program</span>
00060 <span class="comment">        self-checking.</span>
00061 <span class="comment">  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.</span>
00062 <span class="comment">  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5).</span>
00063 <span class="comment">  1999-05-03 lpd Original version.</span>
00064 <span class="comment"> */</span>
00065 
00066 <span class="preprocessor">#include &lt;string.h&gt;</span>
00067 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00068 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00069 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00070 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00071 <span class="preprocessor">#include &lt;klone/md5.h&gt;</span>
00072 
00073 
00074 <span class="preprocessor">#define T_MASK ((md5_word_t)~0)</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define T1 </span><span class="comment">/* 0xd76aa478 */</span> (T_MASK ^ 0x28955b87)
00076 <span class="preprocessor">#define T2 </span><span class="comment">/* 0xe8c7b756 */</span> (T_MASK ^ 0x173848a9)
00077 <span class="preprocessor">#define T3    0x242070db</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define T4 </span><span class="comment">/* 0xc1bdceee */</span> (T_MASK ^ 0x3e423111)
00079 <span class="preprocessor">#define T5 </span><span class="comment">/* 0xf57c0faf */</span> (T_MASK ^ 0x0a83f050)
00080 <span class="preprocessor">#define T6    0x4787c62a</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define T7 </span><span class="comment">/* 0xa8304613 */</span> (T_MASK ^ 0x57cfb9ec)
00082 <span class="preprocessor">#define T8 </span><span class="comment">/* 0xfd469501 */</span> (T_MASK ^ 0x02b96afe)
00083 <span class="preprocessor">#define T9    0x698098d8</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#define T10 </span><span class="comment">/* 0x8b44f7af */</span> (T_MASK ^ 0x74bb0850)
00085 <span class="preprocessor">#define T11 </span><span class="comment">/* 0xffff5bb1 */</span> (T_MASK ^ 0x0000a44e)
00086 <span class="preprocessor">#define T12 </span><span class="comment">/* 0x895cd7be */</span> (T_MASK ^ 0x76a32841)
00087 <span class="preprocessor">#define T13    0x6b901122</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#define T14 </span><span class="comment">/* 0xfd987193 */</span> (T_MASK ^ 0x02678e6c)
00089 <span class="preprocessor">#define T15 </span><span class="comment">/* 0xa679438e */</span> (T_MASK ^ 0x5986bc71)
00090 <span class="preprocessor">#define T16    0x49b40821</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define T17 </span><span class="comment">/* 0xf61e2562 */</span> (T_MASK ^ 0x09e1da9d)
00092 <span class="preprocessor">#define T18 </span><span class="comment">/* 0xc040b340 */</span> (T_MASK ^ 0x3fbf4cbf)
00093 <span class="preprocessor">#define T19    0x265e5a51</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#define T20 </span><span class="comment">/* 0xe9b6c7aa */</span> (T_MASK ^ 0x16493855)
00095 <span class="preprocessor">#define T21 </span><span class="comment">/* 0xd62f105d */</span> (T_MASK ^ 0x29d0efa2)
00096 <span class="preprocessor">#define T22    0x02441453</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#define T23 </span><span class="comment">/* 0xd8a1e681 */</span> (T_MASK ^ 0x275e197e)
00098 <span class="preprocessor">#define T24 </span><span class="comment">/* 0xe7d3fbc8 */</span> (T_MASK ^ 0x182c0437)
00099 <span class="preprocessor">#define T25    0x21e1cde6</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define T26 </span><span class="comment">/* 0xc33707d6 */</span> (T_MASK ^ 0x3cc8f829)
00101 <span class="preprocessor">#define T27 </span><span class="comment">/* 0xf4d50d87 */</span> (T_MASK ^ 0x0b2af278)
00102 <span class="preprocessor">#define T28    0x455a14ed</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#define T29 </span><span class="comment">/* 0xa9e3e905 */</span> (T_MASK ^ 0x561c16fa)
00104 <span class="preprocessor">#define T30 </span><span class="comment">/* 0xfcefa3f8 */</span> (T_MASK ^ 0x03105c07)
00105 <span class="preprocessor">#define T31    0x676f02d9</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#define T32 </span><span class="comment">/* 0x8d2a4c8a */</span> (T_MASK ^ 0x72d5b375)
00107 <span class="preprocessor">#define T33 </span><span class="comment">/* 0xfffa3942 */</span> (T_MASK ^ 0x0005c6bd)
00108 <span class="preprocessor">#define T34 </span><span class="comment">/* 0x8771f681 */</span> (T_MASK ^ 0x788e097e)
00109 <span class="preprocessor">#define T35    0x6d9d6122</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#define T36 </span><span class="comment">/* 0xfde5380c */</span> (T_MASK ^ 0x021ac7f3)
00111 <span class="preprocessor">#define T37 </span><span class="comment">/* 0xa4beea44 */</span> (T_MASK ^ 0x5b4115bb)
00112 <span class="preprocessor">#define T38    0x4bdecfa9</span>
00113 <span class="preprocessor"></span><span class="preprocessor">#define T39 </span><span class="comment">/* 0xf6bb4b60 */</span> (T_MASK ^ 0x0944b49f)
00114 <span class="preprocessor">#define T40 </span><span class="comment">/* 0xbebfbc70 */</span> (T_MASK ^ 0x4140438f)
00115 <span class="preprocessor">#define T41    0x289b7ec6</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#define T42 </span><span class="comment">/* 0xeaa127fa */</span> (T_MASK ^ 0x155ed805)
00117 <span class="preprocessor">#define T43 </span><span class="comment">/* 0xd4ef3085 */</span> (T_MASK ^ 0x2b10cf7a)
00118 <span class="preprocessor">#define T44    0x04881d05</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#define T45 </span><span class="comment">/* 0xd9d4d039 */</span> (T_MASK ^ 0x262b2fc6)
00120 <span class="preprocessor">#define T46 </span><span class="comment">/* 0xe6db99e5 */</span> (T_MASK ^ 0x1924661a)
00121 <span class="preprocessor">#define T47    0x1fa27cf8</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#define T48 </span><span class="comment">/* 0xc4ac5665 */</span> (T_MASK ^ 0x3b53a99a)
00123 <span class="preprocessor">#define T49 </span><span class="comment">/* 0xf4292244 */</span> (T_MASK ^ 0x0bd6ddbb)
00124 <span class="preprocessor">#define T50    0x432aff97</span>
00125 <span class="preprocessor"></span><span class="preprocessor">#define T51 </span><span class="comment">/* 0xab9423a7 */</span> (T_MASK ^ 0x546bdc58)
00126 <span class="preprocessor">#define T52 </span><span class="comment">/* 0xfc93a039 */</span> (T_MASK ^ 0x036c5fc6)
00127 <span class="preprocessor">#define T53    0x655b59c3</span>
00128 <span class="preprocessor"></span><span class="preprocessor">#define T54 </span><span class="comment">/* 0x8f0ccc92 */</span> (T_MASK ^ 0x70f3336d)
00129 <span class="preprocessor">#define T55 </span><span class="comment">/* 0xffeff47d */</span> (T_MASK ^ 0x00100b82)
00130 <span class="preprocessor">#define T56 </span><span class="comment">/* 0x85845dd1 */</span> (T_MASK ^ 0x7a7ba22e)
00131 <span class="preprocessor">#define T57    0x6fa87e4f</span>
00132 <span class="preprocessor"></span><span class="preprocessor">#define T58 </span><span class="comment">/* 0xfe2ce6e0 */</span> (T_MASK ^ 0x01d3191f)
00133 <span class="preprocessor">#define T59 </span><span class="comment">/* 0xa3014314 */</span> (T_MASK ^ 0x5cfebceb)
00134 <span class="preprocessor">#define T60    0x4e0811a1</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#define T61 </span><span class="comment">/* 0xf7537e82 */</span> (T_MASK ^ 0x08ac817d)
00136 <span class="preprocessor">#define T62 </span><span class="comment">/* 0xbd3af235 */</span> (T_MASK ^ 0x42c50dca)
00137 <span class="preprocessor">#define T63    0x2ad7d2bb</span>
00138 <span class="preprocessor"></span><span class="preprocessor">#define T64 </span><span class="comment">/* 0xeb86d391 */</span> (T_MASK ^ 0x14792c6e)
00139 
00140 
00141 <span class="keyword">static</span> <span class="keywordtype">void</span>
00142 md5_process(md5_state_t *pms, <span class="keyword">const</span> md5_byte_t *data <span class="comment">/*[64]*/</span>)
00143 {
00144     md5_word_t
00145         a = pms-&gt;abcd[0], b = pms-&gt;abcd[1],
00146         c = pms-&gt;abcd[2], d = pms-&gt;abcd[3];
00147     md5_word_t t;
00148     <span class="comment">/* Define storage for little-endian or both types of CPUs. */</span>
00149     md5_word_t xbuf[16];
00150     <span class="keyword">const</span> md5_word_t *X;
00151 
00152         <span class="comment">/*</span>
00153 <span class="comment">         * Determine dynamically whether this is a big-endian or</span>
00154 <span class="comment">         * little-endian machine, since we can use a more efficient</span>
00155 <span class="comment">         * algorithm on the latter.</span>
00156 <span class="comment">         */</span>
00157         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> w = 1;
00158 
00159         <span class="keywordflow">if</span> (*((<span class="keyword">const</span> md5_byte_t *)&amp;w)) <span class="comment">/* dynamic little-endian */</span>
00160         {
00161             <span class="comment">/*</span>
00162 <span class="comment">             * On little-endian machines, we can process properly aligned</span>
00163 <span class="comment">             * data without copying it.</span>
00164 <span class="comment">             */</span>
00165             <span class="keywordflow">if</span> (!((data - (<span class="keyword">const</span> md5_byte_t *)0) &amp; 3)) {
00166                 <span class="comment">/* data are properly aligned */</span>
00167                 X = (<span class="keyword">const</span> md5_word_t *)data;
00168             } <span class="keywordflow">else</span> {
00169                 <span class="comment">/* not aligned */</span>
00170                 memcpy(xbuf, data, 64);
00171                 X = xbuf;
00172             }
00173         }
00174         <span class="keywordflow">else</span>                        <span class="comment">/* dynamic big-endian */</span>
00175         {
00176             <span class="comment">/*</span>
00177 <span class="comment">             * On big-endian machines, we must arrange the bytes in the</span>
00178 <span class="comment">             * right order.</span>
00179 <span class="comment">             */</span>
00180             <span class="keyword">const</span> md5_byte_t *xp = data;
00181             <span class="keywordtype">int</span> i;
00182 
00183             X = xbuf;                <span class="comment">/* (dynamic only) */</span>
00184             <span class="keywordflow">for</span> (i = 0; i &lt; 16; ++i, xp += 4)
00185                 xbuf[i] = xp[0] + (xp[1] &lt;&lt; 8) + (xp[2] &lt;&lt; 16) + (xp[3] &lt;&lt; 24);
00186         }
00187 
00188 <span class="preprocessor">#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32 - (n))))</span>
00189 <span class="preprocessor"></span>
00190     <span class="comment">/* Round 1. */</span>
00191     <span class="comment">/* Let [abcd k s i] denote the operation</span>
00192 <span class="comment">       a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */</span>
00193 <span class="preprocessor">#define F(x, y, z) (((x) &amp; (y)) | (~(x) &amp; (z)))</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#define SET(a, b, c, d, k, s, Ti)\</span>
00195 <span class="preprocessor">  t = a + F(b,c,d) + X[k] + Ti;\</span>
00196 <span class="preprocessor">  a = ROTATE_LEFT(t, s) + b</span>
00197 <span class="preprocessor"></span>    <span class="comment">/* Do the following 16 operations. */</span>
00198     SET(a, b, c, d,  0,  7,  T1);
00199     SET(d, a, b, c,  1, 12,  T2);
00200     SET(c, d, a, b,  2, 17,  T3);
00201     SET(b, c, d, a,  3, 22,  T4);
00202     SET(a, b, c, d,  4,  7,  T5);
00203     SET(d, a, b, c,  5, 12,  T6);
00204     SET(c, d, a, b,  6, 17,  T7);
00205     SET(b, c, d, a,  7, 22,  T8);
00206     SET(a, b, c, d,  8,  7,  T9);
00207     SET(d, a, b, c,  9, 12, T10);
00208     SET(c, d, a, b, 10, 17, T11);
00209     SET(b, c, d, a, 11, 22, T12);
00210     SET(a, b, c, d, 12,  7, T13);
00211     SET(d, a, b, c, 13, 12, T14);
00212     SET(c, d, a, b, 14, 17, T15);
00213     SET(b, c, d, a, 15, 22, T16);
00214 <span class="preprocessor">#undef SET</span>
00215 <span class="preprocessor"></span>
00216      <span class="comment">/* Round 2. */</span>
00217      <span class="comment">/* Let [abcd k s i] denote the operation</span>
00218 <span class="comment">          a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */</span>
00219 <span class="preprocessor">#define G(x, y, z) (((x) &amp; (z)) | ((y) &amp; ~(z)))</span>
00220 <span class="preprocessor"></span><span class="preprocessor">#define SET(a, b, c, d, k, s, Ti)\</span>
00221 <span class="preprocessor">  t = a + G(b,c,d) + X[k] + Ti;\</span>
00222 <span class="preprocessor">  a = ROTATE_LEFT(t, s) + b</span>
00223 <span class="preprocessor"></span>     <span class="comment">/* Do the following 16 operations. */</span>
00224     SET(a, b, c, d,  1,  5, T17);
00225     SET(d, a, b, c,  6,  9, T18);
00226     SET(c, d, a, b, 11, 14, T19);
00227     SET(b, c, d, a,  0, 20, T20);
00228     SET(a, b, c, d,  5,  5, T21);
00229     SET(d, a, b, c, 10,  9, T22);
00230     SET(c, d, a, b, 15, 14, T23);
00231     SET(b, c, d, a,  4, 20, T24);
00232     SET(a, b, c, d,  9,  5, T25);
00233     SET(d, a, b, c, 14,  9, T26);
00234     SET(c, d, a, b,  3, 14, T27);
00235     SET(b, c, d, a,  8, 20, T28);
00236     SET(a, b, c, d, 13,  5, T29);
00237     SET(d, a, b, c,  2,  9, T30);
00238     SET(c, d, a, b,  7, 14, T31);
00239     SET(b, c, d, a, 12, 20, T32);
00240 <span class="preprocessor">#undef SET</span>
00241 <span class="preprocessor"></span>
00242      <span class="comment">/* Round 3. */</span>
00243      <span class="comment">/* Let [abcd k s t] denote the operation</span>
00244 <span class="comment">          a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */</span>
00245 <span class="preprocessor">#define H(x, y, z) ((x) ^ (y) ^ (z))</span>
00246 <span class="preprocessor"></span><span class="preprocessor">#define SET(a, b, c, d, k, s, Ti)\</span>
00247 <span class="preprocessor">  t = a + H(b,c,d) + X[k] + Ti;\</span>
00248 <span class="preprocessor">  a = ROTATE_LEFT(t, s) + b</span>
00249 <span class="preprocessor"></span>     <span class="comment">/* Do the following 16 operations. */</span>
00250     SET(a, b, c, d,  5,  4, T33);
00251     SET(d, a, b, c,  8, 11, T34);
00252     SET(c, d, a, b, 11, 16, T35);
00253     SET(b, c, d, a, 14, 23, T36);
00254     SET(a, b, c, d,  1,  4, T37);
00255     SET(d, a, b, c,  4, 11, T38);
00256     SET(c, d, a, b,  7, 16, T39);
00257     SET(b, c, d, a, 10, 23, T40);
00258     SET(a, b, c, d, 13,  4, T41);
00259     SET(d, a, b, c,  0, 11, T42);
00260     SET(c, d, a, b,  3, 16, T43);
00261     SET(b, c, d, a,  6, 23, T44);
00262     SET(a, b, c, d,  9,  4, T45);
00263     SET(d, a, b, c, 12, 11, T46);
00264     SET(c, d, a, b, 15, 16, T47);
00265     SET(b, c, d, a,  2, 23, T48);
00266 <span class="preprocessor">#undef SET</span>
00267 <span class="preprocessor"></span>
00268      <span class="comment">/* Round 4. */</span>
00269      <span class="comment">/* Let [abcd k s t] denote the operation</span>
00270 <span class="comment">          a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */</span>
00271 <span class="preprocessor">#define I(x, y, z) ((y) ^ ((x) | ~(z)))</span>
00272 <span class="preprocessor"></span><span class="preprocessor">#define SET(a, b, c, d, k, s, Ti)\</span>
00273 <span class="preprocessor">  t = a + I(b,c,d) + X[k] + Ti;\</span>
00274 <span class="preprocessor">  a = ROTATE_LEFT(t, s) + b</span>
00275 <span class="preprocessor"></span>     <span class="comment">/* Do the following 16 operations. */</span>
00276     SET(a, b, c, d,  0,  6, T49);
00277     SET(d, a, b, c,  7, 10, T50);
00278     SET(c, d, a, b, 14, 15, T51);
00279     SET(b, c, d, a,  5, 21, T52);
00280     SET(a, b, c, d, 12,  6, T53);
00281     SET(d, a, b, c,  3, 10, T54);
00282     SET(c, d, a, b, 10, 15, T55);
00283     SET(b, c, d, a,  1, 21, T56);
00284     SET(a, b, c, d,  8,  6, T57);
00285     SET(d, a, b, c, 15, 10, T58);
00286     SET(c, d, a, b,  6, 15, T59);
00287     SET(b, c, d, a, 13, 21, T60);
00288     SET(a, b, c, d,  4,  6, T61);
00289     SET(d, a, b, c, 11, 10, T62);
00290     SET(c, d, a, b,  2, 15, T63);
00291     SET(b, c, d, a,  9, 21, T64);
00292 <span class="preprocessor">#undef SET</span>
00293 <span class="preprocessor"></span>
00294      <span class="comment">/* Then perform the following additions. (That is increment each</span>
00295 <span class="comment">        of the four registers by the value it had before this block</span>
00296 <span class="comment">        was started.) */</span>
00297     pms-&gt;abcd[0] += a;
00298     pms-&gt;abcd[1] += b;
00299     pms-&gt;abcd[2] += c;
00300     pms-&gt;abcd[3] += d;
00301 }
00302 
00303 <span class="keywordtype">void</span>
00304 md5_init(md5_state_t *pms)
00305 {
00306     pms-&gt;count[0] = pms-&gt;count[1] = 0;
00307     pms-&gt;abcd[0] = 0x67452301;
00308     pms-&gt;abcd[1] = <span class="comment">/*0xefcdab89*/</span> T_MASK ^ 0x10325476;
00309     pms-&gt;abcd[2] = <span class="comment">/*0x98badcfe*/</span> T_MASK ^ 0x67452301;
00310     pms-&gt;abcd[3] = 0x10325476;
00311 }
00312 
00313 <span class="keywordtype">void</span>
00314 md5_append(md5_state_t *pms, <span class="keyword">const</span> md5_byte_t *data, <span class="keywordtype">int</span> nbytes)
00315 {
00316     <span class="keyword">const</span> md5_byte_t *p = data;
00317     <span class="keywordtype">int</span> left = nbytes;
00318     <span class="keywordtype">int</span> offset = (pms-&gt;count[0] &gt;&gt; 3) &amp; 63;
00319     md5_word_t nbits = (md5_word_t)(nbytes &lt;&lt; 3);
00320 
00321     <span class="keywordflow">if</span> (nbytes &lt;= 0)
00322         <span class="keywordflow">return</span>;
00323 
00324     <span class="comment">/* Update the message length. */</span>
00325     pms-&gt;count[1] += nbytes &gt;&gt; 29;
00326     pms-&gt;count[0] += nbits;
00327     <span class="keywordflow">if</span> (pms-&gt;count[0] &lt; nbits)
00328         pms-&gt;count[1]++;
00329 
00330     <span class="comment">/* Process an initial partial block. */</span>
00331     <span class="keywordflow">if</span> (offset) {
00332         <span class="keywordtype">int</span> copy = (offset + nbytes &gt; 64 ? 64 - offset : nbytes);
00333 
00334         memcpy(pms-&gt;buf + offset, p, copy);
00335         <span class="keywordflow">if</span> (offset + copy &lt; 64)
00336             <span class="keywordflow">return</span>;
00337         p += copy;
00338         left -= copy;
00339         md5_process(pms, pms-&gt;buf);
00340     }
00341 
00342     <span class="comment">/* Process full blocks. */</span>
00343     <span class="keywordflow">for</span> (; left &gt;= 64; p += 64, left -= 64)
00344         md5_process(pms, p);
00345 
00346     <span class="comment">/* Process a final partial block. */</span>
00347     <span class="keywordflow">if</span> (left)
00348         memcpy(pms-&gt;buf, p, left);
00349 }
00350 
00351 <span class="keywordtype">void</span>
00352 md5_finish(md5_state_t *pms, md5_byte_t digest[16])
00353 {
00354     <span class="keyword">static</span> <span class="keyword">const</span> md5_byte_t pad[64] = {
00355         0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00356         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00357         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00358         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
00359     };
00360     md5_byte_t data[8];
00361     <span class="keywordtype">int</span> i;
00362 
00363     <span class="comment">/* Save the length before padding. */</span>
00364     <span class="keywordflow">for</span> (i = 0; i &lt; 8; ++i)
00365         data[i] = (md5_byte_t)(pms-&gt;count[i &gt;&gt; 2] &gt;&gt; ((i &amp; 3) &lt;&lt; 3));
00366     <span class="comment">/* Pad to 56 bytes mod 64. */</span>
00367     md5_append(pms, pad, ((55 - (pms-&gt;count[0] &gt;&gt; 3)) &amp; 63) + 1);
00368     <span class="comment">/* Append the length. */</span>
00369     md5_append(pms, data, 8);
00370     <span class="keywordflow">for</span> (i = 0; i &lt; 16; ++i)
00371         digest[i] = (md5_byte_t)(pms-&gt;abcd[i &gt;&gt; 2] &gt;&gt; ((i &amp; 3) &lt;&lt; 3));
00372 }
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


