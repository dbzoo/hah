<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: rsfilter.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>rsfilter.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: rsfilter.c,v 1.14 2007/12/03 16:05:55 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;time.h&gt;</span>
00013 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00014 <span class="preprocessor">#include &lt;klone/request.h&gt;</span>
00015 <span class="preprocessor">#include &lt;<a class="code" href="response_8h.html">klone/response.h</a>&gt;</span>
00016 <span class="preprocessor">#include &lt;klone/session.h&gt;</span>
00017 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00018 <span class="preprocessor">#include &lt;klone/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;klone/codec.h&gt;</span>
00020 <span class="preprocessor">#include &lt;<a class="code" href="http_8h.html">klone/http.h</a>&gt;</span>
00021 <span class="preprocessor">#include &lt;<a class="code" href="response_8h.html">klone/response.h</a>&gt;</span>
00022 <span class="preprocessor">#include &lt;klone/rsfilter.h&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/ses_prv.h&gt;</span>
00024 
00025 <span class="comment">/* this filter prints the HTTP header before any body part of the web page. </span>
00026 <span class="comment"> * the first RFBUFSZ bytes (at most) of the response will be buffered to </span>
00027 <span class="comment"> * postpone the header printing (the header can be modified until filter flush)</span>
00028 <span class="comment"> */</span>
00029 
00030 <span class="keyword">enum</span> { 
00031     RFS_BUFFERING,
00032     RFS_FLUSHING
00033 };
00034 
00035 <span class="keyword">struct </span>response_filter_s
00036 {
00037     codec_t codec;          <span class="comment">/* must be the first item in the struct */</span>
00038     request_t *rq;
00039     response_t *rs;
00040     session_t *ss;
00041     <span class="keywordtype">int</span> state, feeded;
00042     <span class="keywordtype">char</span> buf[RFBUFSZ], *ptr;
00043     size_t off;
00044     io_t *iob;
00045 };
00046 
00047 <span class="keyword">static</span> <span class="keywordtype">int</span> rf_init_iob(response_filter_t *rf)
00048 {
00049     <span class="keywordtype">char</span> *h;
00050     size_t hsz, htell;
00051 
00052     dbg_err_if (rf == NULL);
00053     
00054     hsz = response_get_max_header_size(rf-&gt;rs) + rf-&gt;off;
00055 
00056     h = (<span class="keywordtype">char</span> *)u_zalloc(hsz);
00057     dbg_err_if(h == NULL);
00058 
00059     dbg_err_if(io_mem_create(h, hsz, 0, &amp;rf-&gt;iob));
00060 
00061     <span class="comment">/* write the header to the memory io_t */</span>
00062     response_print_header_to_io(rf-&gt;rs, rf-&gt;iob);
00063 
00064     <span class="keywordflow">if</span>(<a class="code" href="group__response.html#ga9">response_get_method</a>(rf-&gt;rs) != <a class="code" href="http_8h.html#a33a22">HM_HEAD</a>)
00065     {
00066         <span class="comment">/* append the rf-&gt;buf to the iob */</span>
00067         dbg_err_if(<a class="code" href="group__basic.html#ga19">io_write</a>(rf-&gt;iob, rf-&gt;buf, rf-&gt;off) &lt; 0);
00068     }
00069     dbg_err_if(<a class="code" href="group__basic.html#ga20">io_flush</a>(rf-&gt;iob));
00070 
00071     htell = <a class="code" href="group__basic.html#ga22">io_tell</a>(rf-&gt;iob);
00072 
00073     dbg_if(<a class="code" href="group__basic.html#ga14">io_free</a>(rf-&gt;iob));
00074     rf-&gt;iob = NULL;
00075 
00076     <span class="comment">/* create another in-memory io to read from it */</span>
00077     dbg_err_if(io_mem_create(h, htell, IO_MEM_FREE_BUF, &amp;rf-&gt;iob));
00078 
00079     <span class="keywordflow">return</span> 0;
00080 err:
00081     <span class="keywordflow">return</span> ~0;
00082 }
00083 
00084 <span class="keyword">static</span> <span class="keywordtype">int</span> rf_flush(codec_t *codec, <span class="keywordtype">char</span> *dst, size_t *dcount)
00085 {
00086     response_filter_t *rf = (response_filter_t*)codec;
00087     ssize_t c;
00088 
00089 
00090     dbg_err_if (codec == NULL);
00091     dbg_err_if (dst == NULL);
00092     dbg_err_if (dcount == NULL);
00093 
00094     <span class="keywordflow">if</span>(rf-&gt;state == RFS_BUFFERING)
00095     {
00096         rf-&gt;state = RFS_FLUSHING;
00097 
00098         <span class="comment">/* create a in-memory io_t and fill it with header and rf-&gt;buf */</span>
00099         dbg_err_if(rf_init_iob(rf));
00100     }
00101 
00102     <span class="keywordflow">if</span>(rf-&gt;iob)
00103     {
00104         dbg_err_if((c = <a class="code" href="group__basic.html#ga18">io_read</a>(rf-&gt;iob, dst, *dcount)) &lt; 0);
00105         <span class="keywordflow">if</span>(c == 0)
00106         { <span class="comment">/* eof */</span>
00107             <a class="code" href="group__basic.html#ga14">io_free</a>(rf-&gt;iob);
00108             rf-&gt;iob = NULL;
00109         } <span class="keywordflow">else</span> {
00110             *dcount = c;
00111             <span class="keywordflow">return</span> CODEC_FLUSH_CHUNK;
00112         }
00113     }
00114 
00115     <span class="keywordflow">return</span> CODEC_FLUSH_COMPLETE;
00116 err:
00117     <span class="keywordflow">return</span> -1;
00118 }
00119 
00120 <span class="keyword">static</span> ssize_t rf_transform(codec_t *codec, 
00121         <span class="keywordtype">char</span> *dst, size_t *dcount, 
00122         <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t src_sz)
00123 {
00124     response_filter_t *rf = (response_filter_t*)codec;
00125     size_t max;
00126     ssize_t c;
00127 
00128     dbg_err_if (codec == NULL);
00129     dbg_err_if (dst == NULL);
00130     dbg_err_if (dcount == NULL);
00131     dbg_err_if (src == NULL);
00132 
00133     rf-&gt;feeded = 1;
00134 
00135     <span class="comment">/* if this's a HEAD request don't print the body of the page */</span>
00136     <span class="keywordflow">if</span>(<a class="code" href="group__response.html#ga9">response_get_method</a>(rf-&gt;rs) == <a class="code" href="http_8h.html#a33a22">HM_HEAD</a>)
00137     {
00138         *dcount = 0;    <span class="comment">/* zero output byte written */</span>
00139         <span class="keywordflow">return</span> src_sz;  <span class="comment">/* all input bytes consumed */</span>
00140     }
00141 
00142     <span class="keywordflow">if</span>(rf-&gt;state == RFS_BUFFERING)
00143     {
00144         <span class="keywordflow">if</span>(rf-&gt;off + src_sz &lt; RFBUFSZ)
00145         {
00146             memcpy(rf-&gt;buf + rf-&gt;off, src, src_sz);
00147             rf-&gt;off += src_sz;
00148             *dcount = 0;    <span class="comment">/* zero output byte written */</span>
00149             <span class="keywordflow">return</span> src_sz;  <span class="comment">/* src_sz input byte consumed */</span>
00150         } <span class="keywordflow">else</span> {
00151             <span class="comment">/* the buffer is full, print the header and flush the buffer */</span>
00152             rf-&gt;state = RFS_FLUSHING;
00153 
00154             <span class="comment">/* here's the last chance to modify HTTP header so, if not already</span>
00155 <span class="comment">               set, add a session ID to the cookie list */</span>
00156             <span class="keywordflow">if</span>(rf-&gt;ss &amp;&amp; strlen(rf-&gt;ss-&gt;id) == 0)
00157                 dbg_err_if(session_priv_set_id(rf-&gt;ss, NULL));
00158 
00159             <span class="comment">/* create a in-memory io_t and fill it with header and rf-&gt;buf */</span>
00160             dbg_err_if(rf_init_iob(rf));
00161         }
00162     }
00163 
00164     <span class="keywordflow">if</span>(rf-&gt;iob)
00165     {
00166         dbg_err_if((c = <a class="code" href="group__basic.html#ga18">io_read</a>(rf-&gt;iob, dst, *dcount)) &lt; 0);
00167         <span class="keywordflow">if</span>(c == 0)
00168         { <span class="comment">/* eof */</span>
00169             <a class="code" href="group__basic.html#ga14">io_free</a>(rf-&gt;iob);
00170             rf-&gt;iob = NULL;
00171         } <span class="keywordflow">else</span> {
00172             *dcount = c;
00173             <span class="keywordflow">return</span> 0;
00174         }
00175     }
00176 
00177     <span class="comment">/* copyout the next data block */</span>
00178     max = MIN(*dcount, src_sz);
00179     memcpy(dst, src, max);
00180     *dcount = max;
00181     <span class="keywordflow">return</span> max;
00182 err:
00183     <span class="keywordflow">return</span> -1;
00184 }
00185 
00186 <span class="keyword">static</span> <span class="keywordtype">int</span> rf_free(codec_t *codec)
00187 {
00188     response_filter_t *rf;
00189 
00190     dbg_return_if (codec == NULL, 0);   <span class="comment">/* it's ok */</span>
00191 
00192     rf = (response_filter_t*)codec;
00193  
00194     <span class="keywordflow">if</span>(rf-&gt;iob)
00195         <a class="code" href="group__basic.html#ga14">io_free</a>(rf-&gt;iob);
00196 
00197     U_FREE(rf);
00198 
00199     <span class="keywordflow">return</span> 0;
00200 }
00201 
00202 <span class="keywordtype">int</span> response_filter_feeded(codec_t *codec)
00203 {
00204     response_filter_t *rf;
00205 
00206     dbg_return_if (codec == NULL, 0);   <span class="comment">/* it's ok */</span>
00207 
00208     rf = (response_filter_t*)codec;
00209 
00210     <span class="keywordflow">return</span> rf-&gt;feeded; <span class="comment">/* 1 if at least 1 byte has been written */</span>
00211 }
00212 
00213 <span class="keywordtype">int</span> response_filter_create(request_t *rq, response_t *rs, session_t *ss,
00214     codec_t **prf)
00215 {
00216     response_filter_t *rf = NULL;
00217 
00218     dbg_err_if (rs == NULL);
00219     dbg_err_if (prf == NULL);
00220     
00221     rf = u_zalloc(<span class="keyword">sizeof</span>(response_filter_t));
00222     dbg_err_if(rf == NULL);
00223 
00224     rf-&gt;rq = rq;
00225     rf-&gt;rs = rs;
00226     rf-&gt;ss = ss;
00227     rf-&gt;codec.transform = rf_transform;
00228     rf-&gt;codec.flush = rf_flush;
00229     rf-&gt;codec.free = rf_free;
00230     rf-&gt;ptr = rf-&gt;buf;
00231     rf-&gt;iob = NULL;
00232 
00233     *prf = (codec_t*)rf;
00234 
00235     <span class="keywordflow">return</span> 0;
00236 err:
00237     U_FREE(rf);
00238     <span class="keywordflow">return</span> ~0;
00239 }
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


