<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LibU: pwd.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>pwd.c</h1><div class="fragment"><pre>00001 <span class="comment">/* </span>
00002 <span class="comment"> * Copyright (c) 2005-2008 by KoanLogic s.r.l. - All rights reserved.  </span>
00003 <span class="comment"> */</span>
00004 
00005 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00006 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00007 <span class="preprocessor">#include &lt;u/libu_conf.h&gt;</span>
00008 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00009 <span class="preprocessor">#include &lt;toolbox/hmap.h&gt;</span>
00010 <span class="preprocessor">#include &lt;toolbox/pwd.h&gt;</span>
00011 
00012 <span class="comment">/* in-memory db */</span>
00013 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_db_new (u_pwd_t *pwd);
00014 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_db_term (u_pwd_t *pwd);
00015 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_db_load (u_pwd_t *pwd);
00016 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_db_push (u_pwd_t *pwd, u_pwd_rec_t *rec);
00017 <span class="keyword">static</span> <span class="keywordtype">void</span> __hmap_pwd_rec_free (u_hmap_o_t *obj);  <span class="comment">/* hook hmap free */</span>
00018 
00019 <span class="comment">/* misc */</span>
00020 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_load (u_pwd_t *pwd);
00021 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_need_reload (u_pwd_t *pwd);
00022 
00023 <span class="comment">/* u_pwd_rec_t */</span>
00024 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_rec_new (<span class="keyword">const</span> <span class="keywordtype">char</span> *user, <span class="keyword">const</span> <span class="keywordtype">char</span> *pass, 
00025         <span class="keyword">const</span> <span class="keywordtype">char</span> *opaque, u_pwd_rec_t **prec);
00026 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_retr_mem (u_pwd_t *pwd, <span class="keyword">const</span> <span class="keywordtype">char</span> *user, 
00027         u_pwd_rec_t **prec);
00028 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_retr_res (u_pwd_t *pwd, <span class="keyword">const</span> <span class="keywordtype">char</span> *user, 
00029         u_pwd_rec_t **prec);
00030 
00031 <span class="comment">/* res ops */</span>
00032 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_res_open (u_pwd_t *pwd);
00033 <span class="keyword">static</span> <span class="keywordtype">void</span> u_pwd_res_close (u_pwd_t *pwd);
00034 
00035 <span class="comment">/* file specialization */</span>
00036 <span class="keyword">static</span> <span class="keywordtype">int</span> __file_open (<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">void</span> **pfp);
00037 <span class="keyword">static</span> <span class="keywordtype">void</span> __file_close (<span class="keywordtype">void</span> *fp);
00038 <span class="keyword">static</span> <span class="keywordtype">char</span> *__file_load (<span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> size, <span class="keywordtype">void</span> *fp);
00039 <span class="keyword">static</span> <span class="keywordtype">int</span> __file_notify (<span class="keyword">const</span> <span class="keywordtype">char</span> *path, time_t last_update, 
00040         time_t *pnew_update);
00041 
00042 <span class="comment">/* a pwd instance context (will be passed along all u_pwd functions) */</span>
00043 <span class="keyword">struct </span>u_pwd_s
00044 {
00045     <span class="keywordtype">void</span> *res_handler;  <span class="comment">/* underlying storage resource: FILE*, io_t*, ... */</span>
00046     <span class="keywordtype">char</span> res_uri[U_FILENAME_MAX + 1];
00047 
00048     size_t hash_len;            <span class="comment">/* hash'd password length */</span>
00049     u_pwd_hash_cb_t cb_hash;    <span class="comment">/* hash function for password hiding */</span>
00050 
00051     u_pwd_open_cb_t cb_open;    <span class="comment">/* function for opening the db */</span>
00052     u_pwd_load_cb_t cb_load;    <span class="comment">/* function for getting db records one by one */</span>
00053     u_pwd_close_cb_t cb_close;  <span class="comment">/* function for opening the db */</span>
00054 
00055     u_pwd_notify_cb_t cb_notify;    <span class="comment">/* function for notifying changes in the </span>
00056 <span class="comment">                                       master copy */</span>
00057 
00058     time_t last_mod;    <span class="comment">/* timestamp of master db's last update */</span>
00059     <span class="keywordtype">int</span> in_memory;      <span class="comment">/* if set access is done via snapshot db */</span>
00060     u_hmap_t *db;       <span class="comment">/* in-memory master db snapshot */</span>
00061 };
00062 
00063 <span class="comment">/* each pwd line looks like this: "&lt;user&gt;:&lt;password&gt;[:opaque]\n":</span>
00064 <span class="comment"> * the following holds the line tokenization result */</span>
00065 <span class="keyword">struct </span>u_pwd_rec_s
00066 {
00067     <span class="keywordtype">char</span> *user;     <span class="comment">/* credential owner */</span>
00068     <span class="keywordtype">char</span> *pass;     <span class="comment">/* password (hashed or cleartext) */</span>
00069     <span class="keywordtype">char</span> *opaque;   <span class="comment">/* optional application specific data (e.g. PSK hint) */</span>
00070 };
00071 
<a name="l00095"></a><a class="code" href="group__pwd.html#ga0">00095</a> <span class="keywordtype">int</span> <a class="code" href="group__pwd.html#ga0">u_pwd_init</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *res_uri, u_pwd_open_cb_t cb_open, 
00096         u_pwd_load_cb_t cb_load, u_pwd_close_cb_t cb_close, 
00097         u_pwd_notify_cb_t cb_notify, u_pwd_hash_cb_t cb_hash, 
00098         size_t hash_len, <span class="keywordtype">int</span> in_memory, u_pwd_t **ppwd)
00099 {
00100     u_pwd_t *pwd;
00101    
00102     dbg_return_if (res_uri == NULL, ~0);
00103     dbg_return_if (cb_open == NULL, ~0);
00104     dbg_return_if (cb_load == NULL, ~0);
00105     <span class="comment">/* cb_close is non-mandatory */</span>
00106     <span class="comment">/* cb_notify is non-mandatory */</span>
00107     dbg_return_if (cb_hash &amp;&amp; !hash_len, ~0);
00108     dbg_return_if (ppwd == NULL, ~0);
00109 
00110     <span class="comment">/* make room for the instance context */</span>
00111     pwd = <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(u_pwd_t));
00112     dbg_err_sif (pwd == NULL);
00113 
00114     <span class="comment">/* copy in supplied attributes and methods */</span>
00115     pwd-&gt;res_handler = NULL;
00116     strlcpy(pwd-&gt;res_uri, res_uri, <span class="keyword">sizeof</span> pwd-&gt;res_uri);
00117 
00118     pwd-&gt;hash_len = hash_len;
00119     pwd-&gt;cb_hash = cb_hash;
00120     pwd-&gt;cb_open = cb_open;
00121     pwd-&gt;cb_load = cb_load;
00122     pwd-&gt;cb_close = cb_close;
00123     pwd-&gt;cb_notify = cb_notify;
00124     pwd-&gt;last_mod = 0;
00125     pwd-&gt;in_memory = in_memory;
00126     pwd-&gt;db = NULL;
00127 
00128     <span class="comment">/* NOTE: don't load to memory if requested (i.e. .in_memory != 0) here:</span>
00129 <span class="comment">     * it will be done at very first u_pwd_retr() via u_pwd_need_reload() */</span>
00130 
00131     *ppwd = pwd;
00132 
00133     <span class="keywordflow">return</span> 0;
00134 err:
00135     <a class="code" href="group__pwd.html#ga3">u_pwd_term</a>(pwd);
00136     <span class="keywordflow">return</span> ~0;
00137 }
00138 
<a name="l00149"></a><a class="code" href="group__pwd.html#ga1">00149</a> <span class="keywordtype">int</span> <a class="code" href="group__pwd.html#ga1">u_pwd_retr</a> (u_pwd_t *pwd, <span class="keyword">const</span> <span class="keywordtype">char</span> *user, u_pwd_rec_t **prec)
00150 {
00151     dbg_return_if (pwd == NULL, ~0);
00152     dbg_return_if (user == NULL, ~0);
00153     dbg_return_if (prec == NULL, ~0);
00154 
00155     <span class="comment">/* if in-memory snapshot is mantained, search there (in case on-storage</span>
00156 <span class="comment">     * image has changed it will be resync'd automatically) */</span>
00157     <span class="keywordflow">if</span> (pwd-&gt;in_memory)
00158         <span class="keywordflow">return</span> u_pwd_retr_mem(pwd, user, prec);
00159 
00160     <span class="keywordflow">return</span> u_pwd_retr_res(pwd, user, prec);
00161 }
00162 
<a name="l00172"></a><a class="code" href="group__pwd.html#ga2">00172</a> <span class="keywordtype">int</span> <a class="code" href="group__pwd.html#ga2">u_pwd_auth_user</a> (u_pwd_t *pwd, <span class="keyword">const</span> <span class="keywordtype">char</span> *user, <span class="keyword">const</span> <span class="keywordtype">char</span> *password)
00173 {
00174     <span class="keywordtype">int</span> rc;
00175     u_pwd_rec_t *rec = NULL;
00176     <span class="keywordtype">char</span> *__p = NULL, __pstack[U_PWD_LINE_MAX];
00177 
00178     dbg_return_if (password == NULL, ~0);
00179 
00180     <span class="comment">/* retrieve the pwd record */</span>
00181     dbg_err_if (<a class="code" href="group__pwd.html#ga1">u_pwd_retr</a>(pwd, user, &amp;rec));
00182 
00183     <span class="comment">/* hash if requested, otherwise do cleartext cmp */</span>
00184     <span class="keywordflow">if</span> (pwd-&gt;cb_hash)
00185     {
00186         <span class="comment">/* create a buffer that fits the specific hash function */</span>
00187         dbg_err_if ((__p = <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(pwd-&gt;hash_len)) == NULL);
00188         (<span class="keywordtype">void</span>) pwd-&gt;cb_hash(password, strlen(password), __p);
00189     }
00190     <span class="keywordflow">else</span>
00191     {
00192         (<span class="keywordtype">void</span>) strlcpy(__pstack, password, <span class="keyword">sizeof</span> __pstack);
00193         __p = __pstack;
00194     }
00195 
00196     rc = strcmp(__p, rec-&gt;pass);
00197 
00198     <span class="comment">/* free __p if on heap */</span>
00199     <span class="keywordflow">if</span> (__p &amp;&amp; (__p != __pstack))
00200         <a class="code" href="group__alloc.html#ga8">u_free</a>(__p);
00201 
00202     <span class="comment">/* rec ownership is ours only if hmap doesn't have it */</span>
00203     <span class="keywordflow">if</span> (!pwd-&gt;in_memory)
00204         <a class="code" href="group__pwd.html#ga5">u_pwd_rec_free</a>(pwd, rec);
00205 
00206     <span class="keywordflow">return</span> rc;
00207 err:
00208     <span class="keywordflow">if</span> (__p &amp;&amp; (__p != __pstack))
00209         <a class="code" href="group__alloc.html#ga8">u_free</a>(__p);
00210 
00211     <span class="keywordflow">if</span> (!pwd-&gt;in_memory &amp;&amp; rec)
00212         <a class="code" href="group__pwd.html#ga5">u_pwd_rec_free</a>(pwd, rec);
00213 
00214     <span class="keywordflow">return</span> ~0;
00215 }
00216 
<a name="l00224"></a><a class="code" href="group__pwd.html#ga3">00224</a> <span class="keywordtype">void</span> <a class="code" href="group__pwd.html#ga3">u_pwd_term</a> (u_pwd_t *pwd)
00225 {
00226     nop_return_if (pwd == NULL, );
00227 
00228     (<span class="keywordtype">void</span>) u_pwd_db_term(pwd);
00229 
00230     U_FREE(pwd);
00231 
00232     <span class="keywordflow">return</span>;
00233 }
00234 
<a name="l00248"></a><a class="code" href="group__pwd.html#ga4">00248</a> <span class="keywordtype">int</span> <a class="code" href="group__pwd.html#ga4">u_pwd_init_file</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *res_uri, u_pwd_hash_cb_t cb_hash, 
00249         size_t hash_len, <span class="keywordtype">int</span> in_memory, u_pwd_t **ppwd)
00250 {
00251     <span class="keywordflow">return</span> <a class="code" href="group__pwd.html#ga0">u_pwd_init</a> (res_uri, __file_open, __file_load, __file_close, 
00252         __file_notify, cb_hash, hash_len, in_memory, ppwd);
00253 }
00254 
<a name="l00264"></a><a class="code" href="group__pwd.html#ga5">00264</a> <span class="keywordtype">void</span> <a class="code" href="group__pwd.html#ga5">u_pwd_rec_free</a> (u_pwd_t *pwd, u_pwd_rec_t *rec)
00265 {
00266     dbg_return_if (pwd == NULL, );
00267     dbg_return_if (rec == NULL, );
00268 
00269     <span class="comment">/* only records coming from non hash-map'd pwd's shall be free'd */</span>
00270     nop_return_if (pwd-&gt;in_memory, );
00271 
00272     U_FREE(rec-&gt;user);
00273     U_FREE(rec-&gt;pass);
00274     U_FREE(rec-&gt;opaque);
00275 
00276     <a class="code" href="group__alloc.html#ga8">u_free</a>(rec);
00277 
00278     <span class="keywordflow">return</span>;
00279 }
00280 
<a name="l00288"></a><a class="code" href="group__pwd.html#ga6">00288</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__pwd.html#ga6">u_pwd_rec_get_user</a> (u_pwd_rec_t *rec)
00289 {
00290     dbg_return_if (rec == NULL, NULL);
00291     <span class="keywordflow">return</span> rec-&gt;user;
00292 }
00293 
<a name="l00301"></a><a class="code" href="group__pwd.html#ga7">00301</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__pwd.html#ga7">u_pwd_rec_get_password</a> (u_pwd_rec_t *rec)
00302 {
00303     dbg_return_if (rec == NULL, NULL);
00304     <span class="keywordflow">return</span> rec-&gt;pass;
00305 }
00306 
<a name="l00314"></a><a class="code" href="group__pwd.html#ga8">00314</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__pwd.html#ga8">u_pwd_rec_get_opaque</a> (u_pwd_rec_t *rec)
00315 {
00316     dbg_return_if (rec == NULL, NULL);
00317     <span class="keywordflow">return</span> rec-&gt;opaque;
00318 }
00319 
<a name="l00327"></a><a class="code" href="group__pwd.html#ga9">00327</a> <span class="keywordtype">int</span> <a class="code" href="group__pwd.html#ga9">u_pwd_in_memory</a> (u_pwd_t *pwd)
00328 {
00329     <span class="keywordflow">return</span> pwd-&gt;in_memory;
00330 }
00331 
00336 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_load (u_pwd_t *pwd)
00337 {
00338     dbg_return_if (pwd == NULL, ~0);
00339     dbg_return_if (!pwd-&gt;in_memory, ~0);
00340 
00341     <span class="comment">/* wipe away old snapshot */</span>
00342     <span class="keywordflow">if</span> (pwd-&gt;db)
00343         (<span class="keywordtype">void</span>) u_pwd_db_term(pwd);
00344     
00345     <span class="comment">/* create new hash map and load master db contents into it */</span>
00346     dbg_err_if (u_pwd_db_new(pwd));
00347     dbg_err_if (u_pwd_db_load(pwd));
00348 
00349     <span class="keywordflow">return</span> 0;
00350 err:
00351     <span class="keywordflow">return</span> ~0;
00352 }
00353 
00354 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_retr_res (u_pwd_t *pwd, <span class="keyword">const</span> <span class="keywordtype">char</span> *user, 
00355         u_pwd_rec_t **prec)
00356 {
00357     size_t lc, got_it = 0;
00358     <span class="keywordtype">char</span> ln[U_PWD_LINE_MAX], uu[U_PWD_LINE_MAX];
00359     <span class="keywordtype">char</span> *toks[3 + 1];  <span class="comment">/* line fmt is: "name:password[:opaque]\n" */</span>
00360     u_pwd_rec_t *rec = NULL;
00361 
00362     dbg_return_if (pwd-&gt;res_uri == NULL, ~0);
00363     dbg_return_if (pwd-&gt;cb_load == NULL, ~0);
00364     <span class="comment">/* cb_open consistency will be checked inside u_pwd_res_open */</span>
00365 
00366     <span class="comment">/* open master db */</span>
00367     dbg_err_if (u_pwd_res_open(pwd));
00368 
00369     <span class="comment">/* do suitable search string for strstr(3) */</span>
00370     <a class="code" href="group__misc.html#ga12">u_snprintf</a>(uu, <span class="keyword">sizeof</span> uu, <span class="stringliteral">"%s:"</span>, user);
00371     
00372     <span class="comment">/* read line by line */</span>
00373     <span class="keywordflow">for</span> (lc = 1; pwd-&gt;cb_load(ln, <span class="keyword">sizeof</span> ln, pwd-&gt;res_handler) != NULL; lc++)
00374     {
00375         <span class="comment">/* skip comments */</span>
00376         <span class="keywordflow">if</span> (ln[0] == <span class="charliteral">'#'</span>)
00377             <span class="keywordflow">continue</span>;
00378 
00379         <span class="comment">/* check if we're on user line, in case break the read loop... </span>
00380 <span class="comment">         * this is different from using the in-memory version in case an </span>
00381 <span class="comment">         * entry is duplicated: in-memory matches the last entry, here</span>
00382 <span class="comment">         * we would get the first one */</span>
00383         <span class="keywordflow">if</span> (strstr(ln, uu) == ln)
00384         {
00385             got_it = 1;
00386             <span class="keywordflow">break</span>;
00387         }
00388     }
00389 
00390     <span class="comment">/* check if we've reached here due to simple loop exhaustion */</span>
00391     dbg_err_ifm (!got_it, <span class="stringliteral">"user %s not found"</span>, user);
00392 
00393     <span class="comment">/* remove terminating \n if needed */</span>
00394     <span class="keywordflow">if</span> (ln[strlen(ln) - 1] == <span class="charliteral">'\n'</span>)
00395         ln[strlen(ln) - 1] = <span class="charliteral">'\0'</span>;
00396 
00397     <span class="comment">/* tokenize line */</span>
00398     dbg_err_ifm (<a class="code" href="group__misc.html#ga11">u_tokenize</a>(ln, <span class="stringliteral">":"</span>, toks, 3), 
00399             <span class="stringliteral">"bad syntax at line %zu (%s)"</span>, lc, ln);
00400 
00401     <span class="comment">/* create new record to be given back */</span>
00402     dbg_err_if (u_pwd_rec_new(toks[0], toks[1], toks[2], &amp;rec));
00403 
00404     <span class="comment">/* dispose resource handler (if a 'close' method has been set) */</span>
00405     u_pwd_res_close(pwd);
00406 
00407     <span class="comment">/* copy out */</span>
00408     *prec = rec;
00409 
00410     <span class="keywordflow">return</span> 0;
00411 err:
00412     <span class="keywordflow">if</span> (rec)
00413         <a class="code" href="group__pwd.html#ga5">u_pwd_rec_free</a>(pwd, rec);
00414 
00415     u_pwd_res_close(pwd);
00416 
00417     <span class="keywordflow">return</span> ~0;
00418 }
00419 
00420 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_res_open (u_pwd_t *pwd)
00421 {
00422     dbg_return_if (pwd-&gt;cb_open == NULL, ~0);
00423 
00424     <span class="keywordflow">if</span> (pwd-&gt;res_handler != NULL)
00425         warn(<span class="stringliteral">"non-NULL resource handler will be lost"</span>);
00426 
00427     pwd-&gt;res_handler = NULL;
00428 
00429     <span class="keywordflow">return</span> pwd-&gt;cb_open(pwd-&gt;res_uri, &amp;pwd-&gt;res_handler);
00430 }
00431 
00432 <span class="keyword">static</span> <span class="keywordtype">void</span> u_pwd_res_close (u_pwd_t *pwd)
00433 {
00434     nop_return_if (pwd-&gt;res_handler == NULL, );
00435     nop_return_if (pwd-&gt;cb_close == NULL, );
00436 
00437     pwd-&gt;cb_close(pwd-&gt;res_handler);
00438     pwd-&gt;res_handler = NULL;
00439     
00440     <span class="keywordflow">return</span>;
00441 }
00442 
00443 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_rec_new (<span class="keyword">const</span> <span class="keywordtype">char</span> *user, <span class="keyword">const</span> <span class="keywordtype">char</span> *pass, 
00444         <span class="keyword">const</span> <span class="keywordtype">char</span> *opaque, u_pwd_rec_t **prec)
00445 {
00446     u_pwd_rec_t *rec = NULL;
00447 
00448     dbg_return_if (user == NULL, ~0);
00449     dbg_return_if (pass == NULL, ~0);
00450     dbg_return_if (prec == NULL, ~0);
00451 
00452     rec = <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(u_pwd_rec_t));
00453     dbg_err_sif (rec == NULL);
00454 
00455     rec-&gt;user = <a class="code" href="group__misc.html#ga5">u_strdup</a>(user);
00456     dbg_err_sif (rec-&gt;user == NULL);
00457 
00458     rec-&gt;pass = <a class="code" href="group__misc.html#ga5">u_strdup</a>(pass);
00459     dbg_err_sif (rec-&gt;pass == NULL);
00460 
00461     <span class="comment">/* opaque field may be NULL */</span>
00462     <span class="keywordflow">if</span> (opaque)
00463     {
00464         rec-&gt;opaque = <a class="code" href="group__misc.html#ga5">u_strdup</a>(opaque);
00465         dbg_err_sif (rec-&gt;opaque == NULL);
00466     }
00467 
00468     *prec = rec;
00469 
00470     <span class="keywordflow">return</span> 0;
00471 err:
00472     <span class="keywordflow">if</span> (rec)
00473     {
00474         U_FREE(rec-&gt;user);
00475         U_FREE(rec-&gt;pass);
00476         U_FREE(rec-&gt;opaque);
00477         <a class="code" href="group__alloc.html#ga8">u_free</a>(rec);
00478     }
00479     <span class="keywordflow">return</span> ~0;
00480 }
00481 
00482 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_retr_mem (u_pwd_t *pwd, <span class="keyword">const</span> <span class="keywordtype">char</span> *user, 
00483         u_pwd_rec_t **prec)
00484 {
00485     u_hmap_o_t *hobj = NULL;
00486 
00487     dbg_return_if (pwd == NULL, ~0);
00488     dbg_return_if (user == NULL, ~0);
00489     dbg_return_if (prec == NULL, ~0);
00490 
00491     <span class="comment">/* on error keep on working with the old in-memory db */</span>
00492     dbg_ifb (u_pwd_need_reload(pwd))
00493         warn(<span class="stringliteral">"error reloading master pwd file: using stale cache"</span>);
00494 
00495     dbg_err_if (pwd-&gt;db == NULL);
00496     dbg_err_if (<a class="code" href="group__hmap.html#ga26">u_hmap_get</a>(pwd-&gt;db, user, &amp;hobj));
00497     *prec = (u_pwd_rec_t *) hobj-&gt;val;
00498 
00499     <span class="keywordflow">return</span> 0;
00500 err:
00501     <span class="keywordflow">return</span> ~0;
00502 }
00503 
00504 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_need_reload (u_pwd_t *pwd)
00505 {
00506     time_t update_timestamp;
00507 
00508     <span class="comment">/* if needed parameters are not set return immediately (no error) */</span>
00509     nop_return_if (!pwd-&gt;in_memory, 0);
00510     nop_return_if (pwd-&gt;cb_notify == NULL, 0);
00511 
00512     <span class="comment">/* in case no update has been notified return */</span>
00513     <span class="keywordflow">if</span> (!pwd-&gt;cb_notify(pwd-&gt;res_uri, pwd-&gt;last_mod, &amp;update_timestamp))
00514         <span class="keywordflow">return</span> 0;
00515 
00516     <span class="comment">/* update notified: set .last_mod */</span>
00517     pwd-&gt;last_mod = update_timestamp;
00518     
00519     <span class="comment">/* reload db to memory */</span>
00520     <span class="keywordflow">return</span> u_pwd_load(pwd);
00521 }
00522 
00523 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_db_new (u_pwd_t *pwd)
00524 {
00525     <a class="code" href="structu__hmap__opts__s.html">u_hmap_opts_t</a> hopts;
00526 
00527     dbg_return_if (pwd == NULL, ~0);
00528 
00529     <a class="code" href="group__hmap.html#ga32">u_hmap_opts_init</a>(&amp;hopts);
00530     hopts.<a class="code" href="structu__hmap__opts__s.html#o4">options</a> |= U_HMAP_OPTS_OWNSDATA;
00531     hopts.<a class="code" href="structu__hmap__opts__s.html#o7">f_free</a> = __hmap_pwd_rec_free;
00532             
00533     <span class="keywordflow">return</span> <a class="code" href="group__hmap.html#ga20">u_hmap_new</a>(&amp;hopts, &amp;pwd-&gt;db);
00534 }
00535 
00536 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_db_term (u_pwd_t *pwd)
00537 {
00538     dbg_return_if (pwd == NULL, ~0);
00539         
00540     nop_return_if (pwd-&gt;db == NULL, 0);
00541             
00542     <a class="code" href="group__hmap.html#ga29">u_hmap_free</a>(pwd-&gt;db);
00543     pwd-&gt;db = NULL;
00544 
00545     <span class="keywordflow">return</span> 0;
00546 }
00547 
00548 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_db_load (u_pwd_t *pwd)
00549 {
00550     size_t lc;
00551     <span class="keywordtype">char</span> ln[U_PWD_LINE_MAX];
00552     <span class="keywordtype">char</span> *toks[3 + 1];  <span class="comment">/* line fmt is: "name:password[:hint]\n" */</span>
00553     u_pwd_rec_t *rec = NULL;
00554     
00555     dbg_return_if (pwd-&gt;res_uri == NULL, ~0);
00556     dbg_return_if (pwd-&gt;cb_load == NULL, ~0);
00557     <span class="comment">/* cb_open and cb_close will be checked inside u_pwd_res_{open,close} */</span>
00558 
00559     <span class="comment">/* open master db */</span>
00560     dbg_err_if (u_pwd_res_open(pwd));
00561 
00562     <span class="keywordflow">for</span> (lc = 1; pwd-&gt;cb_load(ln, <span class="keyword">sizeof</span> ln, pwd-&gt;res_handler) != NULL; lc++)
00563     {
00564         <span class="comment">/* skip comment lines */</span>
00565         <span class="keywordflow">if</span> (ln[0] == <span class="charliteral">'#'</span>)
00566             <span class="keywordflow">continue</span>;
00567 
00568         <span class="comment">/* remove trailing \n */</span>
00569         <span class="keywordflow">if</span> (ln[strlen(ln) - 1] == <span class="charliteral">'\n'</span>)
00570             ln[strlen(ln) - 1] = <span class="charliteral">'\0'</span>;
00571 
00572         <span class="comment">/* tokenize line */</span>
00573         dbg_ifb (<a class="code" href="group__misc.html#ga11">u_tokenize</a>(ln, <span class="stringliteral">":"</span>, toks, 3))
00574         {
00575             info(<span class="stringliteral">"bad syntax at line %zu (%s)"</span>, lc, ln);
00576             <span class="keywordflow">continue</span>;
00577         }
00578 
00579         <span class="comment">/* create u_pwd_rec_t from tokens */</span>
00580         dbg_ifb (u_pwd_rec_new(toks[0], toks[1], toks[2], &amp;rec))
00581         {
00582             info(<span class="stringliteral">"could not create record for entry at line %zu"</span>, lc);
00583             <span class="keywordflow">continue</span>;
00584         }
00585 
00586         <span class="comment">/* push rec to db */</span>
00587         dbg_ifb (u_pwd_db_push(pwd, rec))
00588         {
00589             info(<span class="stringliteral">"could not push record for entry at line %zu"</span>, lc);
00590             <a class="code" href="group__pwd.html#ga5">u_pwd_rec_free</a>(pwd, rec), rec = NULL;
00591         }
00592 
00593         rec = NULL;
00594     }
00595 
00596     <span class="keywordflow">if</span> (rec)
00597         <a class="code" href="group__pwd.html#ga5">u_pwd_rec_free</a>(pwd, rec);
00598 
00599     u_pwd_res_close(pwd);
00600 
00601     <span class="keywordflow">return</span> 0;
00602 err:
00603     <span class="keywordflow">if</span> (rec)
00604         <a class="code" href="group__pwd.html#ga5">u_pwd_rec_free</a>(pwd, rec);
00605 
00606     u_pwd_res_close(pwd);
00607 
00608     <span class="keywordflow">return</span> ~0;
00609 }
00610 
00611 <span class="keyword">static</span> <span class="keywordtype">int</span> u_pwd_db_push (u_pwd_t *pwd, u_pwd_rec_t *rec)
00612 {
00613     <span class="keywordtype">char</span> *hkey = NULL;
00614     u_hmap_o_t *hobj = NULL;
00615 
00616     dbg_return_if (pwd-&gt;db == NULL, ~0);
00617     dbg_return_if (rec == NULL, ~0);
00618     dbg_return_if (rec-&gt;user == NULL, ~0);
00619 
00620     hkey = <a class="code" href="group__misc.html#ga5">u_strdup</a>(rec-&gt;user);
00621     dbg_err_if (hkey == NULL);
00622 
00623     hobj = <a class="code" href="group__hmap.html#ga35">u_hmap_o_new</a>((<span class="keywordtype">void</span> *) hkey, (<span class="keywordtype">void</span> *) rec);
00624     dbg_err_if (hobj == NULL);
00625 
00626     <span class="keywordflow">return</span> <a class="code" href="group__hmap.html#ga25">u_hmap_put</a>(pwd-&gt;db, hobj, NULL);
00627 err:
00628     <span class="keywordflow">if</span> (hkey)
00629         <a class="code" href="group__alloc.html#ga8">u_free</a>(hkey);
00630     <span class="keywordflow">if</span> (hobj)
00631         <a class="code" href="group__hmap.html#ga36">u_hmap_o_free</a>(hobj);
00632     <span class="keywordflow">return</span> ~0;
00633 }
00634 
00635 <span class="comment">/* </span>
00636 <span class="comment"> * prefabricated callbacks</span>
00637 <span class="comment"> */</span>
00638 <span class="keyword">static</span> <span class="keywordtype">int</span> __file_open (<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">void</span> **pfp)
00639 {
00640     FILE *fp = NULL;
00641 
00642     dbg_err_sif ((fp = fopen(path, <span class="stringliteral">"r"</span>)) == NULL);
00643 
00644     *pfp = (<span class="keywordtype">void</span> *) fp;
00645 
00646     <span class="keywordflow">return</span> 0;
00647 err:
00648     <span class="keywordflow">return</span> ~0;
00649 }
00650 
00651 <span class="keyword">static</span> <span class="keywordtype">void</span> __file_close (<span class="keywordtype">void</span> *fp)
00652 {
00653     dbg_return_sif (fclose((FILE *) fp), <span class="comment">/* nothing */</span>);
00654     <span class="keywordflow">return</span>;
00655 }
00656 
00657 <span class="keyword">static</span> <span class="keywordtype">char</span> *__file_load (<span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> size, <span class="keywordtype">void</span> *fp)
00658 {
00659     <span class="keywordflow">return</span> fgets(str, size, (FILE *) fp);
00660 }
00661 
00662 <span class="comment">/* in case file update has been detected, *pnew_update is also set */</span>
00663 <span class="keyword">static</span> <span class="keywordtype">int</span> __file_notify (<span class="keyword">const</span> <span class="keywordtype">char</span> *path, time_t last_update, 
00664         time_t *pnew_update)
00665 {
00666     <span class="keyword">struct </span>stat sb;
00667 
00668     dbg_err_if (path == NULL);
00669 
00670     dbg_err_sif (stat(path, &amp;sb));
00671 
00672     <span class="keywordflow">if</span> (sb.st_ctime != last_update)
00673     {
00674         *pnew_update = sb.st_ctime;
00675         <span class="keywordflow">return</span> 1;
00676     }
00677 
00678     <span class="comment">/* fall through (return false) */</span>
00679 err:
00680     <span class="keywordflow">return</span> 0;
00681 }
00682 
00683 <span class="comment">/* hmap glue */</span>
00684 <span class="keyword">static</span> <span class="keywordtype">void</span> __hmap_pwd_rec_free (u_hmap_o_t *obj)
00685 {
00686     u_pwd_t fake_pwd;
00687 
00688     fake_pwd.in_memory = 1;
00689 
00690     U_FREE(obj-&gt;key);
00691     <a class="code" href="group__pwd.html#ga5">u_pwd_rec_free</a>(&amp;fake_pwd, (u_pwd_rec_t *) obj-&gt;val);
00692 
00693     <span class="keywordflow">return</span>;
00694 }
</pre></div><hr>
<div>
  <div style="text-align:left">
    <a href="http://www.koanlogic.com/kl/cont/gb/html/products.html">&larr;Products</a>
  </div>
  <div style="text-align:center;">
    &copy; 2005-2008 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
  </div>
</div>

</body>
</html>
