<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LibU: fnmatch.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>fnmatch.c</h1><div class="fragment"><pre>00001 <span class="comment">/*      $NetBSD: fnmatch.c,v 1.20 2003/08/07 16:42:48 agc Exp $ */</span>
00002 
00003 <span class="comment">/*</span>
00004 <span class="comment"> * Copyright (c) 1989, 1993, 1994</span>
00005 <span class="comment"> *      The Regents of the University of California.  All rights reserved.</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * This code is derived from software contributed to Berkeley by</span>
00008 <span class="comment"> * Guido van Rossum.</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00011 <span class="comment"> * modification, are permitted provided that the following conditions</span>
00012 <span class="comment"> * are met:</span>
00013 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
00014 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
00015 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
00016 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
00017 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
00018 <span class="comment"> * 3. Neither the name of the University nor the names of its contributors</span>
00019 <span class="comment"> *    may be used to endorse or promote products derived from this software</span>
00020 <span class="comment"> *    without specific prior written permission.</span>
00021 <span class="comment"> *</span>
00022 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</span>
00023 <span class="comment"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
00024 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
00025 <span class="comment"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</span>
00026 <span class="comment"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
00027 <span class="comment"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
00028 <span class="comment"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
00029 <span class="comment"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
00030 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
00031 <span class="comment"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
00032 <span class="comment"> * SUCH DAMAGE.</span>
00033 <span class="comment"> */</span>
00034 
00035 <span class="comment">/*</span>
00036 <span class="comment"> * Function fnmatch() as specified in POSIX 1003.2-1992, section B.6.</span>
00037 <span class="comment"> * Compares a filename or pathname to a pattern.</span>
00038 <span class="comment"> */</span>
00039 
00040 <span class="preprocessor">#include &lt;missing/fnmatch.h&gt;</span>
00041 
00042 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00043 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00044 <span class="preprocessor">#include &lt;string.h&gt;</span>
00045 
00046 <span class="preprocessor">#define EOS     '\0'</span>
00047 <span class="preprocessor"></span>
00048 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *rangematch(<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
00049 
00050 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
00051 foldcase(<span class="keywordtype">int</span> ch, <span class="keywordtype">int</span> flags)
00052 {
00053 
00054         <span class="keywordflow">if</span> ((flags &amp; FNM_CASEFOLD) != 0 &amp;&amp; isupper(ch))
00055                 <span class="keywordflow">return</span> (tolower(ch));
00056         <span class="keywordflow">return</span> (ch);
00057 }
00058 
00059 <span class="preprocessor">#define FOLDCASE(ch, flags)     foldcase((unsigned char)(ch), (flags))</span>
00060 <span class="preprocessor"></span>
00061 <span class="keywordtype">int</span>
00062 fnmatch(pattern, string, flags)
00063         <span class="keyword">const</span> <span class="keywordtype">char</span> *pattern, *string;
00064         <span class="keywordtype">int</span> flags;
00065 {
00066         <span class="keyword">const</span> <span class="keywordtype">char</span> *stringstart;
00067         <span class="keywordtype">char</span> c, test;
00068 
00069         <span class="keywordflow">for</span> (stringstart = string;;)
00070                 <span class="keywordflow">switch</span> (c = FOLDCASE(*pattern++, flags)) {
00071                 <span class="keywordflow">case</span> EOS:
00072                         <span class="keywordflow">if</span> ((flags &amp; FNM_LEADING_DIR) &amp;&amp; *string == <span class="charliteral">'/'</span>)
00073                                 <span class="keywordflow">return</span> (0);
00074                         <span class="keywordflow">return</span> (*string == EOS ? 0 : FNM_NOMATCH);
00075                 <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
00076                         <span class="keywordflow">if</span> (*string == EOS)
00077                                 <span class="keywordflow">return</span> (FNM_NOMATCH);
00078                         <span class="keywordflow">if</span> (*string == <span class="charliteral">'/'</span> &amp;&amp; (flags &amp; FNM_PATHNAME))
00079                                 <span class="keywordflow">return</span> (FNM_NOMATCH);
00080                         <span class="keywordflow">if</span> (*string == <span class="charliteral">'.'</span> &amp;&amp; (flags &amp; FNM_PERIOD) &amp;&amp;
00081                             (string == stringstart ||
00082                             ((flags &amp; FNM_PATHNAME) &amp;&amp; *(string - 1) == <span class="charliteral">'/'</span>)))
00083                                 <span class="keywordflow">return</span> (FNM_NOMATCH);
00084                         ++string;
00085                         <span class="keywordflow">break</span>;
00086                 <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
00087                         c = FOLDCASE(*pattern, flags);
00088                         <span class="comment">/* Collapse multiple stars. */</span>
00089                         <span class="keywordflow">while</span> (c == <span class="charliteral">'*'</span>)
00090                                 c = FOLDCASE(*++pattern, flags);
00091 
00092                         <span class="keywordflow">if</span> (*string == <span class="charliteral">'.'</span> &amp;&amp; (flags &amp; FNM_PERIOD) &amp;&amp;
00093                             (string == stringstart ||
00094                             ((flags &amp; FNM_PATHNAME) &amp;&amp; *(string - 1) == <span class="charliteral">'/'</span>)))
00095                                 <span class="keywordflow">return</span> (FNM_NOMATCH);
00096 
00097                         <span class="comment">/* Optimize for pattern with * at end or before /. */</span>
00098                         <span class="keywordflow">if</span> (c == EOS) {
00099                                 <span class="keywordflow">if</span> (flags &amp; FNM_PATHNAME)
00100                                         <span class="keywordflow">return</span> ((flags &amp; FNM_LEADING_DIR) ||
00101                                             strchr(string, <span class="charliteral">'/'</span>) == NULL ?
00102                                             0 : FNM_NOMATCH);
00103                                 <span class="keywordflow">else</span>
00104                                         <span class="keywordflow">return</span> (0);
00105                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == <span class="charliteral">'/'</span> &amp;&amp; flags &amp; FNM_PATHNAME) {
00106                                 <span class="keywordflow">if</span> ((string = strchr(string, <span class="charliteral">'/'</span>)) == NULL)
00107                                         <span class="keywordflow">return</span> (FNM_NOMATCH);
00108                                 <span class="keywordflow">break</span>;
00109                         }
00110 
00111                         <span class="comment">/* General case, use recursion. */</span>
00112                         <span class="keywordflow">while</span> ((test = FOLDCASE(*string, flags)) != EOS) {
00113                                 <span class="keywordflow">if</span> (!fnmatch(pattern, string,
00114                                              flags &amp; ~FNM_PERIOD))
00115                                         <span class="keywordflow">return</span> (0);
00116                                 <span class="keywordflow">if</span> (test == <span class="charliteral">'/'</span> &amp;&amp; flags &amp; FNM_PATHNAME)
00117                                         <span class="keywordflow">break</span>;
00118                                 ++string;
00119                         }
00120                         <span class="keywordflow">return</span> (FNM_NOMATCH);
00121                 <span class="keywordflow">case</span> <span class="charliteral">'['</span>:
00122                         <span class="keywordflow">if</span> (*string == EOS)
00123                                 <span class="keywordflow">return</span> (FNM_NOMATCH);
00124                         <span class="keywordflow">if</span> (*string == <span class="charliteral">'/'</span> &amp;&amp; flags &amp; FNM_PATHNAME)
00125                                 <span class="keywordflow">return</span> (FNM_NOMATCH);
00126                         <span class="keywordflow">if</span> ((pattern =
00127                             rangematch(pattern, FOLDCASE(*string, flags),
00128                                        flags)) == NULL)
00129                                 <span class="keywordflow">return</span> (FNM_NOMATCH);
00130                         ++string;
00131                         <span class="keywordflow">break</span>;
00132                 <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
00133                         <span class="keywordflow">if</span> (!(flags &amp; FNM_NOESCAPE)) {
00134                                 <span class="keywordflow">if</span> ((c = FOLDCASE(*pattern++, flags)) == EOS) {
00135                                         c = <span class="charliteral">'\\'</span>;
00136                                         --pattern;
00137                                 }
00138                         }
00139                         <span class="comment">/* FALLTHROUGH */</span>
00140                 <span class="keywordflow">default</span>:
00141                         <span class="keywordflow">if</span> (c != FOLDCASE(*string++, flags))
00142                                 <span class="keywordflow">return</span> (FNM_NOMATCH);
00143                         <span class="keywordflow">break</span>;
00144                 }
00145         <span class="comment">/* NOTREACHED */</span>
00146 }
00147 
00148 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
00149 rangematch(pattern, test, flags)
00150         <span class="keyword">const</span> <span class="keywordtype">char</span> *pattern;
00151         <span class="keywordtype">int</span> test, flags;
00152 {
00153         <span class="keywordtype">int</span> negate, ok;
00154         <span class="keywordtype">char</span> c, c2;
00155 
00156         <span class="comment">/*</span>
00157 <span class="comment">         * A bracket expression starting with an unquoted circumflex</span>
00158 <span class="comment">         * character produces unspecified results (IEEE 1003.2-1992,</span>
00159 <span class="comment">         * 3.13.2).  This implementation treats it like '!', for</span>
00160 <span class="comment">         * consistency with the regular expression syntax.</span>
00161 <span class="comment">         * J.T. Conklin (conklin@ngai.kaleida.com)</span>
00162 <span class="comment">         */</span>
00163         <span class="keywordflow">if</span> ((negate = (*pattern == <span class="charliteral">'!'</span> || *pattern == <span class="charliteral">'^'</span>)) != 0)
00164                 ++pattern;
00165         
00166         <span class="keywordflow">for</span> (ok = 0; (c = FOLDCASE(*pattern++, flags)) != <span class="charliteral">']'</span>;) {
00167                 <span class="keywordflow">if</span> (c == <span class="charliteral">'\\'</span> &amp;&amp; !(flags &amp; FNM_NOESCAPE))
00168                         c = FOLDCASE(*pattern++, flags);
00169                 <span class="keywordflow">if</span> (c == EOS)
00170                         <span class="keywordflow">return</span> (NULL);
00171                 <span class="keywordflow">if</span> (*pattern == <span class="charliteral">'-'</span> 
00172                     &amp;&amp; (c2 = FOLDCASE(*(pattern+1), flags)) != EOS &amp;&amp;
00173                         c2 != <span class="charliteral">']'</span>) {
00174                         pattern += 2;
00175                         <span class="keywordflow">if</span> (c2 == <span class="charliteral">'\\'</span> &amp;&amp; !(flags &amp; FNM_NOESCAPE))
00176                                 c2 = FOLDCASE(*pattern++, flags);
00177                         <span class="keywordflow">if</span> (c2 == EOS)
00178                                 <span class="keywordflow">return</span> (NULL);
00179                         <span class="keywordflow">if</span> (c &lt;= test &amp;&amp; test &lt;= c2)
00180                                 ok = 1;
00181                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == test)
00182                         ok = 1;
00183         }
00184         <span class="keywordflow">return</span> (ok == negate ? NULL : pattern);
00185 }
</pre></div><hr>
<div>
  <div style="text-align:left">
    <a href="http://www.koanlogic.com/kl/cont/gb/html/products.html">&larr;Products</a>
  </div>
  <div style="text-align:center;">
    &copy; 2005-2008 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
  </div>
</div>

</body>
</html>
