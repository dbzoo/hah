<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: utils.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>utils.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: utils.c,v 1.58 2009/05/29 12:14:59 tho Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00013 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00014 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00015 <span class="preprocessor">#include &lt;time.h&gt;</span>
00016 <span class="preprocessor">#include &lt;string.h&gt;</span>
00017 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00018 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00019 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00020 <span class="preprocessor">#include &lt;dirent.h&gt;</span>
00021 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00022 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/os.h&gt;</span>
00024 <span class="preprocessor">#include &lt;klone/io.h&gt;</span>
00025 <span class="preprocessor">#include &lt;klone/codecs.h&gt;</span>
00026 <span class="preprocessor">#include &lt;klone/emb.h&gt;</span>
00027 <span class="preprocessor">#include &lt;klone/mime_map.h&gt;</span>
00028 <span class="preprocessor">#include &lt;klone/version.h&gt;</span>
00029 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00030 <span class="preprocessor">#ifdef HAVE_STRINGS</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;strings.h&gt;</span>
00032 <span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 <span class="keyword">enum</span> { LF = 0xA, CR = 0xD };
00035 
00036 <span class="keyword">static</span> <span class="keyword">struct </span>html_entities_s
00037 {
00038     <span class="keywordtype">int</span> s_char;
00039     <span class="keyword">const</span> <span class="keywordtype">char</span> *entity; 
00040 } entities[] = {
00041     { <span class="charliteral">'&amp;'</span>,  <span class="stringliteral">"&amp;amp;"</span>  },
00042     { <span class="charliteral">'"'</span>,  <span class="stringliteral">"&amp;quot;"</span> },
00043     { <span class="charliteral">'\''</span>, <span class="stringliteral">"&amp;#39;"</span>  }, 
00044     { <span class="charliteral">'&lt;'</span>,  <span class="stringliteral">"&amp;lt;"</span>   },
00045     { <span class="charliteral">'&gt;'</span>,  <span class="stringliteral">"&amp;gt;"</span>   },
00046     { 0, NULL     }
00047 };
00048 
00049 <span class="preprocessor">#ifdef OS_UNIX</span>
00050 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">int</span> u_sig_block(<span class="keywordtype">int</span> sig)
00051 {
00052     sigset_t sset;
00053 
00054     sigemptyset(&amp;sset);
00055     sigaddset(&amp;sset, sig);
00056     dbg_err_if(sigprocmask(SIG_BLOCK, &amp;sset, NULL));
00057 
00058     <span class="keywordflow">return</span> 0;
00059 err:
00060     <span class="keywordflow">return</span> ~0;
00061 }
00062 
00063 <span class="keyword">inline</span> <span class="keywordtype">int</span> u_sig_unblock(<span class="keywordtype">int</span> sig)
00064 {
00065     sigset_t sset;
00066 
00067     sigemptyset(&amp;sset);
00068     sigaddset(&amp;sset, sig);
00069     dbg_err_if(sigprocmask(SIG_UNBLOCK, &amp;sset, NULL));
00070 
00071     <span class="keywordflow">return</span> 0;
00072 err:
00073     <span class="keywordflow">return</span> ~0;
00074 }
00075 <span class="preprocessor">#endif </span><span class="comment">/* OS_UNIX */</span>
00076 
00077 
<a name="l00093"></a><a class="code" href="group__ut.html#ga29">00093</a> <span class="keywordtype">char</span> *<a class="code" href="group__ut.html#ga29">u_strnstr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keyword">const</span> <span class="keywordtype">char</span> *sub, size_t buflen)
00094 {
00095     ssize_t len = strlen(sub);
00096     ssize_t plen;
00097     <span class="keywordtype">char</span> *p;
00098 
00099     <span class="keywordflow">if</span> (*sub == 0)
00100         <span class="keywordflow">return</span> (<span class="keywordtype">char</span> *)buf;
00101 
00102     plen = buflen;
00103     <span class="keywordflow">for</span> (p = (<span class="keywordtype">char</span> *)buf; p != NULL; p = memchr(p + 1, *sub, plen - 1))
00104     {
00105         plen = buflen - (p - buf);
00106 
00107         <span class="keywordflow">if</span> (plen &lt; len)
00108             <span class="keywordflow">return</span> NULL;
00109 
00110         <span class="keywordflow">if</span> (strncmp(p, sub, len) == 0)
00111             <span class="keywordflow">return</span> (p);
00112     }
00113 
00114     <span class="keywordflow">return</span> NULL;
00115 }
00116 
<a name="l00133"></a><a class="code" href="group__ut.html#ga26">00133</a> <span class="keywordtype">int</span> <a class="code" href="group__ut.html#ga26">u_foreach_dir_item</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask,
00134     <span class="keywordtype">int</span> (*cb)(<span class="keyword">struct</span> dirent*, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">void</span>*), <span class="keywordtype">void</span>* arg)
00135 {
00136     <span class="keyword">struct </span>dirent *de;
00137     <span class="keyword">struct </span>stat st;
00138     DIR *dir = NULL;
00139     <span class="keywordtype">char</span> buf[U_FILENAME_MAX];
00140     <span class="keywordtype">int</span> rc;
00141 
00142     dbg_return_if (path == NULL, ~0);
00143     dbg_return_if (cb == NULL, ~0);
00144     
00145     <span class="comment">/* open the given directory */</span>
00146     dir = opendir(path);
00147     dbg_err_if(dir == NULL);
00148 
00149     <span class="keywordflow">while</span>((de = readdir(dir)) != NULL)
00150     {
00151         <span class="comment">/* skip . and .. dirs */</span>
00152         <span class="keywordflow">if</span>(!strcmp(de-&gt;d_name, <span class="stringliteral">"."</span>) || !strcmp(de-&gt;d_name, <span class="stringliteral">".."</span>))
00153             <span class="keywordflow">continue</span>;
00154 
00155         <span class="comment">/* build fully qualified name of this item */</span>
00156         dbg_err_if(u_snprintf(buf, U_FILENAME_MAX, <span class="stringliteral">"%s/%s"</span>, path, de-&gt;d_name));
00157 
00158         dbg_err_if( (rc = stat(buf, &amp;st)) == -1);
00159 
00160         <span class="comment">/* skip if its type is not in the requested mask */</span>
00161         <span class="keywordflow">if</span>(((st.st_mode &amp; S_IFMT) &amp; mask) != 0 &amp;&amp; cb(de, path, arg))
00162             <span class="keywordflow">break</span>;
00163     }
00164 
00165     closedir(dir);
00166 
00167     <span class="keywordflow">return</span> 0;
00168 err:
00169     <span class="keywordflow">return</span> ~0;
00170 }
00171 
<a name="l00186"></a><a class="code" href="group__ut.html#ga49">00186</a> <span class="keywordtype">int</span> <a class="code" href="group__ut.html#ga49">u_match_ext</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *extension)
00187 {
00188     <span class="keyword">const</span> <span class="keywordtype">char</span> *fn, *ext;
00189     size_t flen, elen;
00190 
00191     <span class="keywordflow">if</span>(filename == NULL || extension == NULL)
00192         <span class="keywordflow">return</span> 0;
00193 
00194     flen = strlen(filename);
00195     elen = strlen(extension);
00196     <span class="keywordflow">if</span>(elen &gt; flen)
00197         <span class="keywordflow">return</span> 0;
00198 
00199     fn = filename + flen - 1;
00200     ext = extension + elen - 1;
00201     <span class="keywordflow">for</span>( ; elen; --fn, --ext, --elen)
00202     {
00203         <span class="keywordflow">if</span>(tolower(*fn) != tolower(*ext))
00204             <span class="keywordflow">return</span> 0;
00205     }
00206     <span class="keywordflow">return</span> 1;
00207 }
00208 
00209 <span class="comment">/* hex char to int */</span>
00210 <span class="keyword">static</span> <span class="keywordtype">short</span> htoi(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c)
00211 {
00212     c = tolower(c);
00213 
00214     <span class="keywordflow">if</span>(c &gt;= <span class="charliteral">'0'</span> &amp;&amp; c &lt;= <span class="charliteral">'9'</span>)
00215         <span class="keywordflow">return</span> c - <span class="charliteral">'0'</span>;
00216     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c &gt;= <span class="charliteral">'a'</span> &amp;&amp; c &lt;= <span class="charliteral">'z'</span>)
00217         <span class="keywordflow">return</span> c - <span class="charliteral">'a'</span> + 10;
00218     <span class="keywordflow">else</span>
00219         <span class="keywordflow">return</span> 0;
00220 }
00221 
00222 
00223 <span class="keyword">static</span> ssize_t u_sqlncpy_encode(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen)
00224 {
00225     ssize_t wr = 0;
00226     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
00227 
00228     dbg_return_if (d == NULL, -1);
00229     dbg_return_if (s == NULL, -1);
00230 
00231     <span class="keywordflow">for</span>(; slen; --slen)
00232     {
00233         c = *d++ = *s++;
00234         wr++;
00235         <span class="keywordflow">if</span>(c == <span class="charliteral">'\''</span>) 
00236         {
00237             dbg_err_if(slen &lt; 2);
00238             *d++ = <span class="charliteral">'\''</span>;
00239             wr++;
00240             --slen;
00241         } 
00242     }
00243     *d = 0;
00244 
00245     <span class="keywordflow">return</span> wr;
00246 err:
00247     <span class="keywordflow">return</span> -1;
00248 }
00249 
00250 <span class="keyword">static</span> ssize_t u_sqlncpy_decode(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen)
00251 {
00252     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c, last = 0;
00253     ssize_t wr = 0;
00254     
00255     dbg_return_if (d == NULL, -1);
00256     dbg_return_if (s == NULL, -1);
00257 
00258     <span class="keywordflow">for</span>(; slen; --slen)
00259     {
00260         c = *s++;
00261         <span class="keywordflow">if</span>(c == <span class="charliteral">'\''</span> &amp;&amp; last == c) 
00262         {
00263             last = 0; 
00264             ; <span class="comment">/* skip */</span>
00265         } <span class="keywordflow">else</span> {
00266             *d++ = c;
00267             last = c;
00268             wr++;
00269         }
00270     }
00271     *d = 0;
00272 
00273     <span class="keywordflow">return</span> wr;
00274 }
00275 
<a name="l00292"></a><a class="code" href="group__ut.html#ga33">00292</a> ssize_t <a class="code" href="group__ut.html#ga33">u_sqlncpy</a>(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen, <span class="keywordtype">int</span> flags)
00293 {
00294     dbg_return_if (d == NULL, -1);
00295     dbg_return_if (s == NULL, -1);
00296 
00297     <span class="keywordflow">switch</span>(flags)
00298     {
00299     <span class="keywordflow">case</span> SQLCPY_ENCODE:
00300         <span class="keywordflow">return</span> u_sqlncpy_encode(d, s, slen);
00301     <span class="keywordflow">case</span> SQLCPY_DECODE:
00302         <span class="keywordflow">return</span> u_sqlncpy_decode(d, s, slen);
00303     <span class="keywordflow">default</span>:
00304         strncpy(d, s, slen);
00305         d[slen] = 0;
00306         <span class="keywordflow">return</span> slen;
00307     }
00308 
00309     <span class="keywordflow">return</span> -1;
00310 }
00311 
00312 <span class="keyword">static</span> ssize_t u_urlncpy_encode(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen)
00313 {
00314     <span class="keyword">const</span> <span class="keywordtype">char</span> hexc[] = <span class="stringliteral">"0123456789ABCDEF"</span>;
00315     ssize_t wr = 0;
00316     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
00317 
00318     dbg_return_if (d == NULL, -1);
00319     dbg_return_if (s == NULL, -1);
00320 
00321     <span class="keywordflow">for</span>(; slen; --slen)
00322     {
00323         c = *s++;
00324         <span class="keywordflow">if</span>(c == <span class="charliteral">' '</span>) {
00325             *d++ = <span class="charliteral">'+'</span>;
00326             wr++;
00327         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(isalnum(c) || c == <span class="charliteral">'_'</span> || c == <span class="charliteral">'-'</span> || c == <span class="charliteral">'.'</span>) {
00328             *d++ = c;
00329             wr++;
00330         } <span class="keywordflow">else</span> {
00331             *d++ = <span class="charliteral">'%'</span>;                                        
00332             *d++ = hexc[(c &gt;&gt; 4) &amp; 0xF];             
00333             *d++ = hexc[c &amp; 0xF];  
00334             wr += 3;
00335         }
00336     }
00337     *d = 0;
00338 
00339     <span class="keywordflow">return</span> wr;
00340 }
00341 
00342 <span class="keyword">static</span> ssize_t u_urlncpy_decode(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen)
00343 {
00344     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
00345     ssize_t wr = 0;
00346 
00347     dbg_return_if (d == NULL, -1);
00348     dbg_return_if (s == NULL, -1);
00349 
00350     <span class="keywordflow">for</span>(; slen; --slen, ++wr)
00351     {
00352         c = *s++;
00353         <span class="keywordflow">if</span>(c == <span class="charliteral">'%'</span>)
00354         {
00355             dbg_err_if(slen &lt; 2 || !isxdigit(s[0]) || !isxdigit(s[1]));
00356             c = htoi(s[0]) &lt;&lt; 4 | htoi(s[1]);
00357             <span class="comment">//dbg_err_if(c == 0);</span>
00358             *d++ = (<span class="keywordtype">char</span>)c;
00359             s += 2;
00360             slen -= 2;
00361         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == <span class="charliteral">'+'</span>) {
00362             *d++ = <span class="charliteral">' '</span>;
00363         } <span class="keywordflow">else</span> {
00364             *d++ = c;
00365         }
00366     }
00367     *d = 0;
00368 
00369     <span class="keywordflow">return</span> wr;
00370 err:
00371     <span class="keywordflow">return</span> -1;
00372 
00373 }
00374 
<a name="l00391"></a><a class="code" href="group__ut.html#ga30">00391</a> ssize_t <a class="code" href="group__ut.html#ga30">u_urlncpy</a>(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen, <span class="keywordtype">int</span> flags)
00392 {
00393     dbg_return_if (d == NULL, -1);
00394     dbg_return_if (s == NULL, -1);
00395 
00396     <span class="keywordflow">switch</span>(flags)
00397     {
00398     <span class="keywordflow">case</span> URLCPY_ENCODE:
00399         <span class="keywordflow">return</span> u_urlncpy_encode(d, s, slen);
00400     <span class="keywordflow">case</span> URLCPY_DECODE:
00401         <span class="keywordflow">return</span> u_urlncpy_decode(d, s, slen);
00402     <span class="keywordflow">default</span>:
00403         strncpy(d, s, slen);
00404         d[slen] = 0; <span class="comment">/* zero-term the string */</span>
00405         <span class="keywordflow">return</span> slen;
00406     }
00407 
00408     <span class="keywordflow">return</span> -1;
00409 }
00410 
00411 <span class="keyword">inline</span> <span class="keywordtype">char</span> u_tochex(<span class="keywordtype">int</span> n)
00412 {
00413         <span class="keywordflow">if</span>(n &gt; 15)
00414                 <span class="keywordflow">return</span> <span class="charliteral">'?'</span>;
00415         <span class="keywordflow">return</span> ( n &lt; 10 ? n + <span class="charliteral">'0'</span> : n-10 + <span class="charliteral">'a'</span>);
00416 }
00417 
00418 <span class="keyword">static</span> <span class="keywordtype">int</span> u_hex2ch(<span class="keywordtype">char</span> c)
00419 {
00420     <span class="keywordflow">if</span>(c &gt;= <span class="charliteral">'a'</span> &amp;&amp; c &lt;= <span class="charliteral">'z'</span>) 
00421         <span class="keywordflow">return</span> c - <span class="charliteral">'a'</span> + 10;
00422     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c &gt;= <span class="charliteral">'A'</span> &amp;&amp; c &lt;= <span class="charliteral">'Z'</span>)
00423         <span class="keywordflow">return</span> c - <span class="charliteral">'A'</span> + 10;
00424     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c &gt;= <span class="charliteral">'0'</span> &amp;&amp; c &lt;= <span class="charliteral">'9'</span>) 
00425         <span class="keywordflow">return</span> c - <span class="charliteral">'0'</span>;
00426     <span class="keywordflow">else</span>
00427         <span class="keywordflow">return</span> -1; <span class="comment">/* error */</span>
00428 }
00429 
00430 <span class="keywordtype">void</span> u_print_version_and_exit(<span class="keywordtype">void</span>)
00431 {
00432     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *vv = 
00433     <span class="stringliteral">"KLone %s - Copyright (c) 2005-2008 KoanLogic s.r.l. - "</span>
00434     <span class="stringliteral">"All rights reserved. \n\n"</span>;
00435 
00436     fprintf(stderr, vv, <a class="code" href="group__ut.html#ga27">klone_version</a>());
00437 
00438     exit(EXIT_FAILURE);
00439 }
00440 
00441 <span class="keyword">static</span> ssize_t u_hexncpy_decode(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen)
00442 {
00443         size_t i, t;
00444 
00445     dbg_return_if (d == NULL, -1);
00446     dbg_return_if (s == NULL, -1);
00447 
00448     <span class="comment">/* slen must be multiple of 2 */</span>
00449     dbg_err_if((slen % 2) != 0);
00450 
00451         <span class="keywordflow">for</span>(i = 0, t = 0; i &lt; slen; ++t, i += 2)
00452         d[t] = (u_hex2ch(s[i]) &lt;&lt; 4) | u_hex2ch(s[i+1]); 
00453 
00454     d[t] = 0; <span class="comment">/* zero-term */</span>
00455 
00456     <span class="keywordflow">return</span> t;
00457 err:
00458     <span class="keywordflow">return</span> -1;
00459 }
00460 
00461 <span class="keyword">static</span> ssize_t u_hexncpy_encode(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen)
00462 {
00463         size_t c, i, t;
00464 
00465     dbg_return_if (d == NULL, -1);
00466     dbg_return_if (s == NULL, -1);
00467 
00468         <span class="keywordflow">for</span>(i = 0, t = 0; i &lt; slen; ++i, t += 2)
00469         {
00470                 c = s[i];
00471         d[t]   = u_tochex((c &gt;&gt; 4) &amp; 0x0F);
00472         d[t+1] = u_tochex(c &amp; 0x0F);
00473         }
00474     d[t] = 0; <span class="comment">/* zero-term */</span>
00475 
00476     <span class="keywordflow">return</span> t;
00477 }
00478 
<a name="l00495"></a><a class="code" href="group__ut.html#ga31">00495</a> ssize_t <a class="code" href="group__ut.html#ga31">u_hexncpy</a>(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen, <span class="keywordtype">int</span> flags)
00496 {
00497     dbg_err_if (d == NULL);
00498     dbg_err_if (s == NULL);
00499 
00500     <span class="keywordflow">switch</span>(flags)
00501     {
00502     <span class="keywordflow">case</span> HEXCPY_ENCODE:
00503         <span class="keywordflow">return</span> u_hexncpy_encode(d, s, slen);
00504     <span class="keywordflow">case</span> HEXCPY_DECODE:
00505         <span class="keywordflow">return</span> u_hexncpy_decode(d, s, slen);
00506     <span class="keywordflow">default</span>:
00507         strncpy(d, s, slen);
00508         d[slen] = 0; <span class="comment">/* zero-term the string */</span>
00509         <span class="keywordflow">return</span> slen;
00510     }
00511 
00512 err:
00513     <span class="keywordflow">return</span> -1;
00514 }
00515 
00516 <span class="keyword">static</span> ssize_t u_htmlncpy_encode(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen)
00517 {
00518     <span class="keyword">struct </span>html_entities_s *p;
00519     <span class="keyword">const</span> <span class="keywordtype">char</span> *map[256];
00520     size_t elen;
00521     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
00522     ssize_t wr = 0;
00523 
00524     dbg_return_if (d == NULL, -1);
00525     dbg_return_if (s == NULL, -1);
00526 
00527     <span class="comment">/* build the map table (could be static but it wouldn't be thread-safe) */</span>
00528     memset(map, 0, <span class="keyword">sizeof</span>(map));
00529     <span class="keywordflow">for</span>(p = entities; p-&gt;s_char; ++p)
00530         map[p-&gt;s_char] = p-&gt;entity;
00531 
00532     <span class="keywordflow">while</span>(slen)
00533     {
00534         c = *s++;
00535         <span class="keywordflow">if</span>(map[c] == NULL)
00536         {
00537             *d++ = c;   <span class="comment">/* this char doesn't need encoding */</span>
00538             wr++;
00539             --slen;
00540         } <span class="keywordflow">else</span> {
00541             elen = strlen(map[c]);
00542             strcpy(d, map[c]); <span class="comment">/* append the entity */</span>
00543             --slen;
00544             d += elen;
00545             wr += elen;
00546         }
00547     }
00548     *d = 0;
00549 
00550     <span class="keywordflow">return</span> wr;
00551 }
00552 
00553 <span class="keyword">static</span> ssize_t u_htmlncpy_decode(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen)
00554 {
00555     <span class="keyword">struct </span>html_entities_s *p;
00556     <span class="keywordtype">char</span> *found, *after;
00557 
00558     dbg_return_if (d == NULL, -1);
00559     dbg_return_if (s == NULL, -1);
00560 
00561     strncpy(d, s, slen);
00562     d[slen] = 0;
00563 
00564     <span class="keywordflow">for</span>(p = entities; p-&gt;s_char; ++p)
00565     {
00566         <span class="keywordflow">while</span>((found = <a class="code" href="group__ut.html#ga28">u_stristr</a>(d, p-&gt;entity)) != NULL)
00567         {
00568             *found = p-&gt;s_char;
00569             after = found + strlen(p-&gt;entity);
00570             memmove(++found, after, 1 + strlen(after));
00571         }
00572     }
00573 
00574     <span class="keywordflow">return</span> strlen(d);
00575 }
00576 
<a name="l00593"></a><a class="code" href="group__ut.html#ga32">00593</a> ssize_t <a class="code" href="group__ut.html#ga32">u_htmlncpy</a>(<span class="keywordtype">char</span> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, size_t slen, <span class="keywordtype">int</span> flags)
00594 {
00595     dbg_err_if (d == NULL);
00596     dbg_err_if (s == NULL);
00597 
00598     <span class="keywordflow">switch</span>(flags)
00599     {
00600     <span class="keywordflow">case</span> HTMLCPY_ENCODE:
00601         <span class="keywordflow">return</span> u_htmlncpy_encode(d, s, slen);
00602     <span class="keywordflow">case</span> HTMLCPY_DECODE:
00603         <span class="keywordflow">return</span> u_htmlncpy_decode(d, s, slen);
00604     <span class="keywordflow">default</span>:
00605         strncpy(d, s, slen);
00606         d[slen] = 0; <span class="comment">/* zero-term */</span>
00607         <span class="keywordflow">return</span> slen;
00608     }
00609 err:
00610     <span class="keywordflow">return</span> -1;
00611 }
00612 
<a name="l00626"></a><a class="code" href="group__ut.html#ga28">00626</a> <span class="keywordtype">char</span> *<a class="code" href="group__ut.html#ga28">u_stristr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *string, <span class="keyword">const</span> <span class="keywordtype">char</span> *sub)
00627 {
00628     <span class="keyword">const</span> <span class="keywordtype">char</span> *p;
00629     size_t len;
00630 
00631     dbg_err_if (sub == NULL);
00632     dbg_err_if (string == NULL);
00633 
00634     len = strlen(sub);
00635     <span class="keywordflow">for</span>(p = string; *p; ++p)
00636     {
00637         <span class="keywordflow">if</span>(strncasecmp(p, sub, len) == 0)
00638             <span class="keywordflow">return</span> (<span class="keywordtype">char</span>*)p;
00639     }
00640 
00641 err: <span class="comment">/* fall through */</span>
00642     <span class="keywordflow">return</span> NULL;
00643 }
00644 
<a name="l00658"></a><a class="code" href="group__ut.html#ga27">00658</a> <span class="keywordtype">char</span>* <a class="code" href="group__ut.html#ga27">u_strnrchr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">char</span> c, size_t len)
00659 {
00660     <span class="keyword">register</span> <span class="keywordtype">int</span> i = len - 1;
00661 
00662     dbg_err_if (s == NULL);
00663     
00664     <span class="keywordflow">for</span>(; i &gt;= 0; --i)
00665         <span class="keywordflow">if</span>(s[i] == c)
00666             <span class="keywordflow">return</span> (<span class="keywordtype">char</span>*)s + i; <span class="comment">/* found */</span>
00667 err:
00668     <span class="keywordflow">return</span> NULL;
00669 }
00670 
<a name="l00685"></a><a class="code" href="group__ut.html#ga36">00685</a> <span class="keywordtype">int</span> <a class="code" href="group__ut.html#ga36">u_tmpfile_open</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *tmpdir, io_t **pio)
00686 {
00687     <span class="keyword">const</span> <span class="keywordtype">char</span> *pfx = <span class="stringliteral">"kloned_tmp_"</span>;
00688     <span class="keywordtype">char</span> *f_temp = NULL;
00689     <span class="keywordtype">char</span> tmp[U_FILENAME_MAX];
00690     io_t *io = NULL;
00691 
00692     dbg_return_if (pio == NULL, ~0);
00693 
00694     <span class="keywordflow">if</span>((f_temp = tempnam(tmpdir, pfx)) != NULL)
00695     {
00696         dbg_err_if (strlcpy(tmp, f_temp, <span class="keyword">sizeof</span> tmp) &gt;= <span class="keyword">sizeof</span> tmp); 
00697         u_free(f_temp), f_temp = NULL;
00698 
00699         dbg_err_if(<a class="code" href="group__ut.html#ga35">u_file_open</a>(tmp, O_CREAT | O_EXCL | O_RDWR, &amp;io));
00700 
00701         dbg_err_if(<a class="code" href="group__basic.html#ga16">io_name_set</a>(io, tmp));
00702 
00703         *pio = io;
00704 
00705         <span class="keywordflow">return</span> 0;
00706     }
00707 
00708 err:
00709     <span class="keywordflow">if</span>(io)
00710         <a class="code" href="group__basic.html#ga14">io_free</a>(io);
00711     <span class="keywordflow">if</span> (f_temp)
00712         u_free(f_temp);
00713     <span class="keywordflow">return</span> ~0;
00714 }
00715 
<a name="l00731"></a><a class="code" href="group__ut.html#ga35">00731</a> <span class="keywordtype">int</span> <a class="code" href="group__ut.html#ga35">u_file_open</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> flags, io_t **pio)
00732 {
00733     <span class="keywordtype">int</span> fmod = 0; <span class="comment">/* flags modifier */</span>
00734     <span class="keywordtype">int</span> fd;
00735 
00736 <span class="preprocessor">#ifdef OS_WIN</span>
00737 <span class="preprocessor"></span>    fmod = _O_BINARY;
00738 <span class="preprocessor">#endif</span>
00739 <span class="preprocessor"></span>    
00740     dbg_return_if (file == NULL, ~0);
00741     dbg_return_if (pio == NULL, ~0);
00742     
00743     fd = open(file, fmod | flags, 0600);
00744     dbg_err_if(fd &lt; 0);
00745 
00746     dbg_err_if(io_fd_create(fd, IO_FD_CLOSE, pio));
00747 
00748     <span class="comment">/* name the stream */</span>
00749     dbg_err_if(<a class="code" href="group__basic.html#ga16">io_name_set</a>(*pio, file));
00750 
00751     <span class="keywordflow">return</span> 0;
00752 err:
00753     <span class="keywordflow">if</span>(fd &lt; 0)
00754         dbg_strerror(errno);
00755     <span class="keywordflow">else</span>
00756         close(fd);
00757     <span class="keywordflow">return</span> ~0;
00758 }
00759 
<a name="l00773"></a><a class="code" href="group__ut.html#ga37">00773</a> <span class="keywordtype">int</span> <a class="code" href="group__ut.html#ga37">u_getline</a>(io_t *io, u_string_t *ln)
00774 {
00775     <span class="keyword">enum</span> { BUFSZ = 1024 };
00776     <span class="keywordtype">char</span> buf[BUFSZ];
00777     ssize_t len, rc;
00778 
00779     dbg_return_if (io == NULL, ~0);
00780     dbg_return_if (ln == NULL, ~0);
00781     
00782     u_string_clear(ln);
00783 
00784     <span class="keywordflow">while</span>((rc = len = <a class="code" href="group__basic.html#ga25">io_gets</a>(io, buf, BUFSZ)) &gt; 0)
00785     {
00786         dbg_err_if(u_string_append(ln, buf, --len));
00787         <span class="keywordflow">if</span>(!u_isnl(buf[len]))
00788             <span class="keywordflow">continue</span>; <span class="comment">/* line's longer the bufsz (or eof);get next line chunk */</span>
00789         <span class="keywordflow">else</span>
00790             <span class="keywordflow">break</span>;
00791     }
00792 
00793     dbg_if(rc &lt; 0); <span class="comment">/* io_gets error */</span>
00794 
00795 err:
00796     <span class="keywordflow">return</span> (rc &lt;= 0 ? ~0 : 0);
00797 }
00798 
<a name="l00812"></a><a class="code" href="group__ut.html#ga38">00812</a> <span class="keywordtype">int</span> <a class="code" href="group__ut.html#ga38">u_fgetline</a>(FILE *in, u_string_t *ln)
00813 {
00814     <span class="keyword">enum</span> { BUFSZ = 256 };
00815     <span class="keywordtype">char</span> buf[BUFSZ];
00816     size_t len;
00817 
00818     dbg_return_if (in == NULL, ~0);
00819     dbg_return_if (ln == NULL, ~0);
00820     
00821     u_string_clear(ln);
00822 
00823     <span class="keywordflow">while</span>(!ferror(in) &amp;&amp; !feof(in) &amp;&amp; fgets(buf, BUFSZ, in))
00824     {
00825         len = strlen(buf);
00826         dbg_err_if(u_string_append(ln, buf, len));
00827         <span class="keywordflow">if</span>(!u_isnl(buf[len-1]))
00828             <span class="keywordflow">continue</span>; <span class="comment">/* line's longer the bufsz, get next line chunk */</span>
00829         <span class="keywordflow">else</span>
00830             <span class="keywordflow">break</span>;
00831     }
00832 
00833     <span class="keywordflow">if</span>(ferror(in))
00834         dbg_strerror(errno);
00835 err:
00836     <span class="keywordflow">return</span> (u_string_len(ln) ? 0 : ~0);
00837 }
00838 
00839 <span class="keywordtype">int</span> u_printf_ccstr(io_t *o, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t sz)
00840 {
00841     <span class="keywordtype">char</span> prev, c = 0;
00842     <span class="keywordtype">int</span> pos = 0;
00843     size_t i;
00844 
00845     dbg_return_if (o == NULL, ~0);
00846     dbg_return_if (buf == NULL, ~0);
00847     
00848     <span class="keywordflow">for</span>(i = 0; i &lt; sz; ++i)
00849     {
00850         prev = c;
00851         c = buf[i];
00852         <span class="keywordflow">if</span>(pos++ == 0) <span class="comment">// first line char</span>
00853             <a class="code" href="group__basic.html#ga30">io_putc</a>(o, <span class="charliteral">'"'</span>);
00854         <span class="keywordflow">switch</span>(c)
00855         {
00856         <span class="keywordflow">case</span> CR:
00857             <span class="keywordflow">if</span>(prev != LF) 
00858             <a class="code" href="group__basic.html#ga28">io_printf</a>(o, <span class="stringliteral">"\\n\"\n"</span>);
00859             pos = 0;
00860             <span class="keywordflow">break</span>;
00861         <span class="keywordflow">case</span> LF:
00862             <span class="keywordflow">if</span>(prev != CR) 
00863             <a class="code" href="group__basic.html#ga28">io_printf</a>(o, <span class="stringliteral">"\\n\"\n"</span>);
00864             pos = 0;
00865             <span class="keywordflow">break</span>;
00866         <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
00867             <a class="code" href="group__basic.html#ga28">io_printf</a>(o, <span class="stringliteral">"\\\""</span>);
00868             <span class="keywordflow">break</span>;
00869         <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
00870             <a class="code" href="group__basic.html#ga28">io_printf</a>(o, <span class="stringliteral">"\\\\"</span>);
00871             <span class="keywordflow">break</span>;
00872         <span class="keywordflow">default</span>:
00873             <span class="keywordflow">if</span>(isprint(c))
00874                 <a class="code" href="group__basic.html#ga30">io_putc</a>(o, c);
00875             <span class="keywordflow">else</span> {
00876                 <a class="code" href="group__basic.html#ga28">io_printf</a>(o, <span class="stringliteral">"\\x%c%c"</span>, u_tochex((c &gt;&gt; 4) &amp; 0x0F),
00877                 u_tochex(c &amp; 0x0F));
00878             }
00879         }
00880     }
00881     <span class="keywordflow">if</span>(pos)
00882         <a class="code" href="group__basic.html#ga30">io_putc</a>(o, <span class="charliteral">'"'</span>);
00883 
00884     <span class="keywordflow">return</span> 0;
00885 }
00886 
<a name="l00897"></a><a class="code" href="group__ut.html#ga24">00897</a> <span class="keywordtype">int</span> <a class="code" href="group__ut.html#ga24">u_file_exists</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *fqn)
00898 {
00899     <span class="keyword">struct </span>stat st;
00900 
00901     dbg_return_if (fqn == NULL, 0);
00902     
00903     <span class="keywordflow">return</span> stat(fqn, &amp;st) == 0 &amp;&amp; S_ISREG(st.st_mode);
00904 }
00905 
<a name="l00920"></a><a class="code" href="group__ut.html#ga40">00920</a> <span class="keywordtype">void</span> <a class="code" href="group__ut.html#ga40">u_tohex</a>(<span class="keywordtype">char</span> *hex, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t sz)
00921 {
00922     size_t c, i, t;
00923 
00924     dbg_ifb (hex == NULL) <span class="keywordflow">return</span>;
00925     dbg_ifb (src == NULL) <span class="keywordflow">return</span>;
00926     
00927     <span class="keywordflow">for</span>(i = 0, t = 0; i &lt; sz; ++i, t += 2)
00928     {
00929         c = src[i];
00930         hex[t]   = u_tochex((c &gt;&gt; 4) &amp; 0x0F);
00931         hex[t+1] = u_tochex(c &amp; 0x0F);
00932     }
00933 
00934     hex[t] = 0; <span class="comment">/* zero-term */</span>
00935 }
00936 
<a name="l00951"></a><a class="code" href="group__ut.html#ga42">00951</a> <span class="keywordtype">int</span> <a class="code" href="group__ut.html#ga42">u_md5</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t sz, <span class="keywordtype">char</span> out[MD5_DIGEST_BUFSZ])
00952 {
00953     md5_state_t md5ctx;
00954     md5_byte_t md5_digest[16]; <span class="comment">/* binary digest */</span>
00955 
00956     dbg_return_if (buf == NULL, ~0);
00957     dbg_return_if (out == NULL, ~0);
00958     
00959     md5_init(&amp;md5ctx);
00960     md5_append(&amp;md5ctx, (md5_byte_t*)buf, sz);
00961     md5_finish(&amp;md5ctx, md5_digest);
00962 
00963     <a class="code" href="group__ut.html#ga40">u_tohex</a>(out, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)md5_digest, 16);
00964 
00965     out[MD5_DIGEST_LEN] = 0;
00966 
00967     <span class="keywordflow">return</span> 0;
00968 }
00969 
<a name="l00984"></a><a class="code" href="group__ut.html#ga43">00984</a> <span class="keywordtype">int</span> <a class="code" href="group__ut.html#ga43">u_md5io</a>(io_t *io, <span class="keywordtype">char</span> out[MD5_DIGEST_BUFSZ])
00985 {
00986     <span class="keyword">enum</span> { page_sz = 4096 };
00987     md5_state_t md5ctx;
00988     md5_byte_t md5_digest[16]; <span class="comment">/* binary digest */</span>
00989     <span class="keywordtype">char</span> buf[page_sz];
00990     size_t cnt;
00991 
00992     dbg_err_if (io == NULL);
00993     dbg_err_if (out == NULL);
00994 
00995     md5_init(&amp;md5ctx);
00996 
00997     <span class="keywordflow">while</span>((cnt = <a class="code" href="group__basic.html#ga18">io_read</a>(io, buf, page_sz)) &gt; 0)
00998         md5_append(&amp;md5ctx, (md5_byte_t*)buf, cnt);
00999 
01000     md5_finish(&amp;md5ctx, md5_digest);
01001 
01002     <a class="code" href="group__ut.html#ga40">u_tohex</a>(out, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)md5_digest, 16);
01003 
01004     out[MD5_DIGEST_LEN] = 0;
01005 
01006     <span class="keywordflow">return</span> 0;
01007 err:
01008     <span class="keywordflow">return</span> ~0;
01009 }
01010 
01011 <span class="keywordtype">int</span> u_signal(<span class="keywordtype">int</span> sig, u_sig_t handler)
01012 {
01013 <span class="preprocessor">#ifdef OS_WIN</span>
01014 <span class="preprocessor"></span>    dbg_err_if(signal(sig, handler) == SIG_ERR);
01015 <span class="preprocessor">#else</span>
01016 <span class="preprocessor"></span>    <span class="keyword">struct </span>sigaction action;
01017     sigset_t all;
01018 
01019     sigfillset(&amp;all); 
01020     action.sa_mask = all;
01021     action.sa_handler = handler;
01022 
01023     <span class="comment">/* disable child shell jobs notification */</span>
01024     action.sa_flags = (sig == SIGCHLD ? SA_NOCLDSTOP : 0);
01025 <span class="preprocessor">#ifdef HAVE_SA_RESTART</span>
01026 <span class="preprocessor"></span>    action.sa_flags |= SA_RESTART;
01027 <span class="preprocessor">#endif</span>
01028 <span class="preprocessor"></span>    dbg_err_if(sigaction(sig, &amp;action, (<span class="keyword">struct</span> sigaction *) 0));
01029 <span class="preprocessor">#endif</span>
01030 <span class="preprocessor"></span>
01031     <span class="keywordflow">return</span> 0;
01032 err:
01033     <span class="keywordflow">return</span> ~0;
01034 }                                                             
01035 
<a name="l01046"></a><a class="code" href="group__ut.html#ga48">01046</a> <span class="keyword">const</span> mime_map_t *<a class="code" href="group__ut.html#ga48">u_get_mime_map</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *file_name)
01047 {
01048     <span class="keywordtype">char</span> *ext;
01049     mime_map_t *mm;
01050 
01051     dbg_goto_if (file_name == NULL, notfound);
01052 
01053     <span class="keywordflow">if</span>((ext = strrchr(file_name, <span class="charliteral">'.'</span>)) != NULL)
01054     {
01055         ++ext; <span class="comment">/* skip '.' */</span>
01056         <span class="comment">/* FIXME binary search here */</span>
01057         <span class="keywordflow">for</span>(mm = mime_map; mm-&gt;ext &amp;&amp; mm-&gt;mime_type; ++mm)
01058         {
01059             <span class="keywordflow">if</span>(strcasecmp(mm-&gt;ext, ext) == 0)
01060                 <span class="keywordflow">return</span> mm;
01061         }
01062     }
01063 
01064 notfound:
01065     <span class="keywordflow">return</span> mime_map; <span class="comment">/* the first item is the default */</span>
01066 }
01067 
<a name="l01079"></a><a class="code" href="group__ut.html#ga47">01079</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__ut.html#ga47">u_guess_mime_type</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *file_name)
01080 {
01081     <span class="keywordtype">char</span> *ext;
01082     mime_map_t *mm;
01083 
01084     dbg_goto_if (file_name == NULL, notfound);
01085     
01086     <span class="keywordflow">if</span>((ext = strrchr(file_name, <span class="charliteral">'.'</span>)) != NULL)
01087     {
01088         ++ext; <span class="comment">/* skip '.' */</span>
01089         <span class="keywordflow">for</span>(mm = mime_map; mm-&gt;ext &amp;&amp; mm-&gt;mime_type; ++mm)
01090             <span class="keywordflow">if</span>(strcasecmp(mm-&gt;ext, ext) == 0)
01091                 <span class="keywordflow">return</span> mm-&gt;mime_type;
01092     }
01093 
01094 notfound:
01095     <span class="keywordflow">return</span> <span class="stringliteral">"application/octet-stream"</span>;
01096 }
01097 
01098 <span class="preprocessor">#ifdef HAVE_LIBZ</span>
01099 <span class="preprocessor"></span>
01114 <span class="keywordtype">int</span> u_io_unzip_copy(io_t *out, <span class="keyword">const</span> <span class="keywordtype">char</span> *data, size_t sz)
01115 {
01116     codec_t *zip = NULL;
01117     io_t *ios = NULL;
01118 
01119     dbg_return_if (out == NULL, ~0);
01120     dbg_return_if (data == NULL, ~0);
01121     
01122     <span class="comment">/* create an io_t around the HTML block */</span>
01123     dbg_err_if(io_mem_create((<span class="keywordtype">char</span>*)data, sz, 0, &amp;ios));
01124 
01125     <span class="comment">/* apply a gzip codec */</span>
01126     dbg_err_if(<a class="code" href="group__filters.html#ga2">codec_gzip_create</a>(GZIP_UNCOMPRESS, &amp;zip));
01127     dbg_err_if(<a class="code" href="group__basic.html#ga32">io_codec_add_tail</a>(ios, zip));
01128     zip = NULL; <span class="comment">/* io_free() will free the codec */</span>
01129 
01130     <span class="comment">/* pipe ios to out */</span>
01131     dbg_err_if(<a class="code" href="group__basic.html#ga24">io_pipe</a>(out, ios) &lt; 0);
01132 
01133     <a class="code" href="group__basic.html#ga14">io_free</a>(ios);
01134 
01135     <span class="keywordflow">return</span> 0;
01136 err:
01137     <span class="keywordflow">if</span>(zip)
01138         <a class="code" href="group__filters.html#ga9">codec_free</a>(zip);
01139     <span class="keywordflow">if</span>(ios)
01140         <a class="code" href="group__basic.html#ga14">io_free</a>(ios);
01141     <span class="keywordflow">return</span> ~0;
01142 }
01143 <span class="preprocessor">#endif</span>
01144 <span class="preprocessor"></span>
01145 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL</span>
01146 <span class="preprocessor"></span>
01168 <span class="keywordtype">int</span> u_cipher_encrypt(<span class="keyword">const</span> EVP_CIPHER *cipher, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *key, 
01169     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *iv, <span class="keywordtype">char</span> *dst, size_t *dcount, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t ssz)
01170 {
01171     EVP_CIPHER_CTX ctx;
01172     ssize_t dlen = 0;  <span class="comment">/* dst buffer length */</span>
01173     <span class="keywordtype">int</span> wr;
01174 
01175     dbg_return_if (cipher == NULL, ~0);
01176     dbg_return_if (key == NULL, ~0);
01177     dbg_return_if (iv == NULL, ~0);
01178     dbg_return_if (dcount == NULL, ~0);
01179     dbg_return_if (src == NULL, ~0);
01180     dbg_return_if (dst == NULL, ~0);
01181     
01182     <span class="comment">/* init the context */</span>
01183     EVP_CIPHER_CTX_init(&amp;ctx);
01184 
01185     <span class="comment">/* be sure that the cipher has been loaded */</span>
01186     EVP_add_cipher(cipher);
01187     
01188     dbg_err_if(!EVP_EncryptInit_ex(&amp;ctx, cipher, NULL, key, iv));
01189 
01190     dbg_err_if(!EVP_EncryptUpdate(&amp;ctx, dst, &amp;wr, src, ssz));
01191     dlen += wr;
01192     dst += wr;
01193 
01194     dbg_err_if(!EVP_EncryptFinal_ex(&amp;ctx, dst, &amp;wr));
01195     dlen += wr;
01196 
01197     *dcount = dlen; <span class="comment">/* # of bytes written to dst */</span>
01198 
01199     EVP_CIPHER_CTX_cleanup(&amp;ctx);
01200 
01201     <span class="keywordflow">return</span> 0;
01202 err:
01203     EVP_CIPHER_CTX_cleanup(&amp;ctx);
01204     <span class="keywordflow">return</span> ~0;
01205 }
01206 
01227 <span class="keywordtype">int</span> u_cipher_decrypt(<span class="keyword">const</span> EVP_CIPHER *cipher, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *key, 
01228     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *iv, <span class="keywordtype">char</span> *dst, size_t *dcount, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t ssz)
01229 {
01230     EVP_CIPHER_CTX ctx;
01231     ssize_t dlen = 0;  <span class="comment">/* dst buffer length */</span>
01232     <span class="keywordtype">int</span> wr;
01233 
01234     dbg_return_if (cipher == NULL, ~0);
01235     dbg_return_if (key == NULL, ~0);
01236     dbg_return_if (iv == NULL, ~0);
01237     dbg_return_if (dcount == NULL, ~0);
01238     dbg_return_if (src == NULL, ~0);
01239     dbg_return_if (dst == NULL, ~0);
01240 
01241     <span class="comment">/* init the context */</span>
01242     EVP_CIPHER_CTX_init(&amp;ctx);
01243 
01244     <span class="comment">/* be sure that the cipher has been loaded */</span>
01245     EVP_add_cipher(cipher);
01246     
01247     dbg_err_if(!EVP_DecryptInit_ex(&amp;ctx, cipher, NULL, key, iv));
01248 
01249     dbg_err_if(!EVP_DecryptUpdate(&amp;ctx, dst, &amp;wr, src, ssz));
01250     dlen += wr;
01251     dst += wr;
01252 
01253     dbg_err_if(!EVP_DecryptFinal_ex(&amp;ctx, dst, &amp;wr));
01254     dlen += wr;
01255 
01256     *dcount = dlen; <span class="comment">/* # of bytes written to dst */</span>
01257 
01258     EVP_CIPHER_CTX_cleanup(&amp;ctx);
01259 
01260     <span class="keywordflow">return</span> 0;
01261 err:
01262     EVP_CIPHER_CTX_cleanup(&amp;ctx);
01263     <span class="keywordflow">return</span> ~0;
01264 }
01265 
01266 <span class="preprocessor">#endif</span>
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


