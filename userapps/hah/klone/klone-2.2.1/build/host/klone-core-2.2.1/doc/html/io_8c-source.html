<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: io.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>io.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: io.c,v 1.43 2008/10/03 16:03:04 tho Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00013 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00014 <span class="preprocessor">#include &lt;klone/va.h&gt;</span>
00015 <span class="preprocessor">#include &lt;klone/io.h&gt;</span>
00016 <span class="preprocessor">#include &lt;klone/ioprv.h&gt;</span>
00017 <span class="preprocessor">#include &lt;klone/codec.h&gt;</span>
00018 
00019 <span class="keyword">enum</span> io_type_e <a class="code" href="group__basic.html#ga0">io_type</a>(io_t *io);
00020 
00021 <span class="keyword">enum</span> { 
00022     IO_RD_BUFSZ = 4096, 
00023     IO_WR_BUFSZ = 4096
00024 };
00025 
00026 <span class="preprocessor">#define IO_WBUF_AVAIL(io) (io-&gt;wbsz - io-&gt;wcount)</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define IO_WBUF_FULL(io) (io-&gt;wbsz == io-&gt;wcount)</span>
00028 <span class="preprocessor"></span>
00029 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> io_transform_codec_buffer(io_t *, codec_t *, <span class="keywordtype">char</span> *, 
00030         size_t *);
00031 
<a name="l00043"></a><a class="code" href="group__basic.html#ga0">00043</a> <span class="keyword">enum</span> io_type_e <a class="code" href="group__basic.html#ga0">io_type</a>(io_t *io)
00044 {
00045     <span class="keywordflow">return</span> io-&gt;type;
00046 }
00047 
<a name="l00061"></a><a class="code" href="group__basic.html#ga24">00061</a> ssize_t <a class="code" href="group__basic.html#ga24">io_pipe</a>(io_t *out, io_t *in)
00062 {
00063     <span class="keyword">enum</span> { BUFSZ = 4096 };
00064     <span class="keywordtype">char</span> buf[BUFSZ];
00065     size_t count = 0;   <span class="comment">/* # of bytes piped */</span>
00066     ssize_t c;
00067 
00068     dbg_err_if (out == NULL);
00069     dbg_err_if (in == NULL);
00070     
00071     <span class="keywordflow">for</span>(;;)
00072     {
00073         c = <a class="code" href="group__basic.html#ga18">io_read</a>(in, buf, BUFSZ);
00074         dbg_err_if(c &lt; 0);
00075         <span class="keywordflow">if</span>(c == 0)
00076             <span class="keywordflow">break</span>; <span class="comment">/* eof */</span>
00077 
00078         <span class="comment">/* write it out */</span>
00079         dbg_err_if(<a class="code" href="group__basic.html#ga19">io_write</a>(out, buf, c) &lt; 0);
00080 
00081         count += c;
00082     }
00083 
00084     <span class="keywordflow">return</span> count;
00085 err:
00086     <span class="keywordflow">return</span> -1;
00087 }
00088 
<a name="l00106"></a><a class="code" href="group__basic.html#ga15">00106</a> <span class="keywordtype">int</span> <a class="code" href="group__basic.html#ga15">io_dup</a>(io_t *io, io_t **pio)
00107 {
00108     dbg_return_if (io == NULL, ~0);
00109     dbg_return_if (pio == NULL, ~0);
00110     
00111     io-&gt;refcnt++;
00112 
00113     *pio = io;
00114 
00115     <span class="keywordflow">return</span> 0;
00116 }
00117 
<a name="l00132"></a><a class="code" href="group__basic.html#ga23">00132</a> ssize_t <a class="code" href="group__basic.html#ga23">io_copy</a>(io_t *out, io_t *in, size_t size)
00133 {
00134     <span class="keyword">enum</span> { BUFSZ = 4096 };
00135     <span class="keywordtype">char</span> buf[BUFSZ];
00136     size_t rem = size;
00137     ssize_t c;
00138 
00139     dbg_err_if (in == NULL);
00140     dbg_err_if (out == NULL);
00141 
00142     <span class="keywordflow">while</span>(rem)
00143     {
00144         c = <a class="code" href="group__basic.html#ga18">io_read</a>(in, buf, MIN(BUFSZ, rem));
00145         dbg_err_if(c &lt; 0);
00146         <span class="keywordflow">if</span>(c == 0)
00147             <span class="keywordflow">break</span>; <span class="comment">/* eof */</span>
00148 
00149         <span class="comment">/* write it out */</span>
00150         dbg_err_if(<a class="code" href="group__basic.html#ga19">io_write</a>(out, buf, c) &lt; 0);
00151 
00152         rem -= c;
00153     }
00154 
00155     <span class="keywordflow">return</span> size - rem;
00156 err:
00157     <span class="keywordflow">return</span> -1;
00158 }
00159 
00160 
<a name="l00175"></a><a class="code" href="group__basic.html#ga21">00175</a> ssize_t <a class="code" href="group__basic.html#ga21">io_seek</a>(io_t *io, size_t off)
00176 {
00177     dbg_err_if (io == NULL);
00178     dbg_err_if (<a class="code" href="group__basic.html#ga20">io_flush</a>(io));
00179 
00180     <span class="keywordflow">if</span>(io-&gt;seek)
00181         <span class="keywordflow">return</span> io-&gt;seek(io, off);
00182 err:
00183     <span class="keywordflow">return</span> -1;
00184 }
00185 
<a name="l00197"></a><a class="code" href="group__basic.html#ga22">00197</a> ssize_t <a class="code" href="group__basic.html#ga22">io_tell</a>(io_t *io)
00198 {
00199     dbg_err_if (io == NULL);
00200     dbg_err_if (<a class="code" href="group__basic.html#ga20">io_flush</a>(io));
00201 
00202     <span class="keywordflow">if</span>(io-&gt;tell)
00203         <span class="keywordflow">return</span> io-&gt;tell(io);
00204 err:
00205     <span class="keywordflow">return</span> -1;
00206 }
00207 
00208 <span class="comment">/* alloc the read buffer */</span>
00209 <span class="keyword">static</span> <span class="keywordtype">int</span> io_rbuf_alloc(io_t *io)
00210 {
00211     dbg_err_if (io == NULL);
00212     
00213     io-&gt;rbsz = IO_RD_BUFSZ; <span class="comment">/* set the buffer size */</span>
00214 
00215     <span class="comment">/* if a dup'd io_t already alloc'd a buffer then use it */</span>
00216     io-&gt;rbuf = (<span class="keywordtype">char</span>*)u_malloc(io-&gt;rbsz);
00217     dbg_err_if(io-&gt;rbuf == NULL);
00218     io-&gt;roff = 0;
00219 
00220     io-&gt;ubuf = (<span class="keywordtype">char</span>*)u_malloc(io-&gt;rbsz);
00221     dbg_err_if(io-&gt;ubuf == NULL);
00222 
00223     <span class="keywordflow">return</span> 0;
00224 err:
00225     <span class="keywordflow">return</span> ~0;
00226 }
00227 
00228 <span class="comment">/* alloc the write buffer */</span>
00229 <span class="keyword">static</span> <span class="keywordtype">int</span> io_wbuf_alloc(io_t *io)
00230 {
00231     dbg_err_if (io == NULL);
00232 
00233     io-&gt;wbsz = IO_WR_BUFSZ; <span class="comment">/* set the buffer size */</span>
00234 
00235     <span class="comment">/* if a dup'd io_t already alloc'd a buffer then use it */</span>
00236     io-&gt;wbuf = (<span class="keywordtype">char</span>*)u_malloc(io-&gt;wbsz);
00237     dbg_err_if(io-&gt;wbuf == NULL);
00238 
00239     <span class="keywordflow">return</span> 0;
00240 err:
00241     <span class="keywordflow">return</span> ~0;
00242 }
00243 
00244 <span class="keyword">static</span> ssize_t io_transform(io_t *io, codec_t *codec, 
00245     <span class="keywordtype">char</span> *dst, size_t *dcount, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t sz)
00246 {
00247     ssize_t c;
00248     size_t cavail, sdcount = *dcount; <span class="comment">/* saved dcount */</span>
00249 
00250     dbg_err_if (io == NULL);
00251     dbg_err_if (codec == NULL);
00252     dbg_err_if (src == NULL);
00253     dbg_err_if (dst == NULL);
00254     dbg_err_if (dcount == NULL);
00255 
00256     <span class="keywordflow">if</span>(codec == TAILQ_LAST(&amp;io-&gt;codec_chain, codec_chain_s))
00257     {
00258         <span class="comment">/* last codec in the chain */</span>
00259         c = codec-&gt;transform(codec, dst, dcount, src, sz); 
00260         dbg_err_if(c == 0 &amp;&amp; *dcount == 0);
00261         <span class="keywordflow">return</span> c;
00262     } <span class="keywordflow">else</span> {
00263         c = 0;
00264         <span class="keywordflow">do</span>
00265         {
00266             *dcount = sdcount;
00267             <span class="keywordflow">if</span>(codec-&gt;ccount)
00268                 dbg_err_if(io_transform_codec_buffer(io, codec, dst, dcount));
00269             <span class="keywordflow">else</span>
00270                 *dcount = 0; <span class="comment">/* no bytes written to 'dst' */</span>
00271 
00272             c = 0; <span class="comment">/* zero byte of 'src' consumed */</span>
00273             cavail = CODEC_BUFSZ - codec-&gt;ccount - codec-&gt;coff;
00274             <span class="keywordflow">if</span>(sz &amp;&amp; cavail)
00275             {
00276                 dbg_err_if((c = codec-&gt;transform(codec, 
00277                     codec-&gt;cbuf + codec-&gt;coff + codec-&gt;ccount, 
00278                     &amp;cavail, src, sz)) &lt; 0);
00279 
00280                 codec-&gt;ccount += cavail;
00281                 dbg_err_if(c == 0 &amp;&amp; cavail == 0);
00282             }
00283         } <span class="keywordflow">while</span>(c == 0 &amp;&amp; *dcount == 0 &amp;&amp; (codec-&gt;ccount || sz));
00284 
00285         <span class="keywordflow">return</span> c;
00286     }
00287 
00288 err:
00289     <span class="keywordflow">return</span> -1;
00290 }
00291 
00292 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> io_transform_codec_buffer(io_t *io, codec_t *codec, 
00293     <span class="keywordtype">char</span> *dst, size_t *dcount)
00294 {
00295     ssize_t ct;
00296 
00297     dbg_err_if (io == NULL);
00298     dbg_err_if (codec == NULL);
00299     dbg_err_if (dst == NULL);
00300     dbg_err_if (dcount == NULL);
00301 
00302     <span class="keywordflow">if</span>(codec-&gt;ccount)
00303     {
00304         dbg_err_if((ct = io_transform(io, TAILQ_NEXT(codec, np), 
00305             dst, dcount, codec-&gt;cbuf + codec-&gt;coff,codec-&gt;ccount)) &lt; 0);
00306 
00307         codec-&gt;ccount -= ct;
00308 
00309         <span class="keywordflow">if</span>(codec-&gt;ccount &gt; 0)
00310             codec-&gt;coff += ct;
00311         <span class="keywordflow">else</span>
00312             codec-&gt;coff = 0;
00313     }
00314 
00315     <span class="keywordflow">return</span> 0;
00316 err:
00317     <span class="keywordflow">return</span> ~0;
00318 }
00319 
00320 <span class="keyword">static</span> <span class="keyword">inline</span> ssize_t io_transfer(io_t *io, <span class="keywordtype">char</span> *dst, size_t *dcount, 
00321         <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t sz)
00322 {
00323     dbg_err_if (io == NULL);
00324     dbg_err_if (src == NULL);
00325     dbg_err_if (dst == NULL);
00326     dbg_err_if (dcount == NULL);
00327 
00328     <span class="keywordflow">if</span>(!TAILQ_EMPTY(&amp;io-&gt;codec_chain))
00329     {
00330         <span class="keywordflow">return</span> io_transform(io, TAILQ_FIRST(&amp;io-&gt;codec_chain), 
00331             dst, dcount, src, sz); 
00332     } <span class="keywordflow">else</span> {
00333         ssize_t wr = MIN(sz, *dcount); 
00334         memcpy(dst, src, wr);
00335         *dcount = wr;
00336         <span class="keywordflow">return</span> wr;
00337     }
00338 err:
00339     <span class="keywordflow">return</span> -1;
00340 }
00341 
00342 <span class="keyword">static</span> <span class="keywordtype">int</span> io_chain_flush_chunk(io_t *io, <span class="keywordtype">char</span> *dst, size_t *dcount)
00343 {
00344     <span class="keywordtype">int</span> er;
00345     codec_t *codec;
00346     size_t sz, sdcount;
00347 
00348     dbg_err_if (io == NULL);
00349     dbg_err_if (dst == NULL);
00350     dbg_err_if (dcount == NULL);
00351 
00352     sdcount = *dcount;
00353 
00354     TAILQ_FOREACH(codec, &amp;io-&gt;codec_chain, np)
00355     {
00356         *dcount = sdcount;
00357         <span class="keywordflow">if</span>(codec == TAILQ_LAST(&amp;io-&gt;codec_chain, codec_chain_s))
00358         {
00359             <span class="keywordflow">return</span> codec-&gt;flush(codec, dst, dcount);
00360         } <span class="keywordflow">else</span> {
00361             <span class="keywordflow">for</span>(;;)
00362             {
00363                 *dcount = sdcount;
00364                 <span class="keywordflow">if</span>(codec-&gt;ccount)
00365                 {
00366                     <span class="keywordtype">int</span> rc = io_transform_codec_buffer(io, codec, dst, dcount);
00367                     dbg_err_if (rc);
00368 
00369                     <span class="keywordflow">if</span>(*dcount)
00370                         <span class="keywordflow">return</span> CODEC_FLUSH_CHUNK; <span class="comment">/* call flush again */</span>
00371                 } <span class="keywordflow">else</span>
00372                     *dcount = 0; <span class="comment">/* no bytes written to 'dst' */</span>
00373 
00374                 sz = CODEC_BUFSZ - codec-&gt;ccount - codec-&gt;coff;
00375                 dbg_err_if((er = codec-&gt;flush(codec, 
00376                     codec-&gt;cbuf + codec-&gt;coff + codec-&gt;ccount, &amp;sz)) &lt; 0);
00377 
00378                 codec-&gt;ccount += sz;
00379 
00380                 <span class="keywordflow">if</span>(er == CODEC_FLUSH_COMPLETE &amp;&amp; codec-&gt;ccount == 0)
00381                     <span class="keywordflow">break</span>; <span class="comment">/* flush of this codec completed */</span>
00382             } <span class="comment">/* for */</span>
00383         }
00384     }
00385 
00386     <span class="keywordflow">return</span> CODEC_FLUSH_COMPLETE;
00387 err:
00388     <span class="keywordflow">return</span> -1;
00389 }
00390 
00391 <span class="keyword">static</span> <span class="keywordtype">int</span> io_chain_flush(io_t *io)
00392 {
00393     <span class="keyword">enum</span> { BUFSZ = 4096 };
00394     <span class="keywordtype">int</span> er;
00395     size_t sz, count;
00396     <span class="keywordtype">char</span> buf[BUFSZ], *ptr;
00397 
00398     dbg_err_if (io == NULL);
00399 
00400     <span class="keywordflow">for</span>(;;)
00401     {
00402         <span class="comment">/* note: we cannot write straight to the wbuf otherwise codec </span>
00403 <span class="comment">         * transform &amp; flush functions cannot call io_write safely; so we use </span>
00404 <span class="comment">         * a temp buffer and memcpy it to the wbuf after flushing */</span>
00405         count = BUFSZ;
00406         <span class="keywordflow">if</span>((er = io_chain_flush_chunk(io, buf, &amp;count)) == CODEC_FLUSH_COMPLETE)
00407             <span class="keywordflow">break</span>; <span class="comment">/* flush complete */</span>
00408         
00409         dbg_err_if(er &lt; 0);
00410 
00411         <span class="keywordflow">for</span>(ptr = buf; count; )
00412         {
00413             <span class="keywordflow">if</span>(IO_WBUF_FULL(io))
00414                 dbg_err_if(<a class="code" href="group__basic.html#ga20">io_flush</a>(io));
00415 
00416             sz = MIN(count, IO_WBUF_AVAIL(io));
00417             memcpy(io-&gt;wbuf + io-&gt;wcount, ptr, sz);
00418 
00419             count -= sz;
00420             io-&gt;wcount += sz;
00421             ptr += sz;
00422         }
00423     } 
00424 
00425     <span class="keywordflow">return</span> 0;
00426 err:
00427     <span class="keywordflow">return</span> ~0;
00428 }
00429 
<a name="l00442"></a><a class="code" href="group__basic.html#ga13">00442</a> <span class="keywordtype">int</span> <a class="code" href="group__basic.html#ga13">io_close</a>(io_t *io)
00443 {
00444     dbg_err_if (io == NULL);
00445 
00446     <span class="keywordflow">if</span>(io-&gt;close)
00447         dbg_err_if(io-&gt;close(io));
00448 
00449     <span class="keywordflow">return</span> 0;
00450 err:
00451     <span class="keywordflow">return</span> ~0;
00452 }
00453 
<a name="l00469"></a><a class="code" href="group__basic.html#ga14">00469</a> <span class="keywordtype">int</span> <a class="code" href="group__basic.html#ga14">io_free</a>(io_t *io)
00470 {
00471     dbg_err_if (io == NULL);
00472     dbg_err_if (io-&gt;refcnt == 0);
00473 
00474     <span class="comment">/* skip if this io_t has been dup'd and there are still one or more </span>
00475 <span class="comment">       references in use */</span>
00476     <span class="keywordflow">if</span>(--io-&gt;refcnt)
00477         <span class="keywordflow">return</span> 0;
00478 
00479     <span class="comment">/* flush, remove and free all codecs */</span>
00480     dbg_if(<a class="code" href="group__basic.html#ga33">io_codecs_remove</a>(io));
00481 
00482     dbg_if(<a class="code" href="group__basic.html#ga20">io_flush</a>(io));
00483 
00484     <span class="comment">/* flush and close the stream (but don't free it) */</span>
00485     dbg_if(<a class="code" href="group__basic.html#ga13">io_close</a>(io));
00486 
00487     <span class="comment">/* free per-type alloc'ed data */</span>
00488     <span class="keywordflow">if</span>(io-&gt;free)
00489         dbg_if(io-&gt;free(io));
00490 
00491     U_FREE(io-&gt;rbuf);
00492     U_FREE(io-&gt;ubuf);
00493     U_FREE(io-&gt;wbuf);
00494     U_FREE(io-&gt;name);
00495     U_FREE(io);
00496 
00497     <span class="keywordflow">return</span> 0;
00498 err:
00499     <span class="keywordflow">return</span> ~0;
00500 }
00501 
00502 <span class="comment">/* refill the read buffer */</span>
00503 <span class="keyword">static</span> ssize_t io_underflow(io_t *io)
00504 {
00505     ssize_t c;
00506     size_t sz;
00507 
00508     dbg_err_if (io == NULL);
00509 
00510     <span class="keywordflow">if</span>(io-&gt;rbuf == NULL)
00511         dbg_err_if(io_rbuf_alloc(io)); <span class="comment">/* alloc the read buffer */</span>
00512 
00513     <span class="keywordflow">while</span>(io-&gt;rcount == 0)
00514     {
00515         <span class="keywordflow">if</span>(io-&gt;ucount == 0)
00516         {   <span class="comment">/* fetch some bytes from the device and fill the rbuffer */</span>
00517             dbg_err_if((c = io-&gt;read(io, io-&gt;ubuf, io-&gt;rbsz)) &lt; 0);
00518             <span class="keywordflow">if</span>(c == 0)
00519             {   <span class="comment">/* eof, try to get some buffered (already transformed) bytes </span>
00520 <span class="comment">                   from the codec */</span>
00521                 <span class="keywordflow">if</span>(!TAILQ_EMPTY(&amp;io-&gt;codec_chain))
00522                 {
00523                     sz = io-&gt;rbsz;
00524                     c = io_chain_flush_chunk(io, io-&gt;rbuf, &amp;sz);
00525                     dbg_err_if(c &lt; 0);
00526                     io-&gt;rcount += sz;
00527                     io-&gt;roff = 0;
00528                     <span class="keywordflow">if</span>(c == 0)
00529                         io-&gt;eof++;
00530                 }
00531                 <span class="keywordflow">break</span>;
00532             }
00533             io-&gt;ucount += c;
00534         }
00535 
00536         <span class="comment">/* transform all data in the buffer */</span>
00537         sz = io-&gt;rbsz - io-&gt;rcount;
00538         dbg_err_if((c = io_transfer(io, io-&gt;rbuf, &amp;sz, 
00539             io-&gt;ubuf + io-&gt;uoff, io-&gt;ucount)) &lt; 0);
00540         dbg_err_if(c &lt; 0);
00541         dbg_err_if(c == 0 &amp;&amp; sz == 0);
00542         io-&gt;ucount -= c;
00543         <span class="keywordflow">if</span>(io-&gt;ucount == 0)
00544             io-&gt;uoff = 0;
00545         <span class="keywordflow">else</span>
00546             io-&gt;uoff += c;
00547 
00548         io-&gt;rcount = sz;
00549         io-&gt;roff = 0;
00550     }
00551 
00552     <span class="keywordflow">return</span> io-&gt;rcount;
00553 err:
00554     <span class="keywordflow">return</span> -1;
00555 }
00556 
<a name="l00572"></a><a class="code" href="group__basic.html#ga18">00572</a> ssize_t <a class="code" href="group__basic.html#ga18">io_read</a>(io_t *io, <span class="keywordtype">char</span> *buf, size_t size)
00573 {
00574     <span class="keywordtype">char</span> *out = buf;
00575     size_t wr;
00576     ssize_t c;
00577 
00578     dbg_err_if (io == NULL);
00579     dbg_err_if (buf == NULL);
00580     
00581     <span class="keywordflow">if</span>(io-&gt;eof)
00582         <span class="keywordflow">return</span> 0;
00583 
00584     <span class="keywordflow">while</span>(size)
00585     {
00586         <span class="keywordflow">if</span>(io-&gt;rcount == 0)
00587         {
00588             dbg_err_if((c = io_underflow(io)) &lt; 0);
00589             <span class="keywordflow">if</span>(c == 0)
00590                 <span class="keywordflow">break</span>;
00591         }
00592         <span class="comment">/* copy out data */</span>
00593         wr = MIN(io-&gt;rcount, size); 
00594         memcpy(out, io-&gt;rbuf + io-&gt;roff, wr);
00595         io-&gt;rcount -= wr;
00596         io-&gt;roff += wr;
00597         out += wr;
00598         size -= wr;
00599     }
00600 
00601     <span class="keywordflow">return</span> out - buf;
00602 err:
00603     <span class="keywordflow">return</span> -1;
00604 }
00605 
<a name="l00620"></a><a class="code" href="group__basic.html#ga29">00620</a> ssize_t <a class="code" href="group__basic.html#ga29">io_vprintf</a>(io_t *io, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap)
00621 {
00622     <span class="keyword">enum</span> { BUFSZ = 2048 };
00623     <span class="keywordtype">char</span> *bbuf = NULL; 
00624     <span class="keywordtype">int</span> sz;
00625     <span class="keywordtype">char</span> buf[BUFSZ];
00626     va_list apcpy;
00627 
00628     dbg_err_if (io == NULL);
00629     dbg_err_if (fmt == NULL);
00630 
00631 <span class="preprocessor">#ifdef VA_COPY_UNAVAIL</span>
00632 <span class="preprocessor"></span>    u_unused_args(apcpy);
00633 <span class="preprocessor">#elif defined(VA_LIST_BY_VALUE)</span>
00634 <span class="preprocessor"></span>    <span class="comment">/* we're sure about vnsprintf not consuming its 'ap' argument, so just do</span>
00635 <span class="comment">     * simple aliasing here: remember not to va_end() the alias */</span>
00636     apcpy = ap;
00637 <span class="preprocessor">#else</span>
00638 <span class="preprocessor"></span>    <span class="comment">/* vnsprintf modifies the va_list so make a copy before using it */</span>
00639     kl_va_copy(apcpy, ap);
00640 <span class="preprocessor">#endif</span>
00641 <span class="preprocessor"></span>
00642     <span class="comment">/* build the message to print */</span>
00643     sz = vsnprintf(buf, BUFSZ, fmt, ap);
00644 
00645     <span class="keywordflow">if</span>(sz &gt;= BUFSZ)
00646     {   
00647 <span class="preprocessor">#ifndef VA_COPY_UNAVAIL</span>
00648 <span class="preprocessor"></span>        <span class="comment">/* stack buffer too small, alloc a bigger one on the heap */</span>
00649         bbuf = (<span class="keywordtype">char</span>*)u_malloc(++sz);
00650         dbg_err_if(bbuf == NULL);
00651 
00652         <span class="comment">/* use apcpy in case ap has been consumed by previous vsnprintf */</span>
00653         <span class="keywordflow">if</span>((sz = vsnprintf(bbuf, sz, fmt, apcpy)) &gt; 0)
00654             dbg_err_if(<a class="code" href="group__basic.html#ga19">io_write</a>(io, bbuf, sz) &lt; 0);
00655 
00656         U_FREE(bbuf);
00657 <span class="preprocessor">#else</span>
00658 <span class="preprocessor"></span>        <span class="comment">/* push out all we can (sz-BUFSZ+1 bytes will be lost) */</span>
00659         warn(<span class="stringliteral">"last %d byte(s) could not be written out"</span>, sz - BUFSZ + 1);
00660         dbg_err_if(<a class="code" href="group__basic.html#ga19">io_write</a>(io, buf, BUFSZ) &lt; 0);
00661 <span class="preprocessor">#endif</span>
00662 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sz &gt; 0) {
00663         dbg_err_if(<a class="code" href="group__basic.html#ga19">io_write</a>(io, buf, sz) &lt; 0);
00664     }
00665 
00666 <span class="preprocessor">#if !defined(VA_LIST_BY_VALUE) &amp;&amp; !defined(VA_COPY_UNAVAIL)</span>
00667 <span class="preprocessor"></span>    va_end(apcpy);
00668 <span class="preprocessor">#endif</span>
00669 <span class="preprocessor"></span>    <span class="keywordflow">return</span> 0;
00670 err:
00671 <span class="preprocessor">#if !defined(VA_LIST_BY_VALUE) &amp;&amp; !defined(VA_COPY_UNAVAIL)</span>
00672 <span class="preprocessor"></span>    va_end(apcpy);
00673 <span class="preprocessor">#endif</span>
00674 <span class="preprocessor"></span>    <span class="keywordflow">return</span> -1;
00675 }
00676 
<a name="l00691"></a><a class="code" href="group__basic.html#ga28">00691</a> ssize_t <a class="code" href="group__basic.html#ga28">io_printf</a>(io_t *io, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
00692 {
00693     va_list ap;
00694     ssize_t ret;
00695 
00696     dbg_err_if (io == NULL);
00697     dbg_err_if (fmt == NULL);
00698 
00699     <span class="comment">/* build the message to print */</span>
00700     va_start(ap, fmt); <span class="comment">/* init variable list arguments */</span>
00701 
00702     ret = <a class="code" href="group__basic.html#ga29">io_vprintf</a>(io, fmt, ap);
00703 
00704     va_end(ap);
00705 
00706     <span class="keywordflow">return</span> ret;
00707 err:
00708     <span class="keywordflow">return</span> -1;
00709 }
00710 
<a name="l00721"></a><a class="code" href="group__basic.html#ga20">00721</a> ssize_t <a class="code" href="group__basic.html#ga20">io_flush</a>(io_t *io)
00722 {
00723     ssize_t c;
00724     size_t off = 0;
00725 
00726     dbg_err_if (io == NULL);
00727  
00728     <span class="keywordflow">while</span>(io-&gt;wcount)
00729     {
00730         c = io-&gt;write(io, io-&gt;wbuf + off, io-&gt;wcount);
00731         dbg_err_if(c &lt; 0);
00732         <span class="keywordflow">if</span>(c == 0)
00733             <span class="keywordflow">break</span>;
00734     
00735         io-&gt;wcount -= c;
00736         off += c;
00737     }
00738 
00739     <span class="keywordflow">return</span> 0;
00740 err:
00741     <span class="keywordflow">return</span> -1;
00742 }
00743 
<a name="l00756"></a><a class="code" href="group__basic.html#ga19">00756</a> ssize_t <a class="code" href="group__basic.html#ga19">io_write</a>(io_t *io, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t size)
00757 {
00758     size_t sz = 0, rem = size;
00759     ssize_t c = 0;
00760 
00761     dbg_err_if (io == NULL);
00762     dbg_err_if (buf == NULL);
00763     
00764     <span class="keywordflow">if</span>(io-&gt;wbuf == NULL)
00765         dbg_err_if(io_wbuf_alloc(io)); <span class="comment">/* alloc the write buffer */</span>
00766 
00767     <span class="keywordflow">while</span>(rem)
00768     {
00769         <span class="keywordflow">if</span>(IO_WBUF_FULL(io)) <span class="comment">/* if there's no more free space */</span>
00770             dbg_err_if(<a class="code" href="group__basic.html#ga20">io_flush</a>(io));
00771 
00772         sz = IO_WBUF_AVAIL(io);
00773         c = io_transfer(io, io-&gt;wbuf + io-&gt;wcount, &amp;sz, buf, rem);
00774         dbg_err_if(c &lt; 0);
00775         dbg_err_if(c == 0 &amp;&amp; sz == 0); <span class="comment">/* some bytes MUST be read or written */</span>
00776 
00777         io-&gt;wcount += sz;
00778         buf += c;
00779         rem -= c;
00780     }
00781 
00782     <span class="keywordflow">return</span> size;
00783 err:
00784     <span class="keywordflow">return</span> -1;
00785 }
00786 
<a name="l00798"></a><a class="code" href="group__basic.html#ga30">00798</a> <span class="keyword">inline</span> ssize_t <a class="code" href="group__basic.html#ga30">io_putc</a>(io_t *io, <span class="keywordtype">char</span> c)
00799 {
00800     <span class="keywordflow">return</span> <a class="code" href="group__basic.html#ga19">io_write</a>(io, &amp;c, 1);
00801 }
00802 
<a name="l00814"></a><a class="code" href="group__basic.html#ga27">00814</a> <span class="keyword">inline</span> ssize_t <a class="code" href="group__basic.html#ga27">io_getc</a>(io_t *io, <span class="keywordtype">char</span> *pc)
00815 {
00816     <span class="keywordflow">return</span> <a class="code" href="group__basic.html#ga18">io_read</a>(io, pc, 1);
00817 }
00818 
00819 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span> *io_strnchr(<span class="keywordtype">char</span> *buf, size_t sz, <span class="keywordtype">char</span> c)
00820 {
00821     <span class="keyword">register</span> <span class="keywordtype">char</span> *p;
00822 
00823     dbg_goto_if (buf == NULL, end);
00824 
00825     p = buf;
00826 
00827     <span class="keywordflow">while</span>(sz--)
00828     {
00829         <span class="keywordflow">if</span>(*p == c)
00830             <span class="keywordflow">return</span> p;
00831         ++p;
00832     }
00833 end:
00834     <span class="keywordflow">return</span> NULL;
00835 }
00836 
<a name="l00852"></a><a class="code" href="group__basic.html#ga26">00852</a> ssize_t <a class="code" href="group__basic.html#ga26">io_get_until</a>(io_t *io, <span class="keywordtype">char</span> stop_at, <span class="keywordtype">char</span> *buf, size_t size)
00853 {
00854     ssize_t wr, c, len = 0;
00855     <span class="keywordtype">char</span> *p, *base = buf;
00856 
00857     dbg_err_if (io == NULL);
00858     dbg_err_if (buf == NULL);
00859 
00860     <span class="keywordflow">if</span>(size &lt; 2)
00861         <span class="keywordflow">return</span> -1; <span class="comment">/* buf too small */</span>
00862 
00863     --size; <span class="comment">/* save a char for \0 */</span>
00864 
00865     <span class="keywordflow">if</span>(io-&gt;rcount == 0)
00866         dbg_err_if(io_underflow(io) &lt; 0);
00867 
00868     <span class="keywordflow">if</span>(io-&gt;rcount == 0)
00869         <span class="keywordflow">return</span> 0;
00870 
00871     <span class="keywordflow">for</span>(;;)
00872     {
00873         <span class="keywordflow">if</span>((p = io_strnchr(io-&gt;rbuf + io-&gt;roff, io-&gt;rcount, stop_at)) != NULL)
00874         {
00875             p++; <span class="comment">/* jump over 'stop_at' char*/</span>
00876             wr = MIN(p - (io-&gt;rbuf + io-&gt;roff), size);
00877             memcpy(buf, io-&gt;rbuf + io-&gt;roff, wr);
00878             buf[wr] = 0;
00879             io-&gt;rcount -= wr;
00880             io-&gt;roff += wr;
00881             len += wr;
00882             <span class="keywordflow">break</span>;
00883         } <span class="keywordflow">else</span> {
00884             <span class="keywordflow">if</span>(size &gt;= io-&gt;rcount)
00885             {
00886                 memcpy(buf, io-&gt;rbuf + io-&gt;roff, io-&gt;rcount);
00887                 len += io-&gt;rcount;
00888                 buf += io-&gt;rcount;
00889                 size -= io-&gt;rcount;
00890                 io-&gt;rcount = 0;
00891                 io-&gt;roff = 0;
00892                 dbg_err_if((c = io_underflow(io)) &lt; 0);
00893                 <span class="keywordflow">if</span>(c == 0)
00894                     <span class="keywordflow">break</span>;
00895             } <span class="keywordflow">else</span> {
00896                 <span class="comment">/* buffer too small, return a partial line */</span>
00897                 memcpy(buf, io-&gt;rbuf + io-&gt;roff, size);
00898                 len += size;
00899                 io-&gt;rcount -= size;
00900                 io-&gt;roff += size;
00901                 <span class="keywordflow">break</span>;
00902             }
00903         }
00904     }
00905 
00906     base[len] = 0;
00907     <span class="keywordflow">return</span> len; <span class="comment">/* return the # of chars in the line (strlen(line)) */</span>
00908 err:
00909     <span class="keywordflow">return</span> -1;
00910 }
00911 
<a name="l00925"></a><a class="code" href="group__basic.html#ga25">00925</a> ssize_t <a class="code" href="group__basic.html#ga25">io_gets</a>(io_t *io, <span class="keywordtype">char</span> *buf, size_t size)
00926 {
00927     <span class="keywordflow">return</span> <a class="code" href="group__basic.html#ga26">io_get_until</a>(io, <span class="charliteral">'\n'</span>, buf, size);
00928 }
00929 
<a name="l00939"></a><a class="code" href="group__basic.html#ga31">00939</a> <span class="keywordtype">int</span> <a class="code" href="group__basic.html#ga31">io_codec_add_head</a>(io_t *io, codec_t* c)
00940 {
00941     dbg_return_if (io == NULL, ~0);
00942     dbg_return_if (c == NULL, ~0);
00943 
00944     <span class="comment">/* insert the codec at the head of the chain */</span>
00945     TAILQ_INSERT_HEAD(&amp;io-&gt;codec_chain, c, np);
00946 
00947     <span class="keywordflow">return</span> 0;
00948 }
00949 
<a name="l00959"></a><a class="code" href="group__basic.html#ga32">00959</a> <span class="keywordtype">int</span> <a class="code" href="group__basic.html#ga32">io_codec_add_tail</a>(io_t *io, codec_t* c)
00960 {
00961     dbg_return_if (io == NULL, ~0);
00962     dbg_return_if (c == NULL, ~0);
00963 
00964     <span class="comment">/* insert the codec at the end of the chain */</span>
00965     TAILQ_INSERT_TAIL(&amp;io-&gt;codec_chain, c, np);
00966 
00967     <span class="keywordflow">return</span> 0;
00968 }
00969 
<a name="l00978"></a><a class="code" href="group__basic.html#ga33">00978</a> <span class="keywordtype">int</span> <a class="code" href="group__basic.html#ga33">io_codecs_remove</a>(io_t *io)
00979 {
00980     codec_t *codec;
00981     <span class="keywordtype">int</span> rc = 0;
00982 
00983     dbg_return_if (io == NULL, ~0);
00984 
00985     <span class="keywordflow">if</span>(!TAILQ_EMPTY(&amp;io-&gt;codec_chain))
00986     {
00987         <span class="keywordflow">if</span>(io-&gt;wbuf)
00988             dbg_ifb(io_chain_flush(io))
00989                 rc++;
00990 
00991         <span class="keywordflow">while</span>((codec = TAILQ_FIRST(&amp;io-&gt;codec_chain)) != NULL)
00992         {
00993             TAILQ_REMOVE(&amp;io-&gt;codec_chain, codec, np);
00994             <a class="code" href="group__filters.html#ga9">codec_free</a>(codec);
00995         }
00996     }
00997 
00998     <span class="keywordflow">return</span> rc;
00999 }
01000 
<a name="l01013"></a><a class="code" href="group__basic.html#ga16">01013</a> <span class="keywordtype">int</span> <a class="code" href="group__basic.html#ga16">io_name_set</a>(io_t *io, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
01014 {
01015     <span class="keywordtype">char</span> *n;
01016 
01017     dbg_err_if (io == NULL);
01018     dbg_err_if (name == NULL);
01019     
01020     n = u_strdup(name);
01021     dbg_err_if(n == NULL);
01022 
01023     U_FREE(io-&gt;name);
01024 
01025     io-&gt;name = n;
01026 
01027     <span class="keywordflow">return</span> 0;
01028 err:
01029     <span class="keywordflow">return</span> ~0;
01030 }
01031 
<a name="l01044"></a><a class="code" href="group__basic.html#ga17">01044</a> <span class="keywordtype">int</span> <a class="code" href="group__basic.html#ga17">io_name_get</a>(io_t *io, <span class="keywordtype">char</span> *name, size_t sz)
01045 {
01046     size_t min = 0;
01047 
01048     dbg_err_if (io == NULL);
01049     dbg_err_if (io-&gt;name == NULL);
01050     dbg_err_if (name == NULL);
01051     dbg_err_if (sz &lt; 2);
01052 
01053     min = MIN(sz-1, strlen(io-&gt;name));
01054 
01055     memcpy(name, io-&gt;name, min);
01056     name[min] = 0;
01057     
01058     <span class="keywordflow">return</span> 0;
01059 err:
01060     <span class="keywordflow">return</span> ~0;
01061 }
01062 
01063 <span class="comment">/*</span>
01064 <span class="comment"> * \ingroup basic</span>
01065 <span class="comment"> * \brief   Return the secure state of the IO object</span>
01066 <span class="comment"> *  </span>
01067 <span class="comment"> *  Return 0 if the connection is not secure (i.e. not encrypted) or not zero</span>
01068 <span class="comment"> *  otherwise</span>
01069 <span class="comment"> *</span>
01070 <span class="comment"> * \param io    io object</span>
01071 <span class="comment"> *</span>
01072 <span class="comment"> * \return \c 0 for not secure connections, non-zero otherwise</span>
01073 <span class="comment"> */</span>
01074 <span class="keywordtype">int</span> io_is_secure(io_t *io)
01075 {
01076     dbg_err_if(io == NULL);
01077 
01078     <span class="keywordflow">return</span> io-&gt;is_secure;
01079 err:
01080     <span class="keywordflow">return</span> 0;
01081 }
01082 
01083 
01084 <span class="comment">/* used by io devices init functions: alloc (used dev_sz block size) </span>
01085 <span class="comment">   and initialize an io_t */</span>
01086 <span class="keywordtype">int</span> io_prv_create(size_t dev_sz, io_t **pio)
01087 {
01088     io_t *io = NULL;
01089 
01090     dbg_err_if (pio == NULL);
01091 
01092     io = u_zalloc(dev_sz);
01093     dbg_err_if(io == NULL);
01094 
01095     TAILQ_INIT(&amp;io-&gt;codec_chain);
01096 
01097     <span class="comment">/* set refcnt to 1 */</span>
01098     io-&gt;refcnt++;
01099 
01100     <span class="comment">/* size of the io device struct (that's also a 'castable' io_t) */</span>
01101     io-&gt;size = dev_sz;
01102 
01103     *pio = io;
01104 
01105     <span class="keywordflow">return</span> 0;
01106 err:
01107     U_FREE(io);
01108     <span class="keywordflow">return</span> -1;
01109 }
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


