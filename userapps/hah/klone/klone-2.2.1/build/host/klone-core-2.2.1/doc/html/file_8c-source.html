<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: file.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>file.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: file.c,v 1.20 2007/11/09 22:06:26 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00012 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00013 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00014 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00015 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00016 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00017 <span class="preprocessor">#include &lt;klone/klog.h&gt;</span>
00018 <span class="preprocessor">#include &lt;klone/klogprv.h&gt;</span>
00019 
00020 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_close_file (klog_t *klf);
00021 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file (klog_t *klf, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap);
00022 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_flush_file (klog_t *kl);
00023 
00024 <span class="comment">/* </span>
00025 <span class="comment"> * A 'file' log is physically subdivided in a certain number of files (pages)</span>
00026 <span class="comment"> * named "&lt;basename&gt;.&lt;page_id&gt;" used as a sliding circular buffer.</span>
00027 <span class="comment"> * A page must be thought as a fixed size array of log lines.  Each page </span>
00028 <span class="comment"> * in a 'file' log is of the same dimension so that each log line can be</span>
00029 <span class="comment"> * referenced univocally.  Suppose a 'file' log made of n pages p_0, p_1, </span>
00030 <span class="comment"> * ..., p_n-1 of size m: the i-th line (0 &lt;= i &lt; n*m) will be found in page </span>
00031 <span class="comment"> * p_i%m at offset i%n.  We assume that at least 2 pages (n=2) exist.</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> * State informations are grouped into a 'head' file to be preserved between</span>
00034 <span class="comment"> * one run and the subsequent.  Informations in 'head' (i.e. n, m, active page</span>
00035 <span class="comment"> * id, offset in it) are used iff they correspond to actual config parameters.</span>
00036 <span class="comment"> * Otherwise past log is discarded.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> * (1) initialisation (where to start writing)</span>
00039 <span class="comment"> * (2) append a log line</span>
00040 <span class="comment"> * (3) termination (flush state to disk on exit)</span>
00041 <span class="comment"> *</span>
00042 <span class="comment"> * (1)</span>
00043 <span class="comment"> * The 'file' log initialisation phase consists in the selection of an </span>
00044 <span class="comment"> * available page and an offset in it, where to start appending log messages.</span>
00045 <span class="comment"> * The needed informations, if consistent with the supplied conf parameters, </span>
00046 <span class="comment"> * are gathered from the 'head' page.  If no 'head' is available (non-existent,</span>
00047 <span class="comment"> * damaged or inconsistent with conf) the write pointer will be placed at page</span>
00048 <span class="comment"> * zero, offset zero.</span>
00049 <span class="comment"> */</span>
00050 
00051 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_free_file (klog_file_t *klf);
00052 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_head_load (<span class="keyword">const</span> <span class="keywordtype">char</span> *base, klog_file_t **pklf);
00053 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_head_dump (klog_file_t *klf);
00054 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_head_new (<span class="keyword">const</span> <span class="keywordtype">char</span> *base, size_t npages, size_t nlines, 
00055         size_t wpageid, size_t offset, klog_file_t **pklf);
00056 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_file_head_free (klog_file_t *klf);
00057 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_append (klog_file_t *klf, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> level, 
00058         <span class="keyword">const</span> <span class="keywordtype">char</span> *ln);
00059 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_open_page (klog_file_t *klf);
00060 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_shift_page (klog_file_t *klf);
00061 
00062 <span class="keywordtype">int</span> klog_open_file (klog_t *kl, <span class="keyword">const</span> <span class="keywordtype">char</span> *base, size_t npages, size_t nlines)
00063 {
00064     klog_file_t *klf = NULL;
00065 
00066     dbg_return_if (kl == NULL, ~0);
00067     dbg_return_if (base == NULL, ~0);
00068 
00069     <span class="comment">/* load an existing head or create a brand new if it doesn't exist */</span>
00070     <span class="keywordflow">if</span> (klog_file_head_load(base, &amp;klf))
00071         dbg_err_if (klog_file_head_new(base, npages, nlines, 0, 0, &amp;klf));
00072     <span class="keywordflow">else</span>
00073     {
00074         <span class="comment">/* check consistency with the supplied values, in case there is</span>
00075 <span class="comment">         * a delta for npages and nlines, reset everything */</span>
00076         dbg_ifb (klf-&gt;npages != npages || klf-&gt;nlines != nlines)
00077         {
00078             klf-&gt;npages = npages;
00079             klf-&gt;nlines = nlines;
00080             klf-&gt;wpageid = 0;
00081             klf-&gt;offset = 0;
00082         }
00083     }
00084 
00085     <span class="comment">/* open the working log page for writing */</span>
00086     dbg_err_if (klog_file_open_page(klf));
00087 
00088     <span class="comment">/* set private methods */</span>
00089     kl-&gt;cb_log = klog_file;
00090     kl-&gt;cb_close = klog_close_file;
00091     kl-&gt;cb_getln = NULL;
00092     kl-&gt;cb_countln = NULL;
00093     kl-&gt;cb_clear = NULL;
00094     kl-&gt;cb_flush = klog_flush_file;
00095 
00096     kl-&gt;u.f = klf, klf = NULL;
00097 
00098     <span class="keywordflow">return</span> 0;
00099 err:
00100     <span class="keywordflow">if</span> (klf)
00101         klog_free_file(klf);
00102     <span class="keywordflow">return</span> ~0;
00103 }
00104 
00105 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_free_file (klog_file_t *klf)
00106 {
00107     U_FREE(klf);
00108 }
00109 
00110 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_flush_file (klog_t *kl)
00111 {
00112     klog_file_t *klf;
00113 
00114     dbg_return_if (kl == NULL, ~0);
00115     dbg_return_if (kl-&gt;type != KLOG_TYPE_FILE, ~0);
00116     dbg_return_if (kl-&gt;u.f == NULL, ~0);
00117 
00118     klf = kl-&gt;u.f;
00119      
00120     dbg_err_if (klf-&gt;wfp == NULL);
00121     dbg_err_sif (fflush(klf-&gt;wfp) != 0);
00122 
00123     <span class="keywordflow">return</span> 0;
00124 err:
00125     <span class="keywordflow">return</span> ~0;
00126 }
00127 
00128 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file (klog_t *kl, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap)
00129 {
00130     klog_file_t *klf;
00131     <span class="keywordtype">char</span> ln[KLOG_LN_SZ + 1];
00132     
00133     dbg_return_if (kl == NULL, ~0);
00134     dbg_return_if (kl-&gt;type != KLOG_TYPE_FILE, ~0);
00135     dbg_return_if (kl-&gt;u.f == NULL, ~0);
00136     dbg_return_if (fmt == NULL, ~0);
00137 
00138     klf = kl-&gt;u.f;
00139 
00140     <span class="comment">/* print log string */</span>
00141     vsnprintf(ln, <span class="keyword">sizeof</span> ln, fmt, ap);
00142     
00143     <span class="keywordflow">if</span> (KLOG_PAGE_FULL(klf)) <span class="comment">/* shift working page */</span>
00144         dbg_err_if (klog_file_shift_page(klf));
00145 
00146     dbg_err_if (klog_file_append(klf, kl-&gt;ident, level, ln));
00147 
00148     <span class="keywordflow">return</span> 0;
00149 err:
00150     <span class="keywordflow">return</span> ~0;
00151 }
00152 
00153 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_append (klog_file_t *klf, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> level, 
00154         <span class="keyword">const</span> <span class="keywordtype">char</span> *ln)
00155 {
00156     time_t now;
00157     <span class="keywordtype">char</span> *ct;
00158 
00159     dbg_return_if (ln == NULL, ~0);
00160     dbg_return_if (<span class="keywordtype">id</span> == NULL, ~0);
00161     dbg_return_if (klf == NULL, ~0);
00162     dbg_return_if (klf-&gt;wfp == NULL, ~0);
00163 
00164     dbg_err_if ((now = time(NULL)) == (time_t) -1);
00165     ct = ctime((<span class="keyword">const</span> time_t *) &amp;now);
00166     ct[24] = <span class="charliteral">'\0'</span>;
00167 
00168     <span class="comment">/* append line to wrk page */</span>
00169     fprintf(klf-&gt;wfp, <span class="stringliteral">"[%s] %s &lt;%s&gt;: %s\n"</span>, 
00170             klog_to_str(level), ct, <span class="keywordtype">id</span>, ln);
00171     klf-&gt;offset += 1;
00172 
00173     fflush(klf-&gt;wfp);
00174 
00175     <span class="keywordflow">return</span> 0;
00176 err:
00177     <span class="keywordflow">return</span> ~0;
00178 }
00179 
00180 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_close_file (klog_t *kl)
00181 {
00182     klog_file_t *klf;
00183     
00184     dbg_ifb (kl == NULL) <span class="keywordflow">return</span>;
00185     dbg_ifb (kl-&gt;type != KLOG_TYPE_FILE) <span class="keywordflow">return</span>;
00186     dbg_ifb (kl-&gt;u.f == NULL) <span class="keywordflow">return</span>;
00187 
00188     klf = kl-&gt;u.f;
00189     
00190     <span class="comment">/* flush pending messages */</span>
00191     U_FCLOSE(klf-&gt;wfp);
00192 
00193     <span class="comment">/* dump head info to disk */</span>
00194     dbg_if (klog_file_head_dump(klf));
00195 
00196     <span class="comment">/* free resources */</span>
00197     klog_free_file(klf), kl-&gt;u.f = NULL;
00198     
00199     <span class="keywordflow">return</span>;
00200 }
00201 
00202 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_head_load (<span class="keyword">const</span> <span class="keywordtype">char</span> *base, klog_file_t **pklf)
00203 {
00204     FILE *hfp = NULL;
00205     <span class="keywordtype">char</span> hf[U_FILENAME_MAX];
00206     klog_file_t hfs, *klf = NULL;
00207 
00208     dbg_return_if (base == NULL, ~0);
00209     dbg_return_if (pklf == NULL, ~0);
00210     
00211     dbg_err_if (u_path_snprintf(hf, U_FILENAME_MAX, U_PATH_SEPARATOR, <span class="stringliteral">"%s%s"</span>, 
00212         base, <span class="stringliteral">".head"</span>));
00213     dbg_err_if ((hfp = fopen(hf, <span class="stringliteral">"r"</span>)) == NULL);
00214     dbg_err_if (fread(&amp;hfs, <span class="keyword">sizeof</span> hfs, 1, hfp) != 1);
00215     U_FCLOSE(hfp);
00216 
00217     dbg_err_if (klog_file_head_new(base, hfs.npages, hfs.nlines, 
00218                                    hfs.wpageid, hfs.offset, &amp;klf));
00219     *pklf = klf;
00220 
00221     <span class="keywordflow">return</span> 0;
00222 err:
00223     <span class="keywordflow">if</span> (klf)
00224         klog_file_head_free(klf);
00225     U_FCLOSE(hfp);
00226     <span class="keywordflow">return</span> ~0;
00227 }
00228 
00229 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_head_dump (klog_file_t *klf)
00230 {
00231     FILE *hfp = NULL;
00232     <span class="keywordtype">char</span> hf[U_FILENAME_MAX];
00233     
00234     dbg_return_if (klf == NULL, ~0);
00235 
00236     dbg_err_if (u_path_snprintf(hf, U_FILENAME_MAX, U_PATH_SEPARATOR, <span class="stringliteral">"%s.%s"</span>, 
00237                                 klf-&gt;basename, <span class="stringliteral">"head"</span>));
00238     dbg_err_if ((hfp = fopen(hf, <span class="stringliteral">"w"</span>)) == NULL);
00239     dbg_err_if (fwrite(klf, <span class="keyword">sizeof</span>(klog_file_t), 1, hfp) != 1);
00240     U_FCLOSE(hfp);
00241 
00242     <span class="keywordflow">return</span> 0;
00243 err:
00244     U_FCLOSE(hfp);
00245     <span class="keywordflow">return</span> ~0;
00246 }
00247 
00248 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_head_new (<span class="keyword">const</span> <span class="keywordtype">char</span> *base, size_t npages, size_t nlines, 
00249         size_t wpageid, size_t offset, klog_file_t **pklf)
00250 {
00251     klog_file_t *klf = NULL;
00252 
00253     klf = u_zalloc(<span class="keyword">sizeof</span>(klog_file_t));
00254     dbg_err_if (klf == NULL);
00255 
00256     u_sstrncpy(klf-&gt;basename, base, U_FILENAME_MAX - 1);
00257     klf-&gt;npages = npages;
00258     klf-&gt;nlines = nlines;
00259     klf-&gt;wpageid = wpageid;
00260     klf-&gt;offset = offset;
00261     klf-&gt;wfp = NULL;
00262 
00263     *pklf = klf;
00264 
00265     <span class="keywordflow">return</span> 0;
00266 err:
00267     klog_file_head_free(klf);
00268     <span class="keywordflow">return</span> ~0;
00269 }
00270 
00271 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_file_head_free (klog_file_t *klf)
00272 {
00273     <span class="keywordflow">if</span> (klf == NULL)
00274         <span class="keywordflow">return</span>;
00275 
00276     U_FCLOSE(klf-&gt;wfp);
00277     U_FREE(klf);
00278     
00279     <span class="keywordflow">return</span>;
00280 }
00281 
00282 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_shift_page (klog_file_t *klf)
00283 {
00284     <span class="keywordtype">char</span> wf[U_FILENAME_MAX];
00285     
00286     dbg_return_if (klf == NULL, ~0);
00287 
00288     U_FCLOSE(klf-&gt;wfp);
00289     dbg_err_if (u_path_snprintf(wf, U_FILENAME_MAX, U_PATH_SEPARATOR, <span class="stringliteral">"%s.%d"</span>, 
00290         klf-&gt;basename, (klf-&gt;wpageid + 1)%klf-&gt;npages));
00291     dbg_err_if ((klf-&gt;wfp = fopen(wf, <span class="stringliteral">"w"</span>)) == NULL);
00292 
00293     klf-&gt;offset = 0;                                <span class="comment">/* reset offset counter */</span>
00294     klf-&gt;wpageid = ++(klf-&gt;wpageid)%klf-&gt;npages;    <span class="comment">/* increment page id */</span>
00295     
00296     <span class="keywordflow">return</span> 0;
00297 err:
00298     <span class="keywordflow">return</span> ~0;
00299 }
00300 
00301 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_file_open_page (klog_file_t *klf)
00302 {
00303     <span class="keywordtype">char</span> wf[U_FILENAME_MAX];
00304 
00305     dbg_return_if (klf == NULL, ~0);
00306 
00307     dbg_err_if (u_path_snprintf(wf, U_FILENAME_MAX, U_PATH_SEPARATOR, <span class="stringliteral">"%s.%d"</span>, 
00308                                 klf-&gt;basename, klf-&gt;wpageid));
00309     dbg_err_if ((klf-&gt;wfp = fopen(wf, <span class="stringliteral">"a"</span>)) == NULL);
00310     
00311     <span class="keywordflow">return</span> 0;
00312 err:
00313     <span class="keywordflow">return</span> ~0;
00314 }
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


