<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: parser.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>parser.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: parser.c,v 1.14 2008/10/18 00:03:00 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00013 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00014 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00015 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00016 <span class="preprocessor">#include &lt;klone/os.h&gt;</span>
00017 <span class="preprocessor">#include &lt;klone/translat.h&gt;</span>
00018 <span class="preprocessor">#include &lt;klone/parser.h&gt;</span>
00019 
00020 <span class="comment">/* parser state */</span>
00021 <span class="keyword">enum</span> { 
00022     S_START, 
00023     S_IN_DOUBLE_QUOTE,
00024     S_IN_SINGLE_QUOTE, 
00025     S_HTML, 
00026     S_WAIT_PERC,
00027     S_START_CODE, 
00028     S_CODE, 
00029     S_WAIT_GT,
00030     S_EAT_NEWLINE
00031 };
00032 
00033 <span class="keyword">enum</span> { LF = 0xA, CR = 0xD };
00034 
00035 <span class="keyword">static</span> <span class="keywordtype">int</span> parser_on_block(parser_t *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t sz)
00036 {
00037     dbg_err_if (p == NULL);
00038     dbg_err_if (buf == NULL);
00039 
00040     <span class="keywordflow">for</span>(;;)
00041     {
00042         <span class="keywordflow">switch</span>(p-&gt;state)
00043         {
00044         <span class="keywordflow">case</span> S_START:
00045             <span class="comment">/* empty file */</span>
00046             <span class="keywordflow">return</span> 0;
00047         <span class="keywordflow">case</span> S_IN_DOUBLE_QUOTE:
00048         <span class="keywordflow">case</span> S_IN_SINGLE_QUOTE: 
00049             <span class="keywordflow">if</span>(p-&gt;state != p-&gt;prev_state)
00050             {
00051                 p-&gt;state = p-&gt;prev_state;
00052                 <span class="keywordflow">continue</span>;
00053             } <span class="keywordflow">else</span>
00054                 <span class="keywordflow">return</span> 0;
00055         <span class="keywordflow">case</span> S_HTML: 
00056         <span class="keywordflow">case</span> S_WAIT_PERC:
00057             <span class="keywordflow">if</span>(sz &amp;&amp; p-&gt;cb_html)
00058                 dbg_err_if(p-&gt;cb_html(p, p-&gt;cb_arg, buf, sz));
00059             <span class="keywordflow">return</span> 0;
00060         <span class="keywordflow">case</span> S_START_CODE:
00061         <span class="keywordflow">case</span> S_CODE:
00062         <span class="keywordflow">case</span> S_WAIT_GT:
00063             <span class="keywordflow">if</span>(sz &amp;&amp; p-&gt;cb_code)
00064                 dbg_err_if(p-&gt;cb_code(p, p-&gt;cmd_code, p-&gt;cb_arg, buf, sz));
00065             <span class="keywordflow">return</span> 0;
00066         }
00067     }
00068 
00069     <span class="keywordflow">return</span> 0;
00070 err:
00071     <span class="keywordflow">return</span> ~0;
00072 }
00073 
00074 <span class="keywordtype">int</span> parser_run(parser_t *p)
00075 {
00076     <span class="keyword">enum</span> { BUFSZ = 262144 }; <span class="comment">/* a big buffer is good to better zip *.kl1 */</span>
00077 <span class="preprocessor">    #define set_state( s ) \</span>
00078 <span class="preprocessor">        do { tmp = p-&gt;state; p-&gt;state = s; p-&gt;prev_state = tmp; } while(0)</span>
00079 <span class="preprocessor"></span><span class="preprocessor">    #define fetch_next_char()                                           \</span>
00080 <span class="preprocessor">        do { prev = c;                                                  \</span>
00081 <span class="preprocessor">            dbg_err_if((rc = io_getc(p-&gt;in, &amp;c)) &lt; 0);                  \</span>
00082 <span class="preprocessor">            if(rc == 0) break;                                          \</span>
00083 <span class="preprocessor">            if( (c == CR || c == LF) &amp;&amp; prev != (c == CR ? LF : CR))    \</span>
00084 <span class="preprocessor">                p-&gt;line++;                                              \</span>
00085 <span class="preprocessor">        } while(0)</span>
00086 <span class="preprocessor"></span>    <span class="keywordtype">int</span> tmp;
00087     <span class="keywordtype">char</span> c = 0, prev;
00088     <span class="keywordtype">char</span> buf[BUFSZ];
00089     size_t idx = 0;
00090     ssize_t rc;
00091 
00092     dbg_err_if (p == NULL);
00093     
00094     buf[0] = 0;
00095     prev = 0;
00096 
00097     dbg_err_if(p-&gt;line &gt; 1);
00098 
00099     fetch_next_char();
00100 
00101     <span class="keywordflow">while</span>(rc &gt; 0)
00102     {
00103         prev = c;
00104         <span class="keywordflow">switch</span>(p-&gt;state)
00105         {
00106         <span class="keywordflow">case</span> S_START:
00107             set_state(S_HTML);
00108             <span class="keywordflow">continue</span>;
00109         <span class="keywordflow">case</span> S_IN_DOUBLE_QUOTE:
00110             <span class="keywordflow">if</span>(c == <span class="charliteral">'"'</span> &amp;&amp; prev != <span class="charliteral">'\\'</span>)
00111                 set_state(p-&gt;prev_state);
00112             <span class="keywordflow">break</span>;
00113         <span class="keywordflow">case</span> S_IN_SINGLE_QUOTE:
00114             <span class="keywordflow">if</span>(c == <span class="charliteral">'\''</span> &amp;&amp; prev != <span class="charliteral">'\\'</span>)
00115                 set_state(p-&gt;prev_state);
00116             <span class="keywordflow">break</span>;
00117         <span class="keywordflow">case</span> S_HTML:
00118             <span class="keywordflow">if</span>(c == <span class="charliteral">'&lt;'</span>)
00119                 set_state(S_WAIT_PERC);
00120             <span class="keywordflow">break</span>;
00121         <span class="keywordflow">case</span> S_WAIT_PERC:
00122             <span class="keywordflow">if</span>(c == <span class="charliteral">'%'</span>)
00123             {
00124                 <span class="keywordflow">if</span>(idx &amp;&amp; --idx) <span class="comment">/* erase &lt; */</span>
00125                 {
00126                     buf[idx] = 0;
00127                     dbg_err_if(parser_on_block(p, buf, idx));
00128                     buf[0] = 0; idx = 0;
00129                 }
00130                 set_state(S_START_CODE);
00131                 p-&gt;code_line = p-&gt;line; <span class="comment">/* save start code line number  */</span>
00132                 fetch_next_char();      <span class="comment">/* get cmd char (!,@,etc.)      */</span>
00133                 <span class="keywordflow">continue</span>;
00134             } <span class="keywordflow">else</span> {
00135                 set_state(S_HTML);
00136                 <span class="keywordflow">continue</span>;
00137             }
00138             <span class="keywordflow">break</span>;
00139         <span class="keywordflow">case</span> S_START_CODE:
00140             <span class="keywordflow">if</span>(isspace(c))
00141                 p-&gt;cmd_code = 0;
00142             <span class="keywordflow">else</span> {
00143                 p-&gt;cmd_code = c;
00144                 fetch_next_char();
00145             }
00146             set_state(S_CODE);
00147             <span class="keywordflow">continue</span>;
00148         <span class="keywordflow">case</span> S_CODE:
00149             <span class="keywordflow">if</span>(c == <span class="charliteral">'%'</span>) 
00150                 set_state(S_WAIT_GT);
00151             <span class="keywordflow">break</span>;
00152         <span class="keywordflow">case</span> S_WAIT_GT:
00153             <span class="keywordflow">if</span>(c == <span class="charliteral">'&gt;'</span>)
00154             {
00155                 <span class="keywordflow">if</span>(idx &amp;&amp; --idx) <span class="comment">/* erase % */</span>
00156                 {
00157                     buf[idx] = 0;
00158                     dbg_err_if(parser_on_block(p, buf, idx));
00159                     buf[0] = 0; idx = 0;
00160                 }
00161                 fetch_next_char();
00162                 p-&gt;cmd_code = 0;
00163                 set_state(S_HTML);
00164                 <span class="keywordflow">continue</span>;
00165             } <span class="keywordflow">else</span> {
00166                 set_state(S_CODE);
00167                 <span class="keywordflow">continue</span>;
00168             }
00169             <span class="keywordflow">break</span>;
00170         <span class="keywordflow">case</span> S_EAT_NEWLINE:
00171             <span class="keywordflow">if</span>(c == CR || c == LF)
00172             {
00173                 fetch_next_char();
00174                 <span class="keywordflow">continue</span>; <span class="comment">/* eat it */</span>
00175             }
00176             set_state(S_HTML);
00177             <span class="keywordflow">continue</span>;
00178         <span class="keywordflow">default</span>:
00179             dbg_err_if(<span class="stringliteral">"unknown parser state"</span>);
00180         }
00181         buf[idx++] = c;
00182         <span class="keywordflow">if</span>(idx == BUFSZ - 1)
00183         {
00184             buf[idx] = 0;
00185             dbg_err_if(parser_on_block(p, buf, idx));
00186             buf[0] = 0; idx = 0;
00187         }
00188 
00189         fetch_next_char();
00190     }
00191 
00192     <span class="keywordflow">if</span>(idx)
00193     {
00194         buf[idx] = 0;
00195         dbg_err_if(parser_on_block(p, buf, idx));
00196         buf[0] = 0; idx = 0;
00197     }
00198 
00199     <span class="keywordflow">return</span> 0;
00200 err:
00201     <span class="keywordflow">return</span> ~0;
00202 }
00203 
00204 <span class="keywordtype">void</span> parser_set_cb_code(parser_t *p, parser_cb_code_t cb)
00205 {
00206     dbg_ifb (p == NULL) <span class="keywordflow">return</span>;
00207     p-&gt;cb_code = cb;
00208 }
00209 
00210 <span class="keywordtype">void</span> parser_set_cb_html(parser_t *p, parser_cb_html_t cb)
00211 {
00212     dbg_ifb (p == NULL) <span class="keywordflow">return</span>;
00213     p-&gt;cb_html = cb;
00214 }
00215 
00216 <span class="keywordtype">void</span>* parser_get_cb_arg(parser_t *p)
00217 {
00218     dbg_ifb (p == NULL) <span class="keywordflow">return</span> NULL;
00219     <span class="keywordflow">return</span> p-&gt;cb_arg;
00220 }
00221 
00222 <span class="keywordtype">void</span> parser_set_cb_arg(parser_t *p, <span class="keywordtype">void</span> *opaque)
00223 {
00224     dbg_ifb (p == NULL) <span class="keywordflow">return</span>;
00225     p-&gt;cb_arg = opaque;
00226 }
00227 
00228 <span class="keywordtype">void</span> parser_set_io(parser_t *p, io_t *in, io_t *out)
00229 {
00230     dbg_ifb (p == NULL) <span class="keywordflow">return</span>;
00231     p-&gt;in = in;
00232     p-&gt;out = out;
00233 }
00234 
00235 <span class="keywordtype">int</span> parser_free(parser_t *t)
00236 {
00237     U_FREE(t);
00238     <span class="keywordflow">return</span> 0;
00239 }
00240 
00241 <span class="keywordtype">int</span> parser_reset(parser_t *p)
00242 {
00243     dbg_return_if (p == NULL, ~0);
00244 
00245     p-&gt;line = 1;
00246     p-&gt;state = p-&gt;prev_state = S_START;
00247     p-&gt;cmd_code = 0;
00248 
00249     <span class="keywordflow">return</span> 0;
00250 }
00251 
00252 <span class="keywordtype">int</span> parser_create(parser_t **pt)
00253 {
00254     parser_t *p = NULL;
00255 
00256     dbg_return_if (pt == NULL, ~0);
00257     
00258     p = (parser_t*)u_zalloc(<span class="keyword">sizeof</span>(parser_t));
00259     dbg_err_if(p == NULL);
00260 
00261     (<span class="keywordtype">void</span>) parser_reset(p);
00262 
00263     *pt = p;
00264 
00265     <span class="keywordflow">return</span> 0;
00266 err:
00267     <span class="keywordflow">if</span>(p)
00268         parser_free(p);
00269     <span class="keywordflow">return</span> ~0;
00270 }
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


