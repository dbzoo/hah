<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LibU: buf.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>buf.c</h1><div class="fragment"><pre>00001 <span class="comment">/* </span>
00002 <span class="comment"> * Copyright (c) 2005-2008 by KoanLogic s.r.l. - All rights reserved.  </span>
00003 <span class="comment"> */</span>
00004 
00005 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00006 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00007 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00008 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00009 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00010 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00011 <span class="preprocessor">#include &lt;toolbox/buf.h&gt;</span>
00012 
<a name="l00028"></a><a class="code" href="group__buf.html#ga0">00028</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga0">u_buf_reserve</a>(u_buf_t *ubuf, size_t size)
00029 {
00030     <span class="keywordtype">char</span> *nbuf;
00031 
00032     dbg_err_if(ubuf == NULL);
00033 
00034     <span class="keywordflow">if</span>(size &lt;= ubuf-&gt;size)
00035         <span class="keywordflow">return</span> 0; <span class="comment">/* nothing to do */</span>
00036    
00037     <span class="comment">/* size plus 1 char to store a '\0' */</span>
00038     nbuf = <a class="code" href="group__alloc.html#ga7">u_realloc</a>(ubuf-&gt;data, size+1);
00039     dbg_err_if(nbuf == NULL);
00040 
00041     <span class="comment">/* buffer data will always be zero-terminated (but the len field will not</span>
00042 <span class="comment">     * count the last '\0') */</span>
00043     nbuf[size] = 0;
00044 
00045     ubuf-&gt;data = (<span class="keywordtype">void</span>*)nbuf;
00046     ubuf-&gt;size = size;
00047 
00048     <span class="keywordflow">return</span> 0;
00049 err:
00050     <span class="keywordflow">return</span> ~0;
00051 }
00052 
<a name="l00065"></a><a class="code" href="group__buf.html#ga1">00065</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga1">u_buf_append</a>(u_buf_t *ubuf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, size_t size)
00066 {
00067     dbg_err_if(ubuf == NULL);
00068     dbg_err_if(data == NULL);
00069     dbg_err_if(size == 0);
00070 
00071     <span class="keywordflow">if</span>(ubuf-&gt;size - ubuf-&gt;len &lt; size)
00072     {   <span class="comment">/* buffer too small, need to resize */</span>
00073         dbg_err_if(<a class="code" href="group__buf.html#ga0">u_buf_reserve</a>(ubuf, ubuf-&gt;size + ubuf-&gt;len + 2*size));
00074     }
00075    
00076     memcpy(ubuf-&gt;data + ubuf-&gt;len, data, size);
00077     ubuf-&gt;len += size;
00078 
00079     <span class="comment">/* zero term the buffer so it can be used (when applicable) as a string */</span>
00080     ubuf-&gt;data[ubuf-&gt;len] = 0;
00081 
00082     <span class="keywordflow">return</span> 0;
00083 err:
00084     <span class="keywordflow">return</span> ~0;
00085 }
00086 
<a name="l00097"></a><a class="code" href="group__buf.html#ga2">00097</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga2">u_buf_load</a>(u_buf_t *ubuf, <span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
00098 {
00099     <span class="keyword">struct </span>stat st;
00100     FILE *fp = NULL;
00101 
00102     dbg_err_if(ubuf == NULL);
00103     dbg_err_if(filename == NULL);
00104 
00105     dbg_err_if(stat(filename, &amp;st));
00106 
00107     <span class="comment">/* clear the current data */</span>
00108     dbg_err_if(<a class="code" href="group__buf.html#ga6">u_buf_clear</a>(ubuf));
00109 
00110     <span class="comment">/* be sure to have a big enough buffer */</span>
00111     dbg_err_if(<a class="code" href="group__buf.html#ga0">u_buf_reserve</a>(ubuf, st.st_size));
00112 
00113     dbg_err_sif((fp = fopen(filename, <span class="stringliteral">"r"</span>)) == NULL);
00114 
00115     <span class="comment">/* fill the buffer with the whole file content */</span>
00116     dbg_err_if(fread(ubuf-&gt;data, st.st_size, 1, fp) == 0);
00117     ubuf-&gt;len = st.st_size;
00118 
00119     fclose(fp);
00120 
00121     <span class="keywordflow">return</span> 0;
00122 err:
00123     <span class="keywordflow">if</span>(fp)
00124         fclose(fp);
00125     <span class="keywordflow">return</span> ~0;
00126 }
00127 
<a name="l00142"></a><a class="code" href="group__buf.html#ga3">00142</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga3">u_buf_detach</a>(u_buf_t *ubuf)
00143 {
00144     dbg_err_if(ubuf == NULL);
00145 
00146     ubuf-&gt;data = NULL;
00147     ubuf-&gt;size = 0;
00148     ubuf-&gt;len = 0;
00149 
00150     <span class="keywordflow">return</span> 0;
00151 err:
00152     <span class="keywordflow">return</span> ~0;
00153 }
00154 
<a name="l00164"></a><a class="code" href="group__buf.html#ga4">00164</a> size_t <a class="code" href="group__buf.html#ga4">u_buf_size</a>(u_buf_t *ubuf)
00165 {
00166     dbg_err_if(ubuf == NULL);
00167 
00168     <span class="keywordflow">return</span> ubuf-&gt;size;
00169 err:
00170     <span class="keywordflow">return</span> 0;
00171 }
00172 
<a name="l00182"></a><a class="code" href="group__buf.html#ga5">00182</a> size_t <a class="code" href="group__buf.html#ga5">u_buf_len</a>(u_buf_t *ubuf)
00183 {
00184     dbg_err_if(ubuf == NULL);
00185 
00186     <span class="keywordflow">return</span> ubuf-&gt;len;
00187 err:
00188     <span class="keywordflow">return</span> 0;
00189 }
00190 
<a name="l00201"></a><a class="code" href="group__buf.html#ga6">00201</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga6">u_buf_clear</a>(u_buf_t *ubuf)
00202 {
00203     dbg_err_if(ubuf == NULL);
00204     
00205     ubuf-&gt;len = 0;
00206 
00207     <span class="keywordflow">return</span> 0;
00208 err:
00209     <span class="keywordflow">return</span> ~0;
00210 }
00211 
<a name="l00224"></a><a class="code" href="group__buf.html#ga7">00224</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga7">u_buf_set</a>(u_buf_t *ubuf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, size_t size)
00225 {
00226     dbg_err_if(ubuf == NULL);
00227     dbg_err_if(data == NULL);
00228     dbg_err_if(size == 0);
00229 
00230     dbg_err_if(<a class="code" href="group__buf.html#ga6">u_buf_clear</a>(ubuf));
00231 
00232     dbg_err_if(<a class="code" href="group__buf.html#ga1">u_buf_append</a>(ubuf, data, size));
00233 
00234     <span class="keywordflow">return</span> 0;
00235 err:
00236     <span class="keywordflow">return</span> ~0;
00237 }
00238 
<a name="l00248"></a><a class="code" href="group__buf.html#ga8">00248</a> <span class="keywordtype">void</span>* <a class="code" href="group__buf.html#ga8">u_buf_ptr</a>(u_buf_t *ubuf)
00249 {
00250     dbg_err_if(ubuf == NULL);
00251     
00252     <span class="keywordflow">return</span> ubuf-&gt;data;
00253 err:
00254     <span class="keywordflow">return</span> NULL;
00255 }
00256 
<a name="l00266"></a><a class="code" href="group__buf.html#ga9">00266</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga9">u_buf_free</a>(u_buf_t *ubuf)
00267 {
00268     dbg_err_if(ubuf == NULL);
00269 
00270     <span class="keywordflow">if</span>(ubuf-&gt;data)
00271         <a class="code" href="group__alloc.html#ga8">u_free</a>(ubuf-&gt;data);
00272 
00273     <a class="code" href="group__alloc.html#ga8">u_free</a>(ubuf);
00274 
00275     <span class="keywordflow">return</span> 0;
00276 err:
00277     <span class="keywordflow">return</span> ~0;
00278 }
00279 
<a name="l00295"></a><a class="code" href="group__buf.html#ga10">00295</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga10">u_buf_printf</a>(u_buf_t *ubuf, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
00296 {
00297     va_list ap;
00298     size_t sz, avail;
00299 
00300     dbg_return_if(ubuf == NULL, ~0);
00301     dbg_return_if(fmt == NULL, ~0);
00302 
00303 again:
00304     va_start(ap, fmt); 
00305 
00306     avail = ubuf-&gt;size - ubuf-&gt;len; <span class="comment">/* avail may be zero */</span>
00307 
00308     <span class="comment">/* write to the internal buffer of ubuf */</span>
00309     dbg_err_if(( sz = vsnprintf(ubuf-&gt;data + ubuf-&gt;len, avail, fmt, ap)) &lt;= 0);
00310 
00311     <span class="keywordflow">if</span>(sz &gt;= avail)
00312     {
00313         <span class="comment">/* enlarge the buffer (make it at least 128 bytes bigger) */</span>
00314         dbg_err_if(<a class="code" href="group__buf.html#ga0">u_buf_reserve</a>(ubuf, ubuf-&gt;len + U_MAX(128, sz + 1)));
00315 
00316         <span class="comment">/* zero-term the buffer (vsnprintf has removed the last \0!) */</span>
00317         ubuf-&gt;data[ubuf-&gt;len] = 0;
00318 
00319         va_end(ap);
00320 
00321         <span class="comment">/* try again with a bigger buffer */</span>
00322         <span class="keywordflow">goto</span> again;
00323     }
00324 
00325     <span class="comment">/* update data length (don't include the '\0' in the size count) */</span>
00326     ubuf-&gt;len += sz; 
00327 
00328     va_end(ap);
00329 
00330     <span class="keywordflow">return</span> 0;
00331 err:
00332     va_end(ap);
00333     <span class="keywordflow">return</span> ~0; <span class="comment">/* error */</span>
00334 }
00335 
<a name="l00345"></a><a class="code" href="group__buf.html#ga11">00345</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga11">u_buf_create</a>(u_buf_t **pubuf)
00346 {
00347     u_buf_t *ubuf = NULL;
00348 
00349     dbg_err_if(pubuf == NULL);
00350 
00351     ubuf = (u_buf_t*)<a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(u_buf_t));
00352     dbg_err_if(ubuf == NULL);
00353 
00354     *pubuf = ubuf;
00355 
00356     <span class="keywordflow">return</span> 0;
00357 err:
00358     <span class="keywordflow">return</span> ~0;
00359 }
00360 
</pre></div><hr>
<div>
  <div style="text-align:left">
    <a href="http://www.koanlogic.com/kl/cont/gb/html/products.html">&larr;Products</a>
  </div>
  <div style="text-align:center;">
    &copy; 2005-2008 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
  </div>
</div>

</body>
</html>
