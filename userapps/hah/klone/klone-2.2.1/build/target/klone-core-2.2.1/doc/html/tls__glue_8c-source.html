<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: tls_glue.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>tls_glue.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005-2008 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: tls_glue.c,v 1.14 2008/03/18 17:28:02 tho Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">/*</span>
00012 <span class="comment"> * This product includes software developed by Ralf S. Engelschall </span>
00013 <span class="comment"> * &lt;rse@engelschall.com&gt; for use in the mod_ssl project (http://www.modssl.org/)</span>
00014 <span class="comment"> * </span>
00015 <span class="comment"> * This product includes software developed by the OpenSSL Project</span>
00016 <span class="comment"> * for use in the OpenSSL Toolkit (http://www.openssl.org/)"</span>
00017 <span class="comment"> */</span>
00018 
00019 <span class="preprocessor">#include "klone_conf.h"</span>
00020 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00021 <span class="preprocessor">#include &lt;klone/io.h&gt;</span>
00022 <span class="preprocessor">#include &lt;klone/emb.h&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/tlsprv.h&gt;</span>
00024 
00025 <span class="preprocessor">#ifndef HAVE_LIBOPENSSL</span>
00026 <span class="preprocessor"></span><span class="keywordtype">int</span> tls_dummy_decl_stub = 0;
00027 <span class="preprocessor">#else </span><span class="comment">/* HAVE_LIBOPENSSL */</span>
00028 <span class="preprocessor">#include &lt;openssl/ssl.h&gt;</span>
00029 <span class="preprocessor">#include &lt;openssl/x509.h&gt;</span>
00030 
00031 
00032 <span class="comment">/* map an emb resource to a OpenSSL memory BIO */</span>
00033 BIO *bio_from_emb (<span class="keyword">const</span> <span class="keywordtype">char</span> *res_name)
00034 {
00035     <span class="keywordtype">int</span> c;
00036     <span class="keywordtype">char</span> buf[1024];
00037     io_t *tmp = NULL;
00038     BIO *b = NULL;
00039 
00040     dbg_return_if (res_name == NULL, NULL);
00041 
00042     dbg_err_if (emb_open(res_name, &amp;tmp));
00043     dbg_err_if (!(b = BIO_new(BIO_s_mem())));
00044 
00045     <span class="keywordflow">for</span> (;;)
00046     {
00047         c = <a class="code" href="group__basic.html#ga18">io_read</a>(tmp, buf, <span class="keyword">sizeof</span> buf);
00048 
00049         <span class="keywordflow">if</span> (c == 0)     <span class="comment">/* EOF */</span>
00050             <span class="keywordflow">break</span>;
00051         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c &lt; 0) <span class="comment">/* read error */</span>
00052             <span class="keywordflow">goto</span> err;
00053 
00054         dbg_err_if (BIO_write(b, buf, c) &lt;= 0);
00055     }
00056 
00057     <a class="code" href="group__basic.html#ga14">io_free</a>(tmp);
00058 
00059     <span class="keywordflow">return</span> b;
00060 err:
00061     <span class="keywordflow">if</span> (tmp) 
00062         <a class="code" href="group__basic.html#ga14">io_free</a>(tmp);
00063     <span class="keywordflow">if</span> (b)  
00064         BIO_free(b);
00065 
00066     <span class="keywordflow">return</span> NULL;
00067 }
00068 
00069 BIO* tls_get_file_bio(<span class="keyword">const</span> <span class="keywordtype">char</span> *res_name)
00070 {
00071     BIO *b = NULL;
00072 
00073     <span class="comment">/* load the cert from the embfs */</span>
00074     <span class="keywordflow">if</span>((b = bio_from_emb(res_name)) != NULL)
00075         <span class="keywordflow">return</span> b;
00076 
00077     <span class="comment">/* load the cert from the file system */</span>
00078     <span class="keywordflow">if</span>((b = BIO_new_file(res_name, <span class="stringliteral">"r"</span>)) != NULL)
00079         <span class="keywordflow">return</span> b;
00080 
00081     <span class="comment">/* no cert found */</span>
00082     <span class="keywordflow">return</span> NULL;
00083 }
00084 
00085 
00086 <span class="comment">/* XXX the original returns the number of certs/crls added */</span>
00087 <span class="keywordtype">int</span> tls_load_verify_locations (SSL_CTX *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *res_name)
00088 {
00089     <span class="keywordtype">int</span> i;
00090     BIO *b = NULL;
00091     STACK_OF(X509_INFO) *info = NULL;
00092 
00093     dbg_return_if (!c, ~0);
00094     dbg_return_if (!res_name, ~0);
00095 
00096     dbg_err_if (!(b = tls_get_file_bio(res_name)));
00097     dbg_err_if (!(info = PEM_X509_INFO_read_bio(b, NULL, NULL, NULL)));
00098     BIO_free(b);
00099 
00100     <span class="keywordflow">for</span> (i = 0; i &lt; sk_X509_INFO_num(info); i++)
00101     {
00102         X509_INFO   *tmp = sk_X509_INFO_value(info, i);
00103 
00104         <span class="keywordflow">if</span> (tmp-&gt;x509)
00105             X509_STORE_add_cert(c-&gt;cert_store, tmp-&gt;x509); 
00106 
00107         <span class="keywordflow">if</span> (tmp-&gt;crl)
00108             X509_STORE_add_crl(c-&gt;cert_store, tmp-&gt;crl); 
00109     }
00110 
00111     sk_X509_INFO_pop_free(info, X509_INFO_free);
00112 
00113     <span class="keywordflow">return</span> 0;
00114 err:
00115     <span class="keywordflow">if</span> (b)
00116         BIO_free(b);
00117     <span class="keywordflow">if</span> (info)
00118         sk_X509_INFO_pop_free(info, X509_INFO_free);
00119 
00120     <span class="keywordflow">return</span> ~0;
00121 } 
00122 
00123 <span class="comment">/* reads certificates from file and returns a STACK_OF(X509_NAME) with </span>
00124 <span class="comment"> * the subject names found */</span>
00125 STACK_OF(X509_NAME) *tls_load_client_CA_file (<span class="keyword">const</span> <span class="keywordtype">char</span> *res_name)
00126 {
00127     BIO *b = NULL;
00128     X509 *x = NULL;
00129     X509_NAME *xn = NULL;
00130     STACK_OF(X509_NAME) *ret, *sk;
00131 
00132     dbg_return_if (!res_name, NULL);
00133     
00134     dbg_err_if (!(ret = sk_X509_NAME_new_null()));
00135     dbg_err_if (!(sk = sk_X509_NAME_new(X509_NAME_cmp)));
00136     dbg_err_if (!(b = tls_get_file_bio(res_name)));
00137 
00138     <span class="keywordflow">for</span> (;;)
00139     {
00140         <span class="keywordflow">if</span> (!PEM_read_bio_X509(b, &amp;x, NULL, NULL))
00141             <span class="keywordflow">break</span>;
00142 
00143         dbg_err_if (!(xn = X509_get_subject_name(x)));
00144 
00145         <span class="comment">/* check for duplicates */</span>
00146         dbg_err_if (!(xn = X509_NAME_dup(xn)));
00147         <span class="keywordflow">if</span> (sk_X509_NAME_find(sk, xn) &gt;= 0)
00148             X509_NAME_free(xn);
00149         <span class="keywordflow">else</span>
00150         {
00151             sk_X509_NAME_push(sk, xn);
00152             sk_X509_NAME_push(ret, xn);
00153         }
00154     }
00155 
00156     sk_X509_NAME_free(sk);
00157     BIO_free(b);
00158     X509_free(x);
00159 
00160     <span class="keywordflow">return</span> ret;
00161 err:
00162     <span class="keywordflow">if</span> (ret)
00163     {
00164         sk_X509_NAME_pop_free(ret, X509_NAME_free);
00165         ret = NULL;
00166     }
00167     <span class="keywordflow">if</span> (sk)
00168         sk_X509_NAME_free(sk);
00169     <span class="keywordflow">if</span> (b)
00170         BIO_free(b);
00171     <span class="keywordflow">if</span> (x)
00172         X509_free(x);
00173 
00174     <span class="keywordflow">return</span> ret;
00175 }
00176 
00177 <span class="comment">/* basically a wrapper for SSL_CTX_use_certificate() */</span>
00178 <span class="keywordtype">int</span> tls_use_certificate_file (SSL_CTX *ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *res_name, <span class="keywordtype">int</span> type)
00179 {
00180     BIO *b = NULL;
00181     <span class="keywordtype">int</span> ret = 0;
00182     X509 *x = NULL;
00183 
00184     dbg_return_if (!ctx, 0);
00185     dbg_return_if (!res_name, 0);
00186     dbg_return_if (type != SSL_FILETYPE_PEM, 0);
00187 
00188     dbg_goto_if (!(b = tls_get_file_bio(res_name)), end);
00189     dbg_goto_if (!(x = PEM_read_bio_X509(b, NULL, NULL, NULL)), end);
00190     ret = SSL_CTX_use_certificate(ctx, x);
00191     <span class="comment">/* fall through */</span>
00192 end:
00193     <span class="keywordflow">if</span> (x)
00194         X509_free(x);
00195     <span class="keywordflow">if</span> (b)
00196         BIO_free(b);
00197 
00198     <span class="keywordflow">return</span> ret;
00199 }
00200 
00201 <span class="keywordtype">int</span> tls_use_crls (SSL_CTX *ctx, tls_ctx_args_t *cargs)
00202 {
00203 <span class="preprocessor">#if OPENSSL_VERSION_NUMBER &gt;= 0x00907000L</span>
00204 <span class="preprocessor"></span>    <span class="keywordtype">int</span> count;
00205     BIO *b = NULL;
00206     X509_CRL *crl = NULL;
00207     X509_STORE *store;
00208 
00209     dbg_return_if (cargs == NULL, ~0);
00210     dbg_return_if (cargs-&gt;crl == NULL, ~0);
00211 
00212     <span class="comment">/* get X509 STORE i.e. client certificate verify context */</span>
00213     dbg_err_if ((store = SSL_CTX_get_cert_store(ctx)) == NULL);
00214 
00215     <span class="comment">/* read CRL from the resource (embfs or fs) */</span>
00216     dbg_err_if ((b = tls_get_file_bio(cargs-&gt;crl)) == NULL);
00217 
00218     <span class="comment">/* get CRLs one by one out of 'cargs-&gt;crl' */</span>
00219     <span class="keywordflow">for</span> (count = 0; ; count++)
00220     {
00221         crl = PEM_read_bio_X509_CRL(b, NULL, NULL, NULL);
00222 
00223         <span class="keywordflow">if</span> (crl == NULL)
00224         {
00225             u_long e = ERR_peek_last_error();
00226 
00227             <span class="keywordflow">if</span> (ERR_GET_REASON(e) == PEM_R_NO_START_LINE &amp;&amp; count &gt; 0)
00228             {
00229                 ERR_clear_error();
00230                 <span class="keywordflow">break</span>;
00231             } 
00232             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count == 0)
00233                 warn_err(<span class="stringliteral">"no CRL found in file \'%s\'"</span>, cargs-&gt;crl);
00234             <span class="keywordflow">else</span>
00235                 warn_err(<span class="stringliteral">"bad CRL (%d) in file \'%s\'"</span>, count, cargs-&gt;crl);
00236         }
00237 
00238         <span class="comment">/* add CRL to the verify ctx */</span>
00239         dbg_err_if (!X509_STORE_add_crl(store, crl));
00240         X509_CRL_free(crl);
00241         crl = NULL;
00242     }
00243  
00244     <span class="comment">/* say to openssl how we want to check certificate revocation status:</span>
00245 <span class="comment">     * every cert in chain or just the client certificate */</span>
00246     X509_STORE_set_flags(store, cargs-&gt;crlopts);
00247 
00248     BIO_free(b);
00249 
00250     <span class="keywordflow">return</span> 0;
00251 err:
00252     <span class="keywordflow">if</span> (b)
00253         BIO_free(b);
00254     <span class="keywordflow">if</span> (crl)
00255         X509_CRL_free(crl);
00256 
00257     <span class="keywordflow">return</span> ~0;
00258 <span class="preprocessor">#else</span>
00259 <span class="preprocessor"></span>    u_unused_args(ctx, cargs);
00260     warn(<span class="stringliteral">"OpenSSL too old (%d): CRL configuration directives won't be honoured"</span>,
00261             OPENSSL_VERSION_NUMBER);
00262     <span class="keywordflow">return</span> 0;
00263 <span class="preprocessor">#endif  </span>
00264 <span class="preprocessor"></span>}
00265 
00266 <span class="comment">/* wrapper for SSL_CTX_use_PrivateKey() */</span>
00267 <span class="keywordtype">int</span> tls_use_PrivateKey_file (SSL_CTX *ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *res_name, <span class="keywordtype">int</span> type)
00268 {
00269     <span class="keywordtype">int</span> ret = 0;
00270     BIO *b = NULL;
00271     EVP_PKEY *pkey = NULL;
00272 
00273     dbg_return_if (!ctx, 0);
00274     dbg_return_if (!res_name, 0);
00275     dbg_return_if (type != SSL_FILETYPE_PEM, 0);
00276 
00277     dbg_goto_if (!(b = tls_get_file_bio(res_name)), end);
00278     dbg_goto_if (!(pkey = PEM_read_bio_PrivateKey(b, NULL, NULL, NULL)), end);
00279     ret = SSL_CTX_use_PrivateKey(ctx, pkey);
00280     EVP_PKEY_free(pkey);
00281     <span class="comment">/* fall through */</span>
00282 end:
00283     <span class="keywordflow">if</span> (b)
00284         BIO_free(b);
00285 
00286     <span class="keywordflow">return</span> ret;
00287 }
00288 
00289 <span class="comment">/* Read a file that optionally contains the server certificate in PEM</span>
00290 <span class="comment"> * format, possibly followed by a sequence of CA certificates that</span>
00291 <span class="comment"> * should be sent to the peer in the SSL Certificate message.  */</span>
00292 <span class="keywordtype">int</span> tls_use_certificate_chain (SSL_CTX *ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *res_name, 
00293         <span class="keywordtype">int</span> skipfirst, <span class="keywordtype">int</span> (*cb)(<span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">void</span> *)) 
00294 {
00295     BIO *b = NULL;
00296     X509 *x = NULL;
00297     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> err;
00298     <span class="keywordtype">int</span> n;
00299 
00300     dbg_return_if (!ctx, -1);
00301     dbg_return_if (!res_name, -1);
00302 
00303     dbg_err_if (!(b = tls_get_file_bio(res_name)));
00304 
00305     <span class="comment">/* optionally skip a leading server certificate */</span>
00306     <span class="keywordflow">if</span> (skipfirst)
00307     {
00308         dbg_err_if (!(x = PEM_read_bio_X509(b, NULL, cb, NULL)));
00309         X509_free(x);
00310         x = NULL;
00311     }
00312 
00313     <span class="comment">/* free a perhaps already configured extra chain */</span>
00314     <span class="keywordflow">if</span> (!ctx-&gt;extra_certs)
00315     {
00316         sk_X509_pop_free(ctx-&gt;extra_certs, X509_free);
00317         ctx-&gt;extra_certs = NULL;
00318     }
00319 
00320     <span class="comment">/* create new extra chain by loading the certs */</span>
00321     n = 0;
00322     <span class="keywordflow">while</span> ((x = PEM_read_bio_X509(b, NULL, cb, NULL))) 
00323     {
00324         dbg_err_if (!SSL_CTX_add_extra_chain_cert(ctx, x));
00325         n++;
00326     }
00327 
00328     <span class="comment">/* Make sure that only the error is just an EOF */</span>
00329     <span class="keywordflow">if</span> ((err = ERR_peek_error()) &gt; 0) 
00330     {
00331         dbg_err_if (!(ERR_GET_LIB(err) == ERR_LIB_PEM &amp;&amp; 
00332                     ERR_GET_REASON(err) == PEM_R_NO_START_LINE));
00333 
00334         <span class="keywordflow">while</span> (ERR_get_error() &gt; 0) ;
00335     }
00336 
00337     BIO_free(b);
00338 
00339     <span class="keywordflow">return</span> n;
00340 err:
00341     <span class="keywordflow">if</span> (b)
00342         BIO_free(b);
00343     <span class="keywordflow">if</span> (x)
00344         X509_free(x);
00345 
00346     <span class="keywordflow">return</span> -1;
00347 }
00348 
00349 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_LIBOPENSSL */</span>
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


