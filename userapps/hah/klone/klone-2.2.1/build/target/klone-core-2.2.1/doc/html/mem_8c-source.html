<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: mem.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>mem.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: mem.c,v 1.12 2006/01/10 21:51:41 tat Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;time.h&gt;</span>
00013 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00014 <span class="preprocessor">#include &lt;klone/klog.h&gt;</span>
00015 <span class="preprocessor">#include &lt;klone/klogprv.h&gt;</span>
00016 
00017 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_mem_msg_new (<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> level, klog_mem_msg_t **pmmsg);
00018 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_mem_msg_push (klog_mem_t *klm, klog_mem_msg_t *mmsg);
00019 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_mem_msg_free (klog_mem_msg_t *mmsg);
00020 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_mem_msgs_free (klog_mem_t *klm);
00021 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_free_mem (klog_mem_t *klm);
00022 
00023 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_mem (klog_t *kl, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap);
00024 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_getln_mem (klog_t *kl, size_t nth, <span class="keywordtype">char</span> ln[]);
00025 <span class="keyword">static</span> ssize_t klog_countln_mem (klog_t *kl);
00026 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_close_mem (klog_t *kl);
00027 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_clear_mem (klog_t *kl);
00028 
00029 <span class="comment">/* mem log type initialisation */</span>
00030 <span class="keywordtype">int</span> klog_open_mem (klog_t *kl, size_t ln_max)
00031 {
00032     klog_mem_t *klm = NULL;
00033 
00034     dbg_return_if (kl == NULL, ~0);
00035 
00036     <span class="comment">/* create a new klog_mem_t object */</span>
00037     klm = u_zalloc(<span class="keyword">sizeof</span>(klog_mem_t));
00038     dbg_err_if (klm == NULL);
00039     
00040     <span class="comment">/* initialise the klog_mem_t object to the supplied values */</span>
00041     klm-&gt;bound = ln_max ? ln_max : 1;   <span class="comment">/* set at least a 1 msg window :) */</span>
00042     klm-&gt;nmsgs = 0;
00043     TAILQ_INIT(&amp;klm-&gt;msgs);
00044 
00045     <span class="comment">/* set private methods */</span>
00046     kl-&gt;cb_log = klog_mem;
00047     kl-&gt;cb_close = klog_close_mem;
00048     kl-&gt;cb_getln = klog_getln_mem;
00049     kl-&gt;cb_countln = klog_countln_mem;
00050     kl-&gt;cb_clear = klog_clear_mem;
00051     kl-&gt;cb_flush = NULL;
00052 
00053     <span class="comment">/* stick the klog_mem_t object to its parent */</span>
00054     kl-&gt;u.m = klm, klm = NULL;
00055 
00056     <span class="keywordflow">return</span> 0;
00057 err:
00058     <span class="keywordflow">if</span> (klm)
00059         klog_free_mem(klm);
00060     <span class="keywordflow">return</span> ~0;
00061 }
00062 
00063 <span class="comment">/* write a log msg to memory */</span>
00064 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_mem (klog_t *kl, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap)
00065 {
00066     klog_mem_t *klm;
00067     <span class="keywordtype">char</span> ln[KLOG_LN_SZ + 1];
00068     klog_mem_msg_t *mmsg = NULL;
00069 
00070     dbg_return_if (kl == NULL, ~0);
00071     dbg_return_if (kl-&gt;type != KLOG_TYPE_MEM, ~0);
00072     dbg_return_if (kl-&gt;u.m == NULL, ~0);
00073     dbg_return_if (fmt == NULL, ~0);
00074 
00075     klm = kl-&gt;u.m;
00076 
00077     <span class="comment">/* NOTE: could check overflow here */</span>
00078     vsnprintf(ln, <span class="keyword">sizeof</span> ln, fmt, ap);
00079     dbg_err_if (klog_mem_msg_new(ln, level, &amp;mmsg));
00080     dbg_err_if (klog_mem_msg_push(klm, mmsg));
00081     mmsg = NULL;
00082 
00083     <span class="keywordflow">return</span> 0;
00084 err:
00085     <span class="keywordflow">if</span> (mmsg)
00086         klog_mem_msg_free(mmsg);
00087     <span class="keywordflow">return</span> ~0;
00088 }
00089 
00090 <span class="comment">/* elements are retrieved in reverse order with respect to insertion */</span>
00091 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_getln_mem (klog_t *kl, size_t nth, <span class="keywordtype">char</span> ln[])
00092 {
00093     size_t i = nth;
00094     klog_mem_msg_t *cur; 
00095     <span class="keywordtype">char</span> *ct;
00096     klog_mem_t *klm;
00097 
00098     dbg_return_if (kl == NULL, ~0);
00099     dbg_return_if (kl-&gt;type != KLOG_TYPE_MEM, ~0);
00100     dbg_return_if (kl-&gt;u.m == NULL, ~0);
00101     nop_return_if (nth &gt; kl-&gt;u.m-&gt;nmsgs, ~0);
00102     dbg_return_if (nth == 0, ~0);
00103 
00104     klm = kl-&gt;u.m;
00105 
00106     TAILQ_FOREACH (cur, &amp;klm-&gt;msgs, next)
00107     {
00108         <span class="keywordflow">if</span> (i-- == 1)
00109             <span class="keywordflow">break</span>;
00110     }
00111     
00112     ct = ctime((<span class="keyword">const</span> time_t *) &amp;cur-&gt;timestamp);
00113     ct[24] = <span class="charliteral">'\0'</span>;
00114 
00115     <span class="comment">/* </span>
00116 <span class="comment">     * line format is:</span>
00117 <span class="comment">     *      [DEBUG] Sep 23 13:26:19 &lt;ident&gt;: log message line.</span>
00118 <span class="comment">     */</span>
00119     snprintf(ln, KLOG_LN_SZ + 1, <span class="stringliteral">"[%s] %s &lt;%s&gt;: %s"</span>, 
00120              klog_to_str(cur-&gt;level), ct, kl-&gt;ident, cur-&gt;line);
00121 
00122     <span class="keywordflow">return</span> 0;
00123 }
00124 
00125 <span class="keyword">static</span> ssize_t klog_countln_mem (klog_t *kl)
00126 {
00127     dbg_return_if (kl == NULL, -1);
00128     dbg_return_if (kl-&gt;type != KLOG_TYPE_MEM, -1);
00129     dbg_return_if (kl-&gt;u.m == NULL, -1);
00130 
00131     <span class="keywordflow">return</span> kl-&gt;u.m-&gt;nmsgs;
00132 }
00133 
00134 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_close_mem (klog_t *kl)
00135 {
00136     <span class="keywordflow">if</span> (kl == NULL || kl-&gt;type != KLOG_TYPE_MEM || kl-&gt;u.m == NULL)
00137         <span class="keywordflow">return</span>;
00138 
00139     klog_free_mem(kl-&gt;u.m), kl-&gt;u.m = NULL;
00140 
00141     <span class="keywordflow">return</span>;
00142 }
00143 
00144 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_free_mem (klog_mem_t *klm)
00145 {
00146     <span class="keywordflow">if</span> (klm == NULL)
00147         <span class="keywordflow">return</span>;
00148     klog_mem_msgs_free(klm);
00149     U_FREE(klm);
00150     <span class="keywordflow">return</span>;
00151 }
00152 
00153 <span class="comment">/* cancel all log messages but retain header information */</span>
00154 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_clear_mem (klog_t *kl)
00155 {
00156     klog_mem_t *klm;
00157 
00158     dbg_return_if (kl == NULL, ~0);
00159     dbg_return_if (kl-&gt;type != KLOG_TYPE_MEM, ~0);
00160     dbg_return_if (kl-&gt;u.m == NULL, ~0);
00161 
00162     klm = kl-&gt;u.m;
00163 
00164     <span class="comment">/* wipe out all msgs in buffer */</span>
00165     klog_mem_msgs_free(klm);
00166 
00167     <span class="comment">/* reset header informations */</span>
00168     klm-&gt;nmsgs = 0;
00169     TAILQ_INIT(&amp;klm-&gt;msgs);
00170 
00171     <span class="keywordflow">return</span> 0;
00172 }
00173 
00174 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_mem_msgs_free (klog_mem_t *klm)
00175 {
00176     klog_mem_msg_t *mmsg;
00177 
00178     dbg_ifb (klm == NULL) <span class="keywordflow">return</span>;
00179     
00180     <span class="keywordflow">while</span>((mmsg = TAILQ_FIRST(&amp;klm-&gt;msgs)) != NULL)
00181     {
00182         TAILQ_REMOVE(&amp;klm-&gt;msgs, mmsg, next);
00183         klm-&gt;nmsgs--;
00184         klog_mem_msg_free(mmsg);
00185     }
00186 
00187     <span class="keywordflow">return</span>;
00188 }
00189 
00190 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_mem_msg_new (<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> level, klog_mem_msg_t **pmmsg)
00191 {
00192     klog_mem_msg_t *mmsg = NULL;
00193 
00194     dbg_return_if (s == NULL, ~0);
00195     dbg_return_if (pmmsg == NULL, ~0);
00196 
00197     mmsg = u_zalloc(<span class="keyword">sizeof</span>(klog_mem_msg_t));
00198     dbg_err_if (mmsg == NULL);
00199 
00200     mmsg-&gt;line = u_strndup(s, KLOG_LN_SZ);
00201     mmsg-&gt;timestamp = time(NULL);
00202     mmsg-&gt;level = level;
00203 
00204     *pmmsg = mmsg;
00205 
00206     <span class="keywordflow">return</span> 0;
00207 
00208 err:
00209     <span class="keywordflow">if</span> (mmsg)
00210         klog_mem_msg_free(mmsg);
00211     <span class="keywordflow">return</span> ~0;
00212 }
00213 
00214 <span class="keyword">static</span> <span class="keywordtype">int</span> klog_mem_msg_push (klog_mem_t *klm, klog_mem_msg_t *mmsg)
00215 {
00216     dbg_return_if (klm == NULL, ~0);
00217     dbg_return_if (mmsg == NULL, ~0);
00218 
00219     <span class="comment">/* push out first-in element on KLOG_MEM_FULL event */</span>
00220     <span class="keywordflow">if</span> (KLOG_MEM_FULL(klm))
00221     {
00222         klog_mem_msg_t *last = TAILQ_LAST(&amp;klm-&gt;msgs, mh);
00223 
00224         <span class="comment">/* last == NULL on KLOG_MEM_FULL should never happen :-) */</span>
00225         <span class="keywordflow">if</span> (last != NULL)
00226         {
00227             TAILQ_REMOVE(&amp;klm-&gt;msgs, last, next);
00228             klog_mem_msg_free(last);
00229             klm-&gt;nmsgs--;
00230         }
00231     }
00232 
00233     TAILQ_INSERT_HEAD(&amp;klm-&gt;msgs, mmsg, next);
00234     klm-&gt;nmsgs++;
00235 
00236     <span class="keywordflow">return</span> 0;
00237 }
00238 
00239 <span class="keyword">static</span> <span class="keywordtype">void</span> klog_mem_msg_free (klog_mem_msg_t *mmsg)
00240 {
00241     dbg_ifb (mmsg == NULL) <span class="keywordflow">return</span>;
00242 
00243     U_FREE(mmsg-&gt;line);
00244     U_FREE(mmsg);
00245 
00246     <span class="keywordflow">return</span>;
00247 }
00248 
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


