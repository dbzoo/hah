<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LibU: str.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>str.c</h1><div class="fragment"><pre>00001 <span class="comment">/* </span>
00002 <span class="comment"> * Copyright (c) 2005-2008 by KoanLogic s.r.l. - All rights reserved.  </span>
00003 <span class="comment"> */</span>
00004 
00005 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00006 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00007 
00008 <span class="preprocessor">#include &lt;toolbox/str.h&gt;</span>
00009 <span class="preprocessor">#include &lt;toolbox/misc.h&gt;</span>
00010 <span class="preprocessor">#include &lt;toolbox/carpal.h&gt;</span>
00011 <span class="preprocessor">#include &lt;toolbox/memory.h&gt;</span>
00012 
00018 <span class="comment">/* null strings will be bound to the null char* */</span>
00019 <span class="keyword">static</span> <span class="keywordtype">char</span> null_cstr[1] = { 0 };
00020 <span class="keyword">static</span> <span class="keywordtype">char</span>* null = null_cstr;
00021 
00022 <span class="comment">/* internal string struct */</span>
00023 <span class="keyword">struct </span>u_string_s
00024 {
00025     <span class="keywordtype">char</span> *data;
00026     size_t data_sz, data_len, shift_cnt;
00027 };
00028 
00029 <span class="keyword">static</span> <span class="keywordtype">int</span> u_string_do_vprintf(u_string_t *, <span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *, va_list);
00030 
<a name="l00040"></a><a class="code" href="group__string.html#ga3">00040</a> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga3">u_string_trim</a>(u_string_t *s)
00041 {
00042     <span class="keywordflow">if</span>(s-&gt;data_len)
00043     {
00044         <a class="code" href="group__misc.html#ga1">u_trim</a>(s-&gt;data);
00045 
00046         s-&gt;data_len = strlen(s-&gt;data);
00047     }
00048 
00049     <span class="keywordflow">return</span> 0;
00050 }
00051 
<a name="l00061"></a><a class="code" href="group__string.html#ga4">00061</a> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga4">u_string_set_length</a>(u_string_t *s, size_t len)
00062 {
00063     dbg_err_if(len &gt; s-&gt;data_len);
00064 
00065     <span class="keywordflow">if</span>(len &lt; s-&gt;data_len)
00066     {
00067         s-&gt;data_len = len;
00068         s-&gt;data[len] = 0;
00069     }
00070 
00071     <span class="keywordflow">return</span> 0;
00072 err:
00073     <span class="keywordflow">return</span> ~0;
00074 }
00075 
<a name="l00085"></a><a class="code" href="group__string.html#ga5">00085</a> <span class="keyword">inline</span> size_t <a class="code" href="group__string.html#ga5">u_string_len</a>(u_string_t *s)
00086 {
00087     <span class="keywordflow">return</span> s-&gt;data_len;
00088 }
00089 
<a name="l00100"></a><a class="code" href="group__string.html#ga6">00100</a> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__string.html#ga6">u_string_c</a>(u_string_t *s)
00101 {
00102     <span class="keywordflow">return</span> s-&gt;data;
00103 }
00104 
<a name="l00115"></a><a class="code" href="group__string.html#ga7">00115</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga7">u_string_copy</a>(u_string_t *dst, u_string_t *src)
00116 {
00117     <a class="code" href="group__string.html#ga8">u_string_clear</a>(dst);
00118     <span class="keywordflow">return</span> <a class="code" href="group__string.html#ga14">u_string_append</a>(dst, src-&gt;data, src-&gt;data_len);
00119 }
00120 
<a name="l00130"></a><a class="code" href="group__string.html#ga8">00130</a> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga8">u_string_clear</a>(u_string_t *s)
00131 {
00132     <span class="comment">/* clear the string but not deallocate the buffer */</span>
00133     <span class="keywordflow">if</span>(s-&gt;data_sz)
00134     {
00135         s-&gt;data[0] = 0;
00136         s-&gt;data_len = 0;
00137     }
00138 
00139     <span class="keywordflow">return</span> 0;
00140 }
00141 
<a name="l00156"></a><a class="code" href="group__string.html#ga9">00156</a> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga9">u_string_create</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t len, u_string_t **ps)
00157 {
00158     u_string_t *s = NULL;
00159 
00160     s = <a class="code" href="group__alloc.html#ga6">u_zalloc</a>(<span class="keyword">sizeof</span>(u_string_t));
00161     dbg_err_sif(s == NULL);
00162 
00163     s-&gt;data = null;
00164 
00165     <span class="keywordflow">if</span>(buf)
00166         dbg_err_if(<a class="code" href="group__string.html#ga14">u_string_append</a>(s, buf, len));
00167 
00168     *ps = s;
00169 
00170     <span class="keywordflow">return</span> 0;
00171 err:
00172     <span class="keywordflow">return</span> ~0;
00173 }
00174 
00175 
<a name="l00185"></a><a class="code" href="group__string.html#ga10">00185</a> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga10">u_string_free</a>(u_string_t *s)
00186 {
00187     <span class="keywordflow">if</span>(s)
00188     {
00189         <span class="keywordflow">if</span>(s-&gt;data_sz)
00190             U_FREE(s-&gt;data);
00191         U_FREE(s);
00192     }
00193     <span class="keywordflow">return</span> 0;
00194 }
00195 
00196 
<a name="l00208"></a><a class="code" href="group__string.html#ga11">00208</a> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga11">u_string_set</a>(u_string_t *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t len)
00209 {
00210     <a class="code" href="group__string.html#ga8">u_string_clear</a>(s);
00211     <span class="keywordflow">return</span> <a class="code" href="group__string.html#ga14">u_string_append</a>(s, buf, len);
00212 }
00213 
<a name="l00224"></a><a class="code" href="group__string.html#ga12">00224</a> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga12">u_string_reserve</a>(u_string_t *s, size_t size)
00225 {
00226     <span class="keywordtype">char</span> *nbuf;
00227 
00228     dbg_err_if(s == NULL);
00229 
00230     <span class="keywordflow">if</span>(size &lt;= s-&gt;data_sz)
00231         <span class="keywordflow">return</span> 0; <span class="comment">/* nothing to do */</span>
00232    
00233     <span class="comment">/* size plus 1 char to store a '\0' */</span>
00234     nbuf = <a class="code" href="group__alloc.html#ga7">u_realloc</a>( ((s-&gt;data == null) ? NULL : s-&gt;data), size+1);
00235     dbg_err_if(nbuf == NULL);
00236 
00237     <span class="comment">/* zero terminate it */</span>
00238     nbuf[size] = 0;
00239 
00240     s-&gt;data = (<span class="keywordtype">void</span>*)nbuf;
00241     s-&gt;data_sz = size;
00242 
00243     <span class="keywordflow">return</span> 0;
00244 err:
00245     <span class="keywordflow">return</span> ~0;
00246 }
00247 
00248 
00249 <span class="keyword">static</span> <span class="keywordtype">int</span> u_string_do_vprintf(u_string_t *s, <span class="keywordtype">int</span> clear, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, 
00250         va_list ap)
00251 {
00252     size_t sz, avail;
00253     va_list apcpy;
00254 
00255     dbg_return_if(s == NULL, ~0);
00256     dbg_return_if(fmt == NULL, ~0);
00257 
00258     <span class="keywordflow">if</span>(clear)
00259         <a class="code" href="group__string.html#ga8">u_string_clear</a>(s);
00260 
00261 again:
00262     avail = s-&gt;data_sz - s-&gt;data_len; <span class="comment">/* avail may be zero */</span>
00263 
00264     <span class="comment">/* copy ap to avoid using it twice when realloc'ing */</span>
00265     u_va_copy(apcpy, ap); 
00266 
00267     <span class="comment">/* write to the internal buffer of the string.</span>
00268 <span class="comment">     * if the return value is greater than or equal to the size argument, </span>
00269 <span class="comment">     * the string was too short and some of the printed characters were </span>
00270 <span class="comment">     * discarded; in that case realloc a bigger buffer and retry */</span>
00271     sz = vsnprintf(s-&gt;data + s-&gt;data_len, avail, fmt, apcpy);
00272 
00273     va_end(apcpy);
00274 
00275     <span class="keywordflow">if</span> (sz &gt;= avail)
00276     {
00277 
00278         dbg_err_if(<a class="code" href="group__string.html#ga12">u_string_reserve</a>(s, s-&gt;data_sz + s-&gt;data_len + 2*sz + 1));
00279 
00280         <span class="comment">/* trunc the buffer again since vsnprintf could have overwritten '\0' */</span>
00281         s-&gt;data[s-&gt;data_len] = 0;
00282 
00283         <span class="keywordflow">goto</span> again;
00284     }
00285 
00286     <span class="comment">/* update string length */</span>
00287     s-&gt;data_len += sz; 
00288 
00289     <span class="keywordflow">return</span> 0;
00290 err:
00291     <span class="keywordflow">return</span> ~0;
00292 }
00293 
00294 <span class="keywordtype">int</span> u_string_do_printf(u_string_t *s, <span class="keywordtype">int</span> clear, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
00295 {
00296     va_list ap;
00297 
00298     va_start(ap, fmt);
00299     dbg_err_if (u_string_do_vprintf(s, clear, fmt, ap));
00300     va_end(ap);
00301 
00302     <span class="keywordflow">return</span> 0;
00303 err:
00304     va_end(ap);
00305     <span class="keywordflow">return</span> ~0;
00306 }
00307 
00308 
<a name="l00320"></a><a class="code" href="group__string.html#ga14">00320</a> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga14">u_string_append</a>(u_string_t *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t len)
00321 {
00322     size_t nsz, min;
00323 
00324     <span class="keywordflow">if</span>(!len)
00325         <span class="keywordflow">return</span> 0; <span class="comment">/* nothing to do */</span>
00326 
00327     <span class="comment">/* if there's not enough space on s-&gt;data alloc a bigger buffer */</span>
00328     <span class="keywordflow">if</span>(s-&gt;data_len + len + 1 &gt; s-&gt;data_sz)
00329     {
00330         min = s-&gt;data_len + len + 1; <span class="comment">/* min required buffer length */</span>
00331         nsz = s-&gt;data_sz;
00332         <span class="keywordflow">while</span>(nsz &lt;= min)
00333             nsz += (BLOCK_SIZE &lt;&lt; s-&gt;shift_cnt++);
00334 
00335         dbg_err_if(<a class="code" href="group__string.html#ga12">u_string_reserve</a>(s, nsz));
00336     }
00337 
00338     <span class="comment">/* append this chunk to the data buffer */</span>
00339     strncpy(s-&gt;data + s-&gt;data_len, buf, len);
00340     s-&gt;data_len += len;
00341     s-&gt;data[s-&gt;data_len] = 0;
00342     
00343     <span class="keywordflow">return</span> 0;
00344 err:
00345     <span class="keywordflow">return</span> ~0;
00346 }
00347 
00360 <span class="keywordtype">int</span> u_string_sprintf(u_string_t *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
00361 {
00362     va_list ap;
00363 
00364     va_start(ap, fmt);
00365     dbg_err_if (u_string_do_vprintf(s, 1, fmt, ap));
00366     va_end(ap);
00367 
00368     <span class="keywordflow">return</span> 0;
00369 err:
00370     va_end(ap);
00371     <span class="keywordflow">return</span> ~0;
00372 }
00373 
00374 
<a name="l00386"></a><a class="code" href="group__string.html#ga16">00386</a> <span class="keywordtype">int</span> <a class="code" href="group__string.html#ga16">u_string_aprintf</a>(u_string_t *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
00387 {
00388     va_list ap;
00389 
00390     va_start(ap, fmt);
00391     dbg_err_if (u_string_do_vprintf(s, 0, fmt, ap));
00392     va_end(ap);
00393 
00394     <span class="keywordflow">return</span> 0;
00395 err:
00396     va_end(ap);
00397     <span class="keywordflow">return</span> ~0;
00398 }
00399 
00400 
</pre></div><hr>
<div>
  <div style="text-align:left">
    <a href="http://www.koanlogic.com/kl/cont/gb/html/products.html">&larr;Products</a>
  </div>
  <div style="text-align:center;">
    &copy; 2005-2008 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
  </div>
</div>

</body>
</html>
