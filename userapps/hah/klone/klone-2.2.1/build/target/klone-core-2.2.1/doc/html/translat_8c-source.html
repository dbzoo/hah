<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KLone: translat.c Source File</title>
<link href="kl.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>translat.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 2005, 2006 by KoanLogic s.r.l. &lt;http://www.koanlogic.com&gt;</span>
00003 <span class="comment"> * All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This file is part of KLone, and as such it is subject to the license stated</span>
00006 <span class="comment"> * in the LICENSE file which you have received as part of this distribution.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * $Id: translat.c,v 1.32 2009/05/29 10:26:01 tho Exp $</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#include "klone_conf.h"</span>
00012 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00013 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00014 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00015 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00016 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00017 <span class="preprocessor">#include &lt;limits.h&gt;</span>
00018 <span class="preprocessor">#ifdef HAVE_LIBOPENSSL</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#include &lt;openssl/evp.h&gt;</span>
00020 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_LIBOPENSSL */</span>
00021 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
00022 <span class="preprocessor">#include &lt;klone/os.h&gt;</span>
00023 <span class="preprocessor">#include &lt;klone/translat.h&gt;</span>
00024 <span class="preprocessor">#include &lt;klone/parser.h&gt;</span>
00025 <span class="preprocessor">#include &lt;klone/utils.h&gt;</span>
00026 <span class="preprocessor">#include &lt;klone/os.h&gt;</span>
00027 <span class="preprocessor">#include &lt;klone/io.h&gt;</span>
00028 <span class="preprocessor">#include &lt;klone/codec.h&gt;</span>
00029 <span class="preprocessor">#include &lt;klone/codecs.h&gt;</span>
00030 
00031 <span class="preprocessor">#define tr_err(...)             \</span>
00032 <span class="preprocessor">    do  { con_p_ctx(p); con_err(__VA_ARGS__); } while(0)</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define tr_err_if(expr)          \</span>
00034 <span class="preprocessor">    do { if( (expr) ) { con_p_ctx(p); con("%s", #expr); goto err; } } while(0)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define tr_err_ifm(expr, ...)    \</span>
00036 <span class="preprocessor">    do { if( (expr) ) { con_p_ctx(p); con(__VA_ARGS__); goto err; } } while(0)</span>
00037 <span class="preprocessor"></span>
00038 
00039 <span class="keyword">typedef</span> <span class="keyword">struct </span>block_s
00040 {
00041     <span class="keywordtype">char</span> *name;                 <span class="comment">/* block name (is NULL for unnamed blocks) */</span>
00042     u_buf_t *ubuf;              <span class="comment">/* block content */</span>
00043     <span class="keyword">struct </span>block_s *parent;     <span class="comment">/* the parent block in the block tree */</span>
00044     <span class="keyword">struct </span>block_s *ancestor;   <span class="comment">/* the ancestor block this block overrides */</span>
00045     u_list_t *children;         <span class="comment">/* list of children blocks */</span>
00046 } block_t;
00047 
00048 <span class="keyword">typedef</span> <span class="keyword">struct </span>ppctx_s
00049 {
00050     block_t *cur;       <span class="comment">/* currently selected block */</span>
00051     block_t *top;       <span class="comment">/* top block in the tree */</span>
00052     block_t *dead;      <span class="comment">/* tree for dead blocks */</span>
00053     <span class="keywordtype">int</span> lev;            <span class="comment">/* blocks nesting level */</span>
00054     <span class="keywordtype">int</span> extending;      <span class="comment">/* nesting level from the extended block */</span>
00055     u_list_t *depend;   <span class="comment">/* list of depends (path+filename) */</span>
00056 } ppctx_t;
00057 
00058 <span class="keyword">static</span> <span class="keywordtype">int</span> preprocess(io_t *in, io_t *out, ppctx_t*);
00059 
00060 <span class="keyword">static</span> <span class="keywordtype">int</span> block_free(block_t *block)
00061 {
00062     block_t *child;
00063     <span class="keywordtype">int</span> i;
00064 
00065     dbg_err_if(block == NULL);
00066 
00067     <span class="comment">/* free children first */</span>
00068     <span class="keywordflow">for</span>(i = 0; (child = u_list_get_n(block-&gt;children, i)) != NULL; ++i)
00069         block_free(child);
00070 
00071     <span class="keywordflow">if</span>(block-&gt;ancestor)
00072         block_free(block-&gt;ancestor);
00073 
00074     <span class="keywordflow">if</span>(block-&gt;name)
00075         u_free(block-&gt;name);
00076 
00077     <span class="keywordflow">if</span>(block-&gt;ubuf)
00078         u_buf_free(block-&gt;ubuf);
00079 
00080     u_free(block);
00081 
00082     <span class="keywordflow">return</span> 0;
00083 err:
00084     <span class="keywordflow">return</span> ~0;
00085 }
00086 
00087 <span class="keyword">static</span> <span class="keywordtype">int</span> block_push_child(block_t *parent, block_t *child)
00088 {
00089     dbg_err_if(u_list_add(parent-&gt;children, child));
00090 
00091     child-&gt;parent = parent;
00092 
00093     <span class="keywordflow">return</span> 0;
00094 err:
00095     <span class="keywordflow">return</span> ~0;
00096 }
00097 
00098 <span class="keyword">static</span> <span class="keywordtype">int</span> block_create(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t size, 
00099             block_t **pblock)
00100 {
00101     block_t *b = NULL;
00102 
00103     b = u_zalloc(<span class="keyword">sizeof</span>(block_t));
00104     dbg_err_if(b == NULL);
00105 
00106     dbg_err_if(u_buf_create(&amp;b-&gt;ubuf));
00107 
00108     dbg_err_if(u_list_create(&amp;b-&gt;children));
00109 
00110     <span class="keywordflow">if</span>(name)
00111     {
00112         b-&gt;name = u_strdup(name);
00113         dbg_err_if(b-&gt;name == NULL);
00114     }
00115 
00116     <span class="keywordflow">if</span>(buf &amp;&amp; size)
00117         dbg_err_if(u_buf_append(b-&gt;ubuf, buf, size));
00118 
00119     *pblock = b;
00120 
00121     <span class="keywordflow">return</span> 0;
00122 err:
00123     <span class="keywordflow">if</span>(b)
00124         block_free(b);
00125     <span class="keywordflow">return</span> ~0;
00126 }
00127 
00128 <span class="keyword">static</span> <span class="keywordtype">int</span> ppctx_print_block(block_t *block, io_t *out)
00129 {
00130     block_t *b;
00131     size_t i;
00132 
00133     <span class="keywordflow">if</span>(block-&gt;name == NULL)
00134     {
00135         <span class="keywordflow">if</span>(u_buf_len(block-&gt;ubuf))
00136             dbg_err_if(<a class="code" href="group__basic.html#ga19">io_write</a>(out, u_buf_ptr(block-&gt;ubuf), 
00137                         u_buf_len(block-&gt;ubuf)) &lt; 0);
00138     } <span class="keywordflow">else</span> {
00139         <span class="comment">/* named block */</span>
00140         <span class="keywordflow">for</span>(i = 0; (b = u_list_get_n(block-&gt;children, i)) != NULL; ++i)
00141             dbg_err_if(ppctx_print_block(b, out));
00142     }
00143 
00144     <span class="keywordflow">return</span> 0;
00145 err:
00146     <span class="keywordflow">return</span> ~0;
00147 }
00148 
00149 
00150 <span class="keyword">static</span> <span class="keywordtype">int</span> ppctx_depend_push(ppctx_t *ppc, <span class="keyword">const</span> <span class="keywordtype">char</span> *filepath)
00151 {
00152     <span class="keyword">const</span> <span class="keywordtype">char</span> *s;
00153 
00154     dbg_err_if((s = u_strdup(filepath)) == NULL);
00155 
00156     dbg_err_if(u_list_add(ppc-&gt;depend, (<span class="keywordtype">void</span>*)s));
00157 
00158     <span class="keywordflow">return</span> 0;
00159 err:
00160     <span class="keywordflow">return</span> ~0;
00161 }
00162 
00163 <span class="keyword">static</span> <span class="keywordtype">int</span> ppctx_print_depend(ppctx_t *ppc, io_t *in, io_t *out, io_t *depend)
00164 {
00165     <span class="keywordtype">char</span> infile[U_FILENAME_MAX], outfile[U_FILENAME_MAX];
00166     <span class="keywordtype">char</span> fullpath[U_FILENAME_MAX];
00167     <span class="keyword">const</span> <span class="keywordtype">char</span> *dfile;
00168     size_t i;
00169 
00170     dbg_err_if(ppc == NULL);
00171     dbg_err_if(in == NULL);
00172     dbg_err_if(out == NULL);
00173     dbg_err_if(depend == NULL);
00174 
00175     <span class="comment">/* print make-style depends list:</span>
00176 <span class="comment">       srcfile: depfile0 depfile1 ... depfileN */</span>
00177 
00178     dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(in, infile, U_FILENAME_MAX));
00179     dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(out, outfile, U_FILENAME_MAX));
00180 
00181     <span class="comment">/* input filename (makefile-style) */</span>
00182     dbg_err_if(translate_makefile_filepath(infile, <span class="stringliteral">"$(srcdir)"</span>, fullpath, 
00183         <span class="keyword">sizeof</span>(fullpath)));
00184 
00185     <a class="code" href="group__basic.html#ga28">io_printf</a>(depend, <span class="stringliteral">"%s %s.kld: %s "</span>, outfile, outfile, fullpath);
00186 
00187     <span class="keywordflow">for</span>(i = 0; (dfile = u_list_get_n(ppc-&gt;depend, i)) != NULL; ++i)
00188     {
00189         dbg_err_if(translate_makefile_filepath(dfile, <span class="stringliteral">"$(srcdir)"</span>, fullpath, 
00190             <span class="keyword">sizeof</span>(fullpath)));
00191         <a class="code" href="group__basic.html#ga28">io_printf</a>(depend, <span class="stringliteral">"%s "</span>, fullpath);
00192     }
00193     <a class="code" href="group__basic.html#ga28">io_printf</a>(depend, <span class="stringliteral">"\n"</span>);
00194 
00195     <span class="keywordflow">return</span> 0;
00196 err:
00197     <span class="keywordflow">return</span> ~0;
00198 
00199 }
00200 
00201 <span class="keyword">static</span> <span class="keywordtype">int</span> ppctx_print(ppctx_t *ppc, io_t *out)
00202 {
00203     block_t *b;
00204     size_t i;
00205 
00206     dbg_err_if(ppc == NULL);
00207     dbg_err_if(out == NULL);
00208 
00209     <span class="keywordflow">for</span>(i = 0; (b = u_list_get_n(ppc-&gt;top-&gt;children, i)) != NULL; ++i)
00210         dbg_err_if(ppctx_print_block(b, out));
00211 
00212     <span class="keywordflow">return</span> 0;
00213 err:
00214     <span class="keywordflow">return</span> ~0;
00215 
00216 }
00217 
00218 <span class="keyword">static</span> <span class="keywordtype">int</span> ppctx_free(ppctx_t *ppc)
00219 {
00220     <span class="keywordtype">char</span> *str;
00221     size_t i;
00222 
00223     <span class="keywordflow">if</span>(ppc-&gt;top)
00224         block_free(ppc-&gt;top);
00225 
00226     <span class="keywordflow">if</span>(ppc-&gt;dead)
00227         block_free(ppc-&gt;dead);
00228 
00229     <span class="keywordflow">if</span>(ppc-&gt;depend)
00230     {
00231         <span class="keywordflow">for</span>(i = 0; (str = u_list_get_n(ppc-&gt;depend, i)) != NULL; ++i)
00232             u_free(str);
00233 
00234         u_list_free(ppc-&gt;depend);
00235     }
00236 
00237     u_free(ppc);
00238 
00239     <span class="keywordflow">return</span> 0;
00240 }
00241 
00242 <span class="keyword">static</span> <span class="keywordtype">int</span> ppctx_create(ppctx_t **pppc)
00243 {
00244     ppctx_t *ppc = NULL;
00245 
00246     ppc = u_zalloc(<span class="keyword">sizeof</span>(ppctx_t));
00247     dbg_err_if(ppc == NULL);
00248 
00249     dbg_err_if(block_create(NULL, NULL, 0, &amp;ppc-&gt;top));
00250     dbg_err_if(block_create(NULL, NULL, 0, &amp;ppc-&gt;dead));
00251 
00252     dbg_err_if(u_list_create(&amp;ppc-&gt;depend));
00253 
00254     ppc-&gt;cur = ppc-&gt;top;
00255     ppc-&gt;dead-&gt;parent = ppc-&gt;top;
00256 
00257     *pppc = ppc;
00258 
00259     <span class="keywordflow">return</span> 0;
00260 err:
00261     <span class="keywordflow">if</span>(ppc)
00262         ppctx_free(ppc);
00263     <span class="keywordflow">return</span> ~0;
00264 }
00265 
00266 <span class="comment">/* print parser context to the console */</span>
00267 <span class="keyword">static</span> <span class="keywordtype">void</span> con_p_ctx(parser_t *p)
00268 {
00269     <span class="keywordtype">char</span> fn[U_FILENAME_MAX];
00270 
00271     dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(p-&gt;in, fn, U_FILENAME_MAX));
00272 
00273     <span class="comment">/* con_ macro should be used here; we'd need a con_no_newline(...) */</span>
00274     fprintf(stderr, <span class="stringliteral">"[%s:%d]: error: "</span>, fn, p-&gt;code_line);
00275 
00276 err:
00277     <span class="keywordflow">return</span>;
00278 }
00279 
00280 <span class="keywordtype">int</span> translate_makefile_filepath(<span class="keyword">const</span> <span class="keywordtype">char</span> *filepath, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, 
00281     <span class="keywordtype">char</span> *buf, size_t size)
00282 {
00283     <span class="keywordtype">char</span> file_in[U_FILENAME_MAX];
00284 
00285     <span class="comment">/* input file */</span>
00286     <span class="keywordflow">if</span>(filepath[0] == <span class="charliteral">'/'</span> || filepath[0] == <span class="charliteral">'\\'</span>)
00287     {   <span class="comment">/* absolute path */</span>
00288         dbg_err_if(u_snprintf(file_in, U_FILENAME_MAX, <span class="stringliteral">"%s"</span>, filepath));
00289     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(isalpha(filepath[0]) &amp;&amp; filepath[1] == <span class="charliteral">':'</span>) {
00290         <span class="comment">/* absolute path Windows (X:/....) */</span>
00291         dbg_err_if(u_snprintf(file_in, U_FILENAME_MAX, <span class="stringliteral">"%s"</span>, filepath));
00292     } <span class="keywordflow">else</span> {
00293         <span class="comment">/* relative path, use $(srcdir) */</span>
00294         dbg_err_if(u_snprintf(file_in, U_FILENAME_MAX, <span class="stringliteral">"%s/%s"</span>, prefix, 
00295             filepath ));
00296     }
00297 
00298     dbg_err_if(strlcpy(buf, file_in, size) &gt;= size);
00299 
00300     <span class="keywordflow">return</span> 0;
00301 err:
00302     <span class="keywordflow">return</span> ~0;
00303 }
00304 
00305 <span class="keywordtype">int</span> translate_is_a_script(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
00306 {
00307     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *script_ext[] = { 
00308         <span class="stringliteral">".klone"</span>, <span class="stringliteral">".kl1"</span>, <span class="stringliteral">".klc"</span>, 
00309         <span class="stringliteral">".klx"</span>,  <span class="comment">/* C++ page */</span>
00310         NULL 
00311     };
00312     <span class="keyword">const</span> <span class="keywordtype">char</span> **ext;
00313 
00314     dbg_return_if(filename == NULL, 0);
00315 
00316     <span class="comment">/* try to find an index page between default index uris */</span>
00317     <span class="keywordflow">for</span>(ext = script_ext; *ext; ++ext)
00318     {
00319         <span class="comment">/* case insensitive matching */</span>
00320         <span class="keywordflow">if</span>(<a class="code" href="group__ut.html#ga49">u_match_ext</a>(filename, *ext))
00321             <span class="keywordflow">return</span> 1;
00322     }
00323     <span class="keywordflow">return</span> 0;
00324 }
00325 
00326 <span class="keyword">static</span> <span class="keywordtype">int</span> include_file_full_path(parser_t *p, <span class="keywordtype">char</span> *inc_file, <span class="keywordtype">char</span> *obuf, 
00327     size_t size)
00328 {
00329     <span class="keywordtype">char</span> buf[U_FILENAME_MAX], *pc;
00330 
00331     <span class="comment">/* get the name of the input file (that include filename path is relative</span>
00332 <span class="comment">     * to the one of the input file) */</span>
00333     dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(p-&gt;in, buf, U_FILENAME_MAX));
00334 
00335     <span class="comment">/* remove file name, just path is needed */</span>
00336     dbg_err_if((pc = strrchr(buf, <span class="charliteral">'/'</span>)) == NULL);
00337     ++pc; *pc = 0;
00338 
00339     dbg_err_if(strlcat(buf, inc_file, U_FILENAME_MAX) &gt;= U_FILENAME_MAX);
00340 
00341     dbg_err_if(strlcpy(obuf, buf, size) &gt;= size);
00342 
00343     <span class="keywordflow">return</span> 0;
00344 err:
00345     <span class="keywordflow">return</span> ~0;
00346 }
00347 
00348 <span class="keyword">static</span> <span class="keywordtype">int</span> process_directive_include(parser_t *p, <span class="keywordtype">char</span> *inc_file)
00349 {
00350     ppctx_t *ppc;
00351     <span class="keywordtype">char</span> fullpath[U_FILENAME_MAX], file[U_FILENAME_MAX];
00352     io_t *io = NULL;
00353 
00354     dbg_return_if (p == NULL, ~0);
00355     dbg_return_if (inc_file == NULL, ~0);
00356 
00357     dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(p-&gt;in, file, U_FILENAME_MAX));
00358 
00359     dbg_err_if(include_file_full_path(p, inc_file, fullpath, U_FILENAME_MAX));
00360 
00361     <span class="comment">/* copy include file to p-&gt;out */</span>
00362     tr_err_ifm(<a class="code" href="group__ut.html#ga35">u_file_open</a>(fullpath, O_RDONLY, &amp;io), 
00363         <span class="stringliteral">"unable to open included file %s"</span>, fullpath);
00364 
00365     dbg_err_if(<a class="code" href="group__basic.html#ga28">io_printf</a>(p-&gt;out, <span class="stringliteral">"&lt;%% #line 1 \"%s\" \n %%&gt;"</span>, fullpath));
00366 
00367     <span class="comment">/* get the current preprocessor context */</span>
00368     ppc = parser_get_cb_arg(p);
00369     dbg_err_if(preprocess(io, p-&gt;out, ppc));
00370 
00371     dbg_err_if(<a class="code" href="group__basic.html#ga28">io_printf</a>(p-&gt;out, <span class="stringliteral">"&lt;%% #line %d \"%s\" \n %%&gt;"</span>, 
00372         p-&gt;code_line, file));
00373 
00374     <a class="code" href="group__basic.html#ga14">io_free</a>(io);
00375 
00376     <span class="keywordflow">return</span> 0;
00377 err:
00378     <span class="keywordflow">if</span>(io)
00379         <a class="code" href="group__basic.html#ga14">io_free</a>(io);
00380     <span class="keywordflow">return</span> ~0;
00381 }
00382 
00383 <span class="keyword">static</span> <span class="keywordtype">int</span> block_get_by_name(block_t *parent, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, 
00384     block_t **pfound, size_t *pidx)
00385 {
00386     block_t *b;
00387     size_t i;
00388 
00389     dbg_err_if(parent == NULL);
00390 
00391     <span class="keywordflow">for</span>(i = 0; (b = u_list_get_n(parent-&gt;children, i)) != NULL; ++i)
00392     {
00393         <span class="keywordflow">if</span>(b-&gt;name &amp;&amp; strcasecmp(b-&gt;name, name) == 0)
00394         {
00395             *pfound = b;
00396             *pidx = i;
00397             <span class="keywordflow">return</span> 0;
00398         }
00399         <span class="keywordflow">if</span>(block_get_by_name(b, name, pfound, pidx) == 0)
00400             <span class="keywordflow">return</span> 0;
00401     }
00402         
00403 err:
00404     <span class="keywordflow">return</span> ~0;
00405 }
00406 
00407 <span class="keyword">static</span> <span class="keywordtype">int</span> process_directive_block(parser_t *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00408 {
00409     block_t *block = NULL, *old;
00410     ppctx_t *ppc;
00411     <span class="keywordtype">char</span> file[U_FILENAME_MAX];
00412     size_t idx;
00413 
00414     dbg_err_if((ppc = parser_get_cb_arg(p)) == NULL);
00415 
00416     <span class="comment">/* create a named block */</span>
00417     dbg_err_if(block_create(name, NULL, 0, &amp;block));
00418 
00419     dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(p-&gt;in, file, U_FILENAME_MAX));
00420 
00421     ppc-&gt;lev++;
00422 
00423     <span class="keywordflow">if</span>(!ppc-&gt;extending)
00424     {
00425         con_err_ifm(!block_get_by_name(ppc-&gt;top, name, &amp;old, &amp;idx),
00426             <span class="stringliteral">"[%s:%d] error: block named %s already exists"</span>, file, p-&gt;code_line,
00427             name);
00428 
00429         <span class="comment">/* new block -&gt; append to the block list */</span>
00430         dbg_err_if(block_push_child(ppc-&gt;cur, block));
00431 
00432         ppc-&gt;cur = block;
00433 
00434         <span class="keywordflow">return</span> 0;
00435     }
00436 
00437     ppc-&gt;extending++; <span class="comment">/* increase the nesting level */</span>
00438 
00439     <span class="comment">/* we're extending a base template... */</span>
00440      
00441     <span class="keywordflow">if</span>(block_get_by_name(ppc-&gt;top, name, &amp;old, &amp;idx))
00442     {
00443         <span class="keywordflow">if</span>(ppc-&gt;cur == ppc-&gt;top)
00444         {
00445             <span class="comment">/* top-level block */</span>
00446             con(<span class="stringliteral">"[%s:%d] warning: extending a block (%s) that does not exist "</span>
00447                 <span class="stringliteral">"in the base templates, ignoring"</span>, file, p-&gt;code_line, name);
00448 
00449             <span class="comment">/* attach it to a dead tree (i.e. a tree that doesn't get printed)*/</span>
00450             dbg_err_if(block_push_child(ppc-&gt;dead, block));
00451 
00452         } <span class="keywordflow">else</span> {
00453 
00454             <span class="keywordflow">if</span>(ppc-&gt;lev)
00455             {
00456                 <span class="comment">/* nested block */</span>
00457                 dbg_err_if(block_push_child(ppc-&gt;cur, block));
00458             }
00459         }
00460 
00461     } <span class="keywordflow">else</span> {
00462         <span class="comment">/* overriding block */</span>
00463 
00464         <span class="comment">/* block with the same name as been found at position 'idx' of</span>
00465 <span class="comment">           its parent's list; replace the old block with the new one</span>
00466 <span class="comment">           and save the old in new-&gt;ancestor (we may need it for</span>
00467 <span class="comment">           &lt;% block inherit %&gt;) */</span>
00468 
00469         <span class="comment">/* save the old block ptr */</span>
00470         block-&gt;ancestor = old;
00471         block-&gt;parent = old-&gt;parent;
00472 
00473         <span class="comment">/* insert the new block in the position of the old block */</span>
00474         dbg_err_if(u_list_insert(old-&gt;parent-&gt;children, block, idx));
00475 
00476         <span class="comment">/* remove the old block from the list */</span>
00477         dbg_err_if(u_list_del(old-&gt;parent-&gt;children, old));
00478     }
00479 
00480     ppc-&gt;cur = block;
00481 
00482     <span class="keywordflow">return</span> 0;
00483 err:
00484     <span class="keywordflow">if</span>(block)
00485         block_free(block);
00486     <span class="keywordflow">return</span> ~0;
00487 }
00488 
00489 <span class="keyword">static</span> <span class="keywordtype">int</span> process_directive_endblock(parser_t *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00490 {
00491     ppctx_t *ppc;
00492 
00493     dbg_err_if((ppc = parser_get_cb_arg(p)) == NULL);
00494 
00495     dbg_err_if(ppc-&gt;cur == NULL);
00496 
00497     tr_err_ifm(--ppc-&gt;lev &lt; 0, <span class="stringliteral">"unbalanced endblock directive"</span>);
00498 
00499     <span class="comment">/* if name is provided check that it's correct */</span>
00500     <span class="keywordflow">if</span>(name)
00501         tr_err_ifm(ppc-&gt;cur-&gt;name == NULL || strcasecmp(name, ppc-&gt;cur-&gt;name),
00502             <span class="stringliteral">"endblock name is not correct (\"%s\" used when closing to "</span>
00503             <span class="stringliteral">"\"%s\" block)"</span>, name, ppc-&gt;cur-&gt;name);
00504 
00505     ppc-&gt;cur = ppc-&gt;cur-&gt;parent; <span class="comment">/* may be NULL */</span>
00506 
00507     <span class="keywordflow">if</span>(ppc-&gt;extending)
00508     {
00509         <span class="comment">/* decrease the nesting level */</span>
00510         <span class="keywordflow">if</span>(--ppc-&gt;extending == 1)
00511             ppc-&gt;cur = ppc-&gt;top;
00512     }
00513 
00514     <span class="keywordflow">return</span> 0;
00515 err:
00516     <span class="keywordflow">return</span> ~0;
00517 }
00518 
00519 <span class="keyword">static</span> <span class="keywordtype">int</span> process_directive_inherit(parser_t *p)
00520 {
00521     ppctx_t *ppc;
00522     block_t *anc, *b;
00523     <span class="keywordtype">int</span> i;
00524 
00525     dbg_err_if((ppc = parser_get_cb_arg(p)) == NULL);
00526 
00527     dbg_err_if(ppc-&gt;cur == NULL);
00528 
00529     anc = ppc-&gt;cur-&gt;ancestor;
00530     tr_err_ifm(anc == NULL, <span class="stringliteral">"inherit directive used in a block "</span>
00531         <span class="stringliteral">"(\"%s\") that is not extending another block"</span>, ppc-&gt;cur-&gt;name);
00532 
00533     <span class="comment">/* move all ancestor children to the current block (that's the block whom</span>
00534 <span class="comment">     * is extending the ancestor */</span>
00535     <span class="keywordflow">for</span>(i = 0; (b = u_list_get_n(anc-&gt;children, i)) != NULL; ++i)
00536         dbg_err_if(block_push_child(ppc-&gt;cur, b));
00537 
00538     <span class="comment">/* remove all elems */</span>
00539     <span class="keywordflow">while</span>(u_list_count(anc-&gt;children))
00540         dbg_err_if(u_list_del_n(anc-&gt;children, 0, NULL));
00541 
00542     <span class="keywordflow">return</span> 0;
00543 err:
00544     <span class="keywordflow">return</span> ~0;
00545 }
00546 
00547 <span class="keyword">static</span> <span class="keywordtype">int</span> process_directive(parser_t *p, <span class="keywordtype">char</span> *buf)
00548 {
00549     ppctx_t *ppc;
00550     <span class="keywordtype">char</span> *tok, *pp;
00551     <span class="keywordtype">char</span> fullpath[U_FILENAME_MAX];
00552 
00553     dbg_return_if (p == NULL, ~0);
00554     dbg_return_if (buf == NULL, ~0);
00555 
00556     <span class="comment">/* preprocessor context */</span>
00557     dbg_err_if((ppc = parser_get_cb_arg(p)) == NULL);
00558 
00559     <span class="comment">/* get preprocessor command */</span>
00560     tr_err_ifm((tok = strtok_r(buf, <span class="stringliteral">" \t"</span>, &amp;pp)) == NULL,
00561         <span class="stringliteral">"bad or missing preprocessor command"</span>);
00562 
00563     <span class="keywordflow">if</span>(strcasecmp(tok, <span class="stringliteral">"include"</span>) == 0)
00564     {
00565         <span class="comment">/* get include file name */</span>
00566         tr_err_ifm((tok = strtok_r(NULL, <span class="stringliteral">" \t\""</span>, &amp;pp)) == NULL,
00567             <span class="stringliteral">"bad or missing include filename"</span>);
00568 
00569         <span class="comment">/* calc the full path of the included file and add it to the deps list*/</span>
00570         dbg_err_if(include_file_full_path(p, tok, fullpath, U_FILENAME_MAX));
00571 
00572         dbg_err_if(ppctx_depend_push(ppc, fullpath));
00573 
00574         dbg_err_if(process_directive_include(p, tok));
00575 
00576     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcasecmp(tok, <span class="stringliteral">"extends"</span>) == 0) { 
00577 
00578         <span class="comment">/* get base file name */</span>
00579         tr_err_ifm((tok = strtok_r(NULL, <span class="stringliteral">" \t\""</span>, &amp;pp)) == NULL,
00580             <span class="stringliteral">"bad or missing 'extends' filename"</span>);
00581 
00582         tr_err_ifm(p-&gt;code_line &gt; 1, <span class="stringliteral">"child templates must start with the "</span>
00583             <span class="stringliteral">"'&lt;%@ extends \"FILE\" %&gt;' directive (first line) %d"</span>);
00584 
00585         <span class="comment">/* calc the full path of the included file and add it to the deps list*/</span>
00586         dbg_err_if(include_file_full_path(p, tok, fullpath, U_FILENAME_MAX));
00587 
00588         dbg_err_if(ppctx_depend_push(ppc, fullpath));
00589 
00590         <span class="comment">/* no difference with include? */</span>
00591         dbg_err_if(process_directive_include(p, tok));
00592 
00593         con_err_ifm(ppc-&gt;lev, <span class="stringliteral">"[%s] error: unclosed block \"%s\""</span>, tok, 
00594             ppc-&gt;cur-&gt;name);
00595 
00596         ppc-&gt;extending++;
00597 
00598     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcasecmp(tok, <span class="stringliteral">"block"</span>) == 0) { 
00599 
00600         <span class="comment">/* get block name */</span>
00601         tr_err_ifm((tok = strtok_r(NULL, <span class="stringliteral">" \t\""</span>, &amp;pp)) == NULL,
00602             <span class="stringliteral">"bad or missing 'block' name"</span>);
00603 
00604         dbg_err_if(process_directive_block(p, tok));
00605 
00606     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcasecmp(tok, <span class="stringliteral">"endblock"</span>) == 0) { 
00607 
00608         <span class="comment">/* try get the block name (it's not mandatory) */</span>
00609         tok = strtok_r(NULL, <span class="stringliteral">" \t\""</span>, &amp;pp);
00610 
00611         dbg_err_if(process_directive_endblock(p, tok));
00612 
00613     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcasecmp(tok, <span class="stringliteral">"inherit"</span>) == 0) { 
00614 
00615         dbg_err_if(process_directive_inherit(p));
00616 
00617     } <span class="keywordflow">else</span> {
00618         tr_err(<span class="stringliteral">"unknown preprocessor directive: %s"</span>, tok);
00619     }
00620 
00621     <span class="keywordflow">return</span> 0;
00622 err:
00623     <span class="keywordflow">return</span> ~0;
00624 }
00625 
00626 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_directive(parser_t *p, <span class="keywordtype">void</span> *arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t sz)
00627 {
00628     <span class="keyword">enum</span> { LINE_BUFSZ = 1024 };
00629     <span class="keywordtype">char</span> line[LINE_BUFSZ];
00630     io_t *io = NULL;
00631 
00632     u_unused_args(arg);
00633 
00634     dbg_return_if (p == NULL, ~0);
00635     dbg_return_if (buf == NULL, ~0);
00636     
00637     dbg_err_if(io_mem_create((<span class="keywordtype">char</span>*)buf, sz, 0, &amp;io));
00638 
00639     <span class="keywordflow">while</span>(<a class="code" href="group__basic.html#ga25">io_gets</a>(io, line, LINE_BUFSZ) &gt; 0)
00640         dbg_err_if(process_directive(p, line));
00641 
00642     <a class="code" href="group__basic.html#ga14">io_free</a>(io);
00643 
00644     <span class="keywordflow">return</span> 0;
00645 err:
00646     <span class="keywordflow">if</span>(io)
00647         <a class="code" href="group__basic.html#ga14">io_free</a>(io);
00648     <span class="keywordflow">return</span> ~0;
00649 }
00650 
00651 <span class="keyword">static</span> <span class="keywordtype">int</span> cb_pre_html_block(parser_t *p, <span class="keywordtype">void</span> *arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, size_t sz)
00652 {
00653     ppctx_t *ppc = (ppctx_t*)arg;
00654     block_t *block = NULL;
00655     <span class="keywordtype">char</span> file[U_FILENAME_MAX];
00656     <span class="keywordtype">int</span> i, ln;
00657 
00658     u_unused_args(arg);
00659 
00660     dbg_err_if (p == NULL);
00661     dbg_err_if (ppc == NULL);
00662 
00663     <span class="comment">/* create and append un unnamed */</span>
00664     dbg_err_if(block_create(NULL, buf, sz, &amp;block));
00665 
00666     <span class="keywordflow">if</span>(ppc-&gt;cur == ppc-&gt;top &amp;&amp; ppc-&gt;extending)
00667     {
00668         <span class="keywordflow">for</span>(ln = p-&gt;code_line, i = 0; i &lt; sz; ++i)
00669         {
00670             <span class="keywordflow">if</span>(buf[i] == <span class="charliteral">'\n'</span>)
00671                 ln++; <span class="comment">/* find out the line of the first not-blank char */</span>
00672             <span class="keywordflow">if</span>(!isspace(buf[i]))
00673             {
00674                 dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(p-&gt;in, file, U_FILENAME_MAX));
00675                 con(<span class="stringliteral">"[%s:%d] warning: text out of blocks is not allowed in "</span>
00676                     <span class="stringliteral">"child templates, ignoring"</span>, file, ln);
00677                 <span class="keywordflow">break</span>;
00678             }
00679         }
00680 
00681         <span class="comment">/* attach it to a dead tree (i.e. a tree that doesn't get printed)*/</span>
00682         dbg_err_if(block_push_child(ppc-&gt;dead, block));
00683     } <span class="keywordflow">else</span> {
00684 
00685         <span class="comment">/* append the text block to the block list */</span>
00686         dbg_err_if(block_push_child(ppc-&gt;cur, block));
00687     }
00688 
00689     <span class="keywordflow">return</span> 0;
00690 err:
00691     <span class="keywordflow">return</span> ~0;
00692 }
00693 
00694 <span class="keyword">static</span> <span class="keywordtype">int</span> cb_pre_code_block(parser_t *p, <span class="keywordtype">int</span> cmd, <span class="keywordtype">void</span> *arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, 
00695         size_t sz)
00696 {
00697     u_string_t *ustr = NULL;
00698     block_t *block = NULL;
00699     ppctx_t *ppc;
00700     <span class="keywordtype">char</span> file[U_FILENAME_MAX];
00701 
00702     dbg_err_if (p == NULL);
00703     dbg_err_if((ppc = parser_get_cb_arg(p)) == NULL);
00704 
00705     <span class="keywordflow">if</span>(cmd == <span class="charliteral">'@'</span>)
00706     {   <span class="comment">/* do preprocess */</span>
00707         dbg_err_if(parse_directive(p, arg, buf, sz));
00708     } <span class="keywordflow">else</span> {
00709         <span class="comment">/* append the code to the current block */</span>
00710         dbg_err_if(u_string_create(NULL, 0, &amp;ustr));
00711 
00712         dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(p-&gt;in, file, U_FILENAME_MAX));
00713 
00714         <span class="comment">/* we must know the file:line where this code is coming from */</span>
00715         <span class="keywordflow">if</span>(cmd == 0 || cmd == <span class="charliteral">'='</span>)
00716         {
00717             dbg_err_if(u_string_aprintf(ustr, <span class="stringliteral">"&lt;%% #line %d \"%s\" \n%%&gt;&lt;%%"</span>, 
00718                  p-&gt;code_line, file)); 
00719             <span class="keywordflow">if</span>(cmd == <span class="charliteral">'='</span>)
00720                 dbg_err_if(u_string_aprintf(ustr, <span class="stringliteral">"="</span>));
00721         } <span class="keywordflow">else</span> {
00722             dbg_err_if(u_string_aprintf(ustr, 
00723                 <span class="stringliteral">"&lt;%%%c #line %d \"%s\" \n%%&gt;&lt;%%%c"</span>, 
00724                  cmd, p-&gt;code_line, file, cmd)); 
00725         }
00726         dbg_err_if(u_string_aprintf(ustr, <span class="stringliteral">"%.*s"</span>, sz, buf));
00727         dbg_err_if(u_string_aprintf(ustr, <span class="stringliteral">"%%&gt;"</span>));
00728 
00729         <span class="comment">/* placeholder to be subst'd in the last translation phase */</span>
00730         dbg_err_if(u_string_aprintf(ustr, <span class="stringliteral">"&lt;%%%c #line 0 __PG_FILE_C__ \n%%&gt;"</span>, 
00731                     (cmd == <span class="charliteral">'!'</span> &amp;&amp; cmd != 0 ? cmd : <span class="charliteral">' '</span>)));
00732 
00733         dbg_err_if(block_create(NULL, u_string_c(ustr), u_string_len(ustr), 
00734                     &amp;block));
00735 
00736         <span class="keywordflow">if</span>(ppc-&gt;cur == ppc-&gt;top &amp;&amp; ppc-&gt;extending)
00737         {
00738             dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(p-&gt;in, file, U_FILENAME_MAX));
00739             con(<span class="stringliteral">"[%s:%d] warning: code out of blocks is not allowed in child "</span>
00740                 <span class="stringliteral">"templates, ignoring"</span>, file, p-&gt;code_line);
00741 
00742             <span class="comment">/* attach it to a dead tree (i.e. a tree that doesn't get printed)*/</span>
00743             dbg_err_if(block_push_child(ppc-&gt;dead, block));
00744         } <span class="keywordflow">else</span> {
00745 
00746             dbg_err_if(block_push_child(ppc-&gt;cur, block));
00747         }
00748 
00749         dbg_err_if(u_string_free(ustr));
00750         ustr = NULL;
00751     }
00752 
00753     <span class="keywordflow">return</span> 0;
00754 err:
00755     <span class="keywordflow">if</span>(ustr)
00756         u_string_free(ustr);
00757     <span class="keywordflow">if</span>(block)
00758         block_free(block);
00759     <span class="keywordflow">return</span> ~0;
00760 }
00761 
00762 <span class="keyword">static</span> <span class="keywordtype">int</span> preprocess(io_t *in, io_t *out, ppctx_t *ppc)
00763 {
00764     parser_t *p = NULL;
00765     <span class="keywordtype">char</span> file[U_FILENAME_MAX];
00766 
00767     dbg_err_if(in == NULL);
00768     dbg_err_if(out == NULL);
00769     dbg_err_if(ppc == NULL);
00770 
00771     <span class="comment">/* create a parse that reads from in and writes to out */</span>
00772     dbg_err_if(parser_create(&amp;p));
00773 
00774     parser_set_cb_arg(p, ppc);
00775 
00776     <span class="comment">/* input filename */</span>
00777     dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(in, file, U_FILENAME_MAX));
00778 
00779     parser_set_io(p, in, out);
00780 
00781     parser_set_cb_code(p, cb_pre_code_block);
00782     parser_set_cb_html(p, cb_pre_html_block);
00783 
00784     dbg_err_if(parser_run(p));
00785 
00786     con_err_ifm(ppc-&gt;lev, <span class="stringliteral">"[%s] error: unclosed block \"%s\""</span>, file, 
00787         ppc-&gt;cur-&gt;name);
00788 
00789     parser_free(p);
00790 
00791     <span class="keywordflow">return</span> 0;
00792 err:
00793     <span class="keywordflow">if</span>(p)
00794         parser_free(p);
00795     <span class="keywordflow">return</span> ~0;
00796 }
00797 
00798 <span class="keyword">static</span> <span class="keywordtype">int</span> fix_line_decl(trans_info_t *pti)
00799 {
00800     io_t *in = NULL, *tmp = NULL;
00801     <span class="keywordtype">char</span> tname[U_FILENAME_MAX], buf[1024];
00802     <span class="keywordtype">int</span> ln = 0;
00803 
00804     <span class="comment">/* open the input file */</span>
00805     con_err_ifm(<a class="code" href="group__ut.html#ga35">u_file_open</a>(pti-&gt;file_out, O_RDONLY, &amp;in),
00806         <span class="stringliteral">"unable to open %s"</span>, pti-&gt;file_out);
00807 
00808     <span class="comment">/* get a temporary io_t */</span>
00809     con_err_if(<a class="code" href="group__ut.html#ga36">u_tmpfile_open</a>(NULL, &amp;tmp));
00810 
00811     <span class="keywordflow">while</span>(<a class="code" href="group__basic.html#ga25">io_gets</a>(in, buf, <span class="keyword">sizeof</span>(buf)) &gt; 0)
00812     {
00813         <span class="keywordflow">if</span>(strstr(buf, <span class="stringliteral">"#line 0 __PG_FILE_C__"</span>) == NULL)
00814         {
00815             <a class="code" href="group__basic.html#ga28">io_printf</a>(tmp, <span class="stringliteral">"%s"</span>, buf);
00816             ln++; <span class="comment">/* line number */</span>
00817         } <span class="keywordflow">else</span>
00818             <a class="code" href="group__basic.html#ga28">io_printf</a>(tmp, <span class="stringliteral">"#line %d \"%s\""</span>, ln + 2, pti-&gt;file_out);
00819     }
00820 
00821     <span class="comment">/* get the filename of the temporary io_t */</span>
00822     dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(tmp, tname, U_FILENAME_MAX));
00823 
00824     <a class="code" href="group__basic.html#ga14">io_free</a>(in), in = NULL;
00825     <a class="code" href="group__basic.html#ga14">io_free</a>(tmp), tmp = NULL;
00826 
00827     <span class="comment">/* move tmp to file_out */</span>
00828     u_remove(pti-&gt;file_out);
00829 
00830     u_move(tname, pti-&gt;file_out);
00831 
00832     <span class="keywordflow">return</span> 0;
00833 err:
00834     <span class="keywordflow">if</span>(in)
00835         <a class="code" href="group__basic.html#ga14">io_free</a>(in);
00836     <span class="keywordflow">if</span>(tmp)
00837         <a class="code" href="group__basic.html#ga14">io_free</a>(tmp);
00838     <span class="keywordflow">return</span> ~0;
00839 }
00840 
00841 <span class="keywordtype">int</span> translate(trans_info_t *pti)
00842 {
00843     io_t *in = NULL, *out = NULL, *tmp = NULL, *depend = NULL;
00844     ppctx_t *ppc = NULL;
00845     codec_t *gzip = NULL, *aes = NULL;
00846     <span class="keywordtype">char</span> tname[U_FILENAME_MAX];
00847 
00848     dbg_return_if (pti == NULL, ~0);
00849     
00850     <span class="comment">/* open the input file */</span>
00851     con_err_ifm(<a class="code" href="group__ut.html#ga35">u_file_open</a>(pti-&gt;file_in, O_RDONLY, &amp;in),
00852         <span class="stringliteral">"unable to open %s"</span>, pti-&gt;file_in);
00853 
00854     <span class="comment">/* open the output file */</span>
00855     con_err_ifm(<a class="code" href="group__ut.html#ga35">u_file_open</a>(pti-&gt;file_out, O_CREAT | O_TRUNC | O_WRONLY, &amp;out),
00856         <span class="stringliteral">"unable to open %s"</span>, pti-&gt;file_out);
00857 
00858     <span class="comment">/* open the depend output file */</span>
00859     <span class="keywordflow">if</span>(pti-&gt;depend_out[0])
00860         con_err_ifm(<a class="code" href="group__ut.html#ga35">u_file_open</a>(pti-&gt;depend_out, O_CREAT | O_TRUNC | O_WRONLY, 
00861             &amp;depend), <span class="stringliteral">"unable to open %s"</span>, pti-&gt;depend_out);
00862 
00863     <span class="comment">/* should choose the right translator based on file extensions or config */</span>
00864     <span class="keywordflow">if</span>(translate_is_a_script(pti-&gt;file_in))
00865     {
00866         <span class="comment">/* get a temporary io_t */</span>
00867         con_err_if(<a class="code" href="group__ut.html#ga36">u_tmpfile_open</a>(NULL, &amp;tmp));
00868 
00869         <span class="comment">/* create a preprocessor context */</span>
00870         dbg_err_if(ppctx_create(&amp;ppc));
00871 
00872         <span class="comment">/* save the preprocessed in file to tmp */</span>
00873         dbg_err_if(preprocess(in, tmp, ppc));
00874 
00875         <span class="comment">/* print out the preprocessed file */</span>
00876         dbg_err_if(ppctx_print(ppc, tmp));
00877 
00878         <span class="comment">/* reset the tmp io */</span>
00879         <a class="code" href="group__basic.html#ga21">io_seek</a>(tmp, 0);
00880 
00881         <span class="comment">/* translate it */</span>
00882         dbg_err_if(translate_script_to_c(tmp, out, pti));
00883 
00884         <span class="comment">/* get the filename of the temporary io_t */</span>
00885         dbg_err_if(<a class="code" href="group__basic.html#ga17">io_name_get</a>(tmp, tname, U_FILENAME_MAX));
00886 
00887         <span class="comment">/* free the tmp io */</span>
00888         <a class="code" href="group__basic.html#ga14">io_free</a>(tmp); tmp = NULL;
00889 
00890         <span class="comment">/* remove the tmp file */</span>
00891         u_remove(tname);
00892 
00893         <span class="comment">/* print out the depend .kld file */</span>
00894         <span class="keywordflow">if</span>(depend)
00895             dbg_err_if(ppctx_print_depend(ppc, in, out, depend));
00896 
00897         dbg_err_if(ppctx_free(ppc)); ppc = NULL;
00898     } <span class="keywordflow">else</span> {
00899         <span class="comment">/* check if compression is requested */</span>
00900 <span class="preprocessor">#ifdef HAVE_LIBZ</span>
00901 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(pti-&gt;comp)
00902         {
00903             <span class="comment">/* set a compression filter to the input stream */</span>
00904             dbg_err_if(<a class="code" href="group__filters.html#ga2">codec_gzip_create</a>(GZIP_COMPRESS, &amp;gzip));
00905             dbg_err_if(<a class="code" href="group__basic.html#ga32">io_codec_add_tail</a>(in, gzip));
00906             gzip = NULL;
00907         }
00908 <span class="preprocessor">#endif</span>
00909 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_LIBOPENSSL</span>
00910 <span class="preprocessor"></span>        <span class="comment">/* check if encryption is requested */</span>
00911         <span class="keywordflow">if</span>(pti-&gt;encrypt)
00912         {
00913             <span class="comment">/* set a cipher filter */</span>
00914             dbg_err_if(<a class="code" href="group__filters.html#ga0">codec_cipher_create</a>(CIPHER_ENCRYPT, EVP_aes_256_cbc(),
00915                 pti-&gt;key, NULL, &amp;aes));
00916             dbg_err_if(<a class="code" href="group__basic.html#ga32">io_codec_add_tail</a>(in, aes));
00917             aes = NULL;
00918         }
00919 <span class="preprocessor">#endif</span>
00920 <span class="preprocessor"></span>        dbg_err_if(translate_opaque_to_c(in, out, pti));
00921     }
00922 
00923     <span class="keywordflow">if</span>(pti-&gt;depend_out[0])
00924         <a class="code" href="group__basic.html#ga14">io_free</a>(depend), depend = NULL;
00925 
00926     <a class="code" href="group__basic.html#ga14">io_free</a>(out), out = NULL;
00927     <a class="code" href="group__basic.html#ga14">io_free</a>(in), in = NULL;
00928 
00929     <span class="comment">/* replace '#line 0 __PG_FILE_C__' lines with '#line N "real_filename.c"' */</span>
00930     <span class="keywordflow">if</span>(translate_is_a_script(pti-&gt;file_in))
00931         dbg_err_if(fix_line_decl(pti));
00932 
00933     <span class="keywordflow">return</span> 0;
00934 err:
00935     <span class="keywordflow">if</span>(pti &amp;&amp; strlen(pti-&gt;emsg))
00936         con(<span class="stringliteral">"%s"</span>, pti-&gt;emsg);
00937     <span class="keywordflow">if</span>(gzip)
00938         <a class="code" href="group__filters.html#ga9">codec_free</a>(gzip);
00939     <span class="keywordflow">if</span>(tmp)
00940         <a class="code" href="group__basic.html#ga14">io_free</a>(tmp);
00941     <span class="keywordflow">if</span>(depend)
00942         <a class="code" href="group__basic.html#ga14">io_free</a>(depend);
00943     <span class="keywordflow">if</span>(in)
00944         <a class="code" href="group__basic.html#ga14">io_free</a>(in);
00945     <span class="keywordflow">if</span>(out)
00946         <a class="code" href="group__basic.html#ga14">io_free</a>(out);
00947     <span class="keywordflow">return</span> ~0;
00948 }
</pre></div>
    </div>

    <div id="footer">
        <p>Copyright &copy; 
    2005-2007 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
         | Valid <a
        href="http://jigsaw.w3.org/css-validator/">CSS</a> &amp; <a
        href="http://validator.w3.org/">XHTML</a> | powered by <a
        href="/klone/index.html">KLone</a> </p>
    </div>
</body>

</html>


